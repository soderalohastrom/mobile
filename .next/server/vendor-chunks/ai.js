"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useObject: () => (/* binding */ experimental_useObject),\n/* harmony export */   useAssistant: () => (/* binding */ useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/react */ \"(ssr)/./node_modules/@ai-sdk/react/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ experimental_useObject,useAssistant,useChat,useCompletion auto */ // react/index.ts\n\nvar useChat = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.useChat;\nvar useCompletion = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.useCompletion;\nvar useAssistant = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.useAssistant;\nvar experimental_useObject = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.experimental_useObject;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBS087QUFFQSxJQUFNQSxVQUFVQyxrREFBWUE7QUFDNUIsSUFBTUMsZ0JBQWdCQyx3REFBa0JBO0FBQ3hDLElBQU1DLGVBQWVDLHVEQUFpQkE7QUFDdEMsSUFBTUMseUJBQXlCQyxpRUFBMkJBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNzaXN0YW50LXVpLXN0YXJ0ZXIvLi4vaW5kZXgudHM/NzMxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICB1c2VDaGF0IGFzIHVzZUNoYXRSZWFjdCxcbiAgdXNlQ29tcGxldGlvbiBhcyB1c2VDb21wbGV0aW9uUmVhY3QsXG4gIHVzZUFzc2lzdGFudCBhcyB1c2VBc3Npc3RhbnRSZWFjdCxcbiAgZXhwZXJpbWVudGFsX3VzZU9iamVjdCBhcyBleHBlcmltZW50YWxfdXNlT2JqZWN0UmVhY3QsXG59IGZyb20gJ0BhaS1zZGsvcmVhY3QnO1xuXG5leHBvcnQgY29uc3QgdXNlQ2hhdCA9IHVzZUNoYXRSZWFjdDtcbmV4cG9ydCBjb25zdCB1c2VDb21wbGV0aW9uID0gdXNlQ29tcGxldGlvblJlYWN0O1xuZXhwb3J0IGNvbnN0IHVzZUFzc2lzdGFudCA9IHVzZUFzc2lzdGFudFJlYWN0O1xuZXhwb3J0IGNvbnN0IGV4cGVyaW1lbnRhbF91c2VPYmplY3QgPSBleHBlcmltZW50YWxfdXNlT2JqZWN0UmVhY3Q7XG5leHBvcnQgdHlwZSB7XG4gIENyZWF0ZU1lc3NhZ2UsXG4gIE1lc3NhZ2UsXG4gIFVzZUNoYXRPcHRpb25zLFxuICBVc2VDaGF0SGVscGVycyxcbn0gZnJvbSAnQGFpLXNkay9yZWFjdCc7XG4iXSwibmFtZXMiOlsidXNlQ2hhdCIsInVzZUNoYXRSZWFjdCIsInVzZUNvbXBsZXRpb24iLCJ1c2VDb21wbGV0aW9uUmVhY3QiLCJ1c2VBc3Npc3RhbnQiLCJ1c2VBc3Npc3RhbnRSZWFjdCIsImV4cGVyaW1lbnRhbF91c2VPYmplY3QiLCJleHBlcmltZW50YWxfdXNlT2JqZWN0UmVhY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError),\n/* harmony export */   AIStream: () => (/* binding */ AIStream),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError),\n/* harmony export */   AWSBedrockAnthropicMessagesStream: () => (/* binding */ AWSBedrockAnthropicMessagesStream),\n/* harmony export */   AWSBedrockAnthropicStream: () => (/* binding */ AWSBedrockAnthropicStream),\n/* harmony export */   AWSBedrockCohereStream: () => (/* binding */ AWSBedrockCohereStream),\n/* harmony export */   AWSBedrockLlama2Stream: () => (/* binding */ AWSBedrockLlama2Stream),\n/* harmony export */   AWSBedrockStream: () => (/* binding */ AWSBedrockStream),\n/* harmony export */   AnthropicStream: () => (/* binding */ AnthropicStream),\n/* harmony export */   AssistantResponse: () => (/* binding */ AssistantResponse),\n/* harmony export */   CohereStream: () => (/* binding */ CohereStream),\n/* harmony export */   DownloadError: () => (/* binding */ DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError),\n/* harmony export */   GoogleGenerativeAIStream: () => (/* binding */ GoogleGenerativeAIStream),\n/* harmony export */   HuggingFaceStream: () => (/* binding */ HuggingFaceStream),\n/* harmony export */   InkeepStream: () => (/* binding */ InkeepStream),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidResponseDataError),\n/* harmony export */   InvalidToolArgumentsError: () => (/* binding */ InvalidToolArgumentsError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError),\n/* harmony export */   LangChainAdapter: () => (/* binding */ langchain_adapter_exports),\n/* harmony export */   LangChainStream: () => (/* binding */ LangChainStream),\n/* harmony export */   LlamaIndexAdapter: () => (/* binding */ llamaindex_adapter_exports),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError),\n/* harmony export */   MessageConversionError: () => (/* binding */ MessageConversionError),\n/* harmony export */   MistralStream: () => (/* binding */ MistralStream),\n/* harmony export */   NoContentGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoContentGeneratedError),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   OpenAIStream: () => (/* binding */ OpenAIStream),\n/* harmony export */   ReplicateStream: () => (/* binding */ ReplicateStream),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   StreamData: () => (/* binding */ StreamData2),\n/* harmony export */   StreamingTextResponse: () => (/* binding */ StreamingTextResponse),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError),\n/* harmony export */   convertToCoreMessages: () => (/* binding */ convertToCoreMessages),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createCallbacksTransformer: () => (/* binding */ createCallbacksTransformer),\n/* harmony export */   createEventStreamTransformer: () => (/* binding */ createEventStreamTransformer),\n/* harmony export */   createStreamDataTransformer: () => (/* binding */ createStreamDataTransformer),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_AssistantResponse: () => (/* binding */ experimental_AssistantResponse),\n/* harmony export */   experimental_StreamData: () => (/* binding */ experimental_StreamData),\n/* harmony export */   experimental_createModelRegistry: () => (/* binding */ experimental_createModelRegistry),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_customProvider: () => (/* binding */ experimental_customProvider),\n/* harmony export */   experimental_generateObject: () => (/* binding */ experimental_generateObject),\n/* harmony export */   experimental_generateText: () => (/* binding */ experimental_generateText),\n/* harmony export */   experimental_streamObject: () => (/* binding */ experimental_streamObject),\n/* harmony export */   experimental_streamText: () => (/* binding */ experimental_streamText),\n/* harmony export */   experimental_wrapLanguageModel: () => (/* binding */ experimental_wrapLanguageModel),\n/* harmony export */   formatStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart),\n/* harmony export */   generateId: () => (/* binding */ generateId2),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.jsonSchema),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   parseStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.parseStreamPart),\n/* harmony export */   processDataProtocolResponse: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.processDataProtocolResponse),\n/* harmony export */   readDataStream: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.readDataStream),\n/* harmony export */   readableFromAsyncIterable: () => (/* binding */ readableFromAsyncIterable),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   streamToResponse: () => (/* binding */ streamToResponse),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   trimStartOfStreamHelper: () => (/* binding */ trimStartOfStreamHelper)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/ai/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/ai/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/trace-api.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/trace/status.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.mjs\");\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(rsc)/./node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name11 in all)\n    __defProp(target, name11, { get: all[name11], enumerable: true });\n};\n\n// streams/index.ts\n\n\n\n// core/index.ts\n\n\n// util/retry-with-exponential-backoff.ts\n\n\n\n// util/delay.ts\nasync function delay(delayInMs) {\n  return delayInMs === void 0 ? Promise.resolve() : new Promise((resolve) => setTimeout(resolve, delayInMs));\n}\n\n// util/retry-error.ts\n\nvar name = \"AI_RetryError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message,\n    reason,\n    errors\n  }) {\n    super({ name, message });\n    this[_a] = true;\n    this.reason = reason;\n    this.errors = errors;\n    this.lastError = errors[errors.length - 1];\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isRetryError(error) {\n    return error instanceof Error && error.name === name && typeof error.reason === \"string\" && Array.isArray(error.errors);\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      reason: this.reason,\n      lastError: this.lastError,\n      errors: this.errors\n    };\n  }\n};\n_a = symbol;\n\n// util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.isAbortError)(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await delay(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// core/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({\n  operationId,\n  telemetry\n}) {\n  return {\n    // standardized operation and resource name:\n    \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n    \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n    // detailed, AI SDK specific data:\n    \"ai.operationId\": operationId,\n    \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n  };\n}\n\n// core/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers\n}) {\n  var _a11;\n  return {\n    \"ai.model.provider\": model.provider,\n    \"ai.model.id\": model.modelId,\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {}),\n    // add metadata as attributes:\n    ...Object.entries((_a11 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a11 : {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {}\n    ),\n    // request headers\n    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {\n      if (value !== void 0) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {})\n  };\n}\n\n// core/telemetry/get-tracer.ts\n\n\n// core/telemetry/noop-tracer.ts\nvar noopTracer = {\n  startSpan() {\n    return noopSpan;\n  },\n  startActiveSpan(name11, arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === \"function\") {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === \"function\") {\n      return arg3(noopSpan);\n    }\n  }\n};\nvar noopSpan = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  }\n};\nvar noopSpanContext = {\n  traceId: \"\",\n  spanId: \"\",\n  traceFlags: 0\n};\n\n// core/telemetry/get-tracer.ts\nfunction getTracer({\n  isEnabled = false,\n  tracer\n} = {}) {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n  if (tracer) {\n    return tracer;\n  }\n  return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.trace.getTracer(\"ai\");\n}\n\n// core/telemetry/record-span.ts\n\nfunction recordSpan({\n  name: name11,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true\n}) {\n  return tracer.startActiveSpan(name11, { attributes }, async (span) => {\n    try {\n      const result = await fn(span);\n      if (endWhenDone) {\n        span.end();\n      }\n      return result;\n    } catch (error) {\n      try {\n        if (error instanceof Error) {\n          span.recordException({\n            name: error.name,\n            message: error.message,\n            stack: error.stack\n          });\n          span.setStatus({\n            code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__.SpanStatusCode.ERROR,\n            message: error.message\n          });\n        } else {\n          span.setStatus({ code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__.SpanStatusCode.ERROR });\n        }\n      } finally {\n        span.end();\n      }\n      throw error;\n    }\n  });\n}\n\n// core/telemetry/select-telemetry-attributes.ts\nfunction selectTelemetryAttributes({\n  telemetry,\n  attributes\n}) {\n  return Object.entries(attributes).reduce((attributes2, [key, value]) => {\n    if (value === void 0) {\n      return attributes2;\n    }\n    if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n        return attributes2;\n      }\n      const result = value.input();\n      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };\n    }\n    if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n        return attributes2;\n      }\n      const result = value.output();\n      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };\n    }\n    return { ...attributes2, [key]: value };\n  }, {});\n}\n\n// core/embed/embed.ts\nasync function embed({\n  model,\n  value,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embed\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embed\", telemetry }),\n        ...baseTelemetryAttributes,\n        \"ai.value\": { input: () => JSON.stringify(value) }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const { embedding, usage, rawResponse } = await retry(\n        () => (\n          // nested spans to align with the embedMany telemetry data:\n          recordSpan({\n            name: \"ai.embed.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embed.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": { input: () => [JSON.stringify(value)] }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a11;\n              const modelResponse = await model.doEmbed({\n                values: [value],\n                abortSignal,\n                headers\n              });\n              const embedding2 = modelResponse.embeddings[0];\n              const usage2 = (_a11 = modelResponse.usage) != null ? _a11 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => modelResponse.embeddings.map(\n                        (embedding3) => JSON.stringify(embedding3)\n                      )\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return {\n                embedding: embedding2,\n                usage: usage2,\n                rawResponse: modelResponse.rawResponse\n              };\n            }\n          })\n        )\n      );\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embedding\": { output: () => JSON.stringify(embedding) },\n            \"ai.usage.tokens\": usage.tokens\n          }\n        })\n      );\n      return new DefaultEmbedResult({ value, embedding, usage, rawResponse });\n    }\n  });\n}\nvar DefaultEmbedResult = class {\n  constructor(options) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.rawResponse = options.rawResponse;\n  }\n};\n\n// core/util/split-array.ts\nfunction splitArray(array, chunkSize) {\n  if (chunkSize <= 0) {\n    throw new Error(\"chunkSize must be greater than 0\");\n  }\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n  return result;\n}\n\n// core/embed/embed-many.ts\nasync function embedMany({\n  model,\n  values,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embedMany\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embedMany\", telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.values\": {\n          input: () => values.map((value) => JSON.stringify(value))\n        }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n      if (maxEmbeddingsPerCall == null) {\n        const { embeddings: embeddings2, usage } = await retry(() => {\n          return recordSpan({\n            name: \"ai.embedMany.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embedMany.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                  input: () => values.map((value) => JSON.stringify(value))\n                }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a11;\n              const modelResponse = await model.doEmbed({\n                values,\n                abortSignal,\n                headers\n              });\n              const embeddings3 = modelResponse.embeddings;\n              const usage2 = (_a11 = modelResponse.usage) != null ? _a11 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => embeddings3.map((embedding) => JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return { embeddings: embeddings3, usage: usage2 };\n            }\n          });\n        });\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.embeddings\": {\n                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n              },\n              \"ai.usage.tokens\": usage.tokens\n            }\n          })\n        );\n        return new DefaultEmbedManyResult({ values, embeddings: embeddings2, usage });\n      }\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n      const embeddings = [];\n      let tokens = 0;\n      for (const chunk of valueChunks) {\n        const { embeddings: responseEmbeddings, usage } = await retry(() => {\n          return recordSpan({\n            name: \"ai.embedMany.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embedMany.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                  input: () => chunk.map((value) => JSON.stringify(value))\n                }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a11;\n              const modelResponse = await model.doEmbed({\n                values: chunk,\n                abortSignal,\n                headers\n              });\n              const embeddings2 = modelResponse.embeddings;\n              const usage2 = (_a11 = modelResponse.usage) != null ? _a11 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return { embeddings: embeddings2, usage: usage2 };\n            }\n          });\n        });\n        embeddings.push(...responseEmbeddings);\n        tokens += usage.tokens;\n      }\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embeddings\": {\n              output: () => embeddings.map((embedding) => JSON.stringify(embedding))\n            },\n            \"ai.usage.tokens\": tokens\n          }\n        })\n      );\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens }\n      });\n    }\n  });\n}\nvar DefaultEmbedManyResult = class {\n  constructor(options) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n  }\n};\n\n// core/generate-object/generate-object.ts\n\n\n// core/prompt/convert-to-language-model-prompt.ts\n\n\n// util/download-error.ts\n\nvar name2 = \"AI_DownloadError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`\n  }) {\n    super({ name: name2, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker2);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isDownloadError(error) {\n    return error instanceof Error && error.name === name2 && typeof error.url === \"string\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.statusText == null || typeof error.statusText === \"string\");\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      url: this.url,\n      statusCode: this.statusCode,\n      statusText: this.statusText,\n      cause: this.cause\n    };\n  }\n};\n_a2 = symbol2;\n\n// util/download.ts\nasync function download({\n  url,\n  fetchImplementation = fetch\n}) {\n  var _a11;\n  const urlText = url.toString();\n  try {\n    const response = await fetchImplementation(urlText);\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText\n      });\n    }\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mimeType: (_a11 = response.headers.get(\"content-type\")) != null ? _a11 : void 0\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n}\n\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n  { mimeType: \"image/gif\", bytes: [71, 73, 70] },\n  { mimeType: \"image/png\", bytes: [137, 80, 78, 71] },\n  { mimeType: \"image/jpeg\", bytes: [255, 216] },\n  { mimeType: \"image/webp\", bytes: [82, 73, 70, 70] }\n];\nfunction detectImageMimeType(image) {\n  for (const { bytes, mimeType } of mimeTypeSignatures) {\n    if (image.length >= bytes.length && bytes.every((byte, index) => image[index] === byte)) {\n      return mimeType;\n    }\n  }\n  return void 0;\n}\n\n// core/prompt/data-content.ts\n\n\n// core/prompt/invalid-data-content-error.ts\n\nvar name3 = \"AI_InvalidDataContentError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`\n  }) {\n    super({ name: name3, message, cause });\n    this[_a3] = true;\n    this.content = content;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker3);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidDataContentError(error) {\n    return error instanceof Error && error.name === name3 && error.content != null;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      cause: this.cause,\n      content: this.content\n    };\n  }\n};\n_a3 = symbol3;\n\n// core/prompt/data-content.ts\n\nvar dataContentSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n  zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  zod__WEBPACK_IMPORTED_MODULE_4__.z.instanceof(Uint8Array),\n  zod__WEBPACK_IMPORTED_MODULE_4__.z.instanceof(ArrayBuffer),\n  zod__WEBPACK_IMPORTED_MODULE_4__.z.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value) => {\n      var _a11, _b;\n      return (_b = (_a11 = globalThis.Buffer) == null ? void 0 : _a11.isBuffer(value)) != null ? _b : false;\n    },\n    { message: \"Must be a Buffer\" }\n  )\n]);\nfunction convertDataContentToBase64String(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content instanceof ArrayBuffer) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertUint8ArrayToBase64)(new Uint8Array(content));\n  }\n  return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    try {\n      return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertBase64ToUint8Array)(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message: \"Invalid data content. Content string is not a base64-encoded media.\",\n        content,\n        cause: error\n      });\n    }\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new InvalidDataContentError({ content });\n}\nfunction convertUint8ArrayToText(uint8Array) {\n  try {\n    return new TextDecoder().decode(uint8Array);\n  } catch (error) {\n    throw new Error(\"Error decoding Uint8Array to text\");\n  }\n}\n\n// core/prompt/invalid-message-role-error.ts\n\nvar name4 = \"AI_InvalidMessageRoleError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`\n  }) {\n    super({ name: name4, message });\n    this[_a4] = true;\n    this.role = role;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker4);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidMessageRoleError(error) {\n    return error instanceof Error && error.name === name4 && typeof error.role === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      role: this.role\n    };\n  }\n};\n_a4 = symbol4;\n\n// core/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n  try {\n    const [header, base64Content] = dataUrl.split(\",\");\n    return {\n      mimeType: header.split(\";\")[0].split(\":\")[1],\n      base64Content\n    };\n  } catch (error) {\n    return {\n      mimeType: void 0,\n      base64Content: void 0\n    };\n  }\n}\n\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({\n  prompt,\n  modelSupportsImageUrls = true,\n  downloadImplementation = download\n}) {\n  const languageModelMessages = [];\n  if (prompt.system != null) {\n    languageModelMessages.push({ role: \"system\", content: prompt.system });\n  }\n  const downloadedAssets = modelSupportsImageUrls || prompt.messages == null ? null : await downloadAssets(prompt.messages, downloadImplementation);\n  const promptType = prompt.type;\n  switch (promptType) {\n    case \"prompt\": {\n      languageModelMessages.push({\n        role: \"user\",\n        content: [{ type: \"text\", text: prompt.prompt }]\n      });\n      break;\n    }\n    case \"messages\": {\n      languageModelMessages.push(\n        ...prompt.messages.map(\n          (message) => convertToLanguageModelMessage(message, downloadedAssets)\n        )\n      );\n      break;\n    }\n    default: {\n      const _exhaustiveCheck = promptType;\n      throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n    }\n  }\n  return languageModelMessages;\n}\nfunction convertToLanguageModelMessage(message, downloadedAssets) {\n  const role = message.role;\n  switch (role) {\n    case \"system\": {\n      return {\n        role: \"system\",\n        content: message.content,\n        providerMetadata: message.experimental_providerMetadata\n      };\n    }\n    case \"user\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"user\",\n          content: [{ type: \"text\", text: message.content }],\n          providerMetadata: message.experimental_providerMetadata\n        };\n      }\n      return {\n        role: \"user\",\n        content: message.content.map(\n          (part) => {\n            var _a11, _b, _c, _d, _e;\n            switch (part.type) {\n              case \"text\": {\n                return {\n                  type: \"text\",\n                  text: part.text,\n                  providerMetadata: part.experimental_providerMetadata\n                };\n              }\n              case \"image\": {\n                if (part.image instanceof URL) {\n                  if (downloadedAssets == null) {\n                    return {\n                      type: \"image\",\n                      image: part.image,\n                      mimeType: part.mimeType,\n                      providerMetadata: part.experimental_providerMetadata\n                    };\n                  } else {\n                    const downloadedImage = downloadedAssets[part.image.toString()];\n                    return {\n                      type: \"image\",\n                      image: downloadedImage.data,\n                      mimeType: (_a11 = part.mimeType) != null ? _a11 : downloadedImage.mimeType,\n                      providerMetadata: part.experimental_providerMetadata\n                    };\n                  }\n                }\n                if (typeof part.image === \"string\") {\n                  try {\n                    const url = new URL(part.image);\n                    switch (url.protocol) {\n                      case \"http:\":\n                      case \"https:\": {\n                        if (downloadedAssets == null) {\n                          return {\n                            type: \"image\",\n                            image: url,\n                            mimeType: part.mimeType,\n                            providerMetadata: part.experimental_providerMetadata\n                          };\n                        } else {\n                          const downloadedImage = downloadedAssets[url.toString()];\n                          return {\n                            type: \"image\",\n                            image: downloadedImage.data,\n                            mimeType: (_b = part.mimeType) != null ? _b : downloadedImage.mimeType,\n                            providerMetadata: part.experimental_providerMetadata\n                          };\n                        }\n                      }\n                      case \"data:\": {\n                        try {\n                          const { mimeType, base64Content } = splitDataUrl(\n                            part.image\n                          );\n                          if (mimeType == null || base64Content == null) {\n                            throw new Error(\"Invalid data URL format\");\n                          }\n                          return {\n                            type: \"image\",\n                            image: convertDataContentToUint8Array(base64Content),\n                            mimeType,\n                            providerMetadata: part.experimental_providerMetadata\n                          };\n                        } catch (error) {\n                          throw new Error(\n                            `Error processing data URL: ${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(\n                              message\n                            )}`\n                          );\n                        }\n                      }\n                    }\n                  } catch (_ignored) {\n                  }\n                }\n                const imageUint8 = convertDataContentToUint8Array(part.image);\n                return {\n                  type: \"image\",\n                  image: imageUint8,\n                  mimeType: (_c = part.mimeType) != null ? _c : detectImageMimeType(imageUint8),\n                  providerMetadata: part.experimental_providerMetadata\n                };\n              }\n              case \"file\": {\n                if (part.data instanceof URL) {\n                  if (downloadedAssets == null) {\n                    return {\n                      type: \"file\",\n                      data: part.data,\n                      mimeType: part.mimeType,\n                      providerMetadata: part.experimental_providerMetadata\n                    };\n                  } else {\n                    const downloadedImage = downloadedAssets[part.data.toString()];\n                    return {\n                      type: \"file\",\n                      data: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertUint8ArrayToBase64)(downloadedImage.data),\n                      mimeType: (_d = part.mimeType) != null ? _d : downloadedImage.mimeType,\n                      providerMetadata: part.experimental_providerMetadata\n                    };\n                  }\n                }\n                if (typeof part.data === \"string\") {\n                  try {\n                    const url = new URL(part.data);\n                    switch (url.protocol) {\n                      case \"http:\":\n                      case \"https:\": {\n                        if (downloadedAssets == null) {\n                          return {\n                            type: \"file\",\n                            data: url,\n                            mimeType: part.mimeType,\n                            providerMetadata: part.experimental_providerMetadata\n                          };\n                        } else {\n                          const downloadedImage = downloadedAssets[url.toString()];\n                          return {\n                            type: \"file\",\n                            data: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertUint8ArrayToBase64)(\n                              downloadedImage.data\n                            ),\n                            mimeType: (_e = part.mimeType) != null ? _e : downloadedImage.mimeType,\n                            providerMetadata: part.experimental_providerMetadata\n                          };\n                        }\n                      }\n                      case \"data:\": {\n                        try {\n                          const { mimeType, base64Content } = splitDataUrl(\n                            part.data\n                          );\n                          if (mimeType == null || base64Content == null) {\n                            throw new Error(\"Invalid data URL format\");\n                          }\n                          return {\n                            type: \"file\",\n                            data: convertDataContentToBase64String(\n                              base64Content\n                            ),\n                            mimeType,\n                            providerMetadata: part.experimental_providerMetadata\n                          };\n                        } catch (error) {\n                          throw new Error(\n                            `Error processing data URL: ${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(\n                              message\n                            )}`\n                          );\n                        }\n                      }\n                    }\n                  } catch (_ignored) {\n                  }\n                }\n                const imageBase64 = convertDataContentToBase64String(\n                  part.data\n                );\n                return {\n                  type: \"file\",\n                  data: imageBase64,\n                  mimeType: part.mimeType,\n                  providerMetadata: part.experimental_providerMetadata\n                };\n              }\n            }\n          }\n        ).filter((part) => part.type !== \"text\" || part.text !== \"\"),\n        providerMetadata: message.experimental_providerMetadata\n      };\n    }\n    case \"assistant\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"assistant\",\n          content: [{ type: \"text\", text: message.content }],\n          providerMetadata: message.experimental_providerMetadata\n        };\n      }\n      return {\n        role: \"assistant\",\n        content: message.content.filter(\n          // remove empty text parts:\n          (part) => part.type !== \"text\" || part.text !== \"\"\n        ).map((part) => {\n          const { experimental_providerMetadata, ...rest } = part;\n          return {\n            ...rest,\n            providerMetadata: experimental_providerMetadata\n          };\n        }),\n        providerMetadata: message.experimental_providerMetadata\n      };\n    }\n    case \"tool\": {\n      return {\n        role: \"tool\",\n        content: message.content.map((part) => ({\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          result: part.result,\n          providerMetadata: part.experimental_providerMetadata\n        })),\n        providerMetadata: message.experimental_providerMetadata\n      };\n    }\n    default: {\n      const _exhaustiveCheck = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\nasync function downloadAssets(messages, downloadImplementation) {\n  const urls = messages.filter((message) => message.role === \"user\").map((message) => message.content).filter(\n    (content) => Array.isArray(content)\n  ).flat().filter(\n    (part) => part.type === \"image\" || part.type === \"file\"\n  ).map((part) => part.type === \"image\" ? part.image : part.data).map(\n    (part) => (\n      // support string urls:\n      typeof part === \"string\" && (part.startsWith(\"http:\") || part.startsWith(\"https:\")) ? new URL(part) : part\n    )\n  ).filter((image) => image instanceof URL);\n  const downloadedImages = await Promise.all(\n    urls.map(async (url) => ({\n      url,\n      data: await downloadImplementation({ url })\n    }))\n  );\n  return Object.fromEntries(\n    downloadedImages.map(({ url, data }) => [url.toString(), data])\n  );\n}\n\n// errors/invalid-argument-error.ts\n\nvar name5 = \"AI_InvalidArgumentError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    parameter,\n    value,\n    message\n  }) {\n    super({\n      name: name5,\n      message: `Invalid argument for parameter ${parameter}: ${message}`\n    });\n    this[_a5] = true;\n    this.parameter = parameter;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker5);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidArgumentError(error) {\n    return error instanceof Error && error.name === name5 && typeof error.parameter === \"string\" && typeof error.value === \"string\";\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      parameter: this.parameter,\n      value: this.value\n    };\n  }\n};\n_a5 = symbol5;\n\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({\n  maxTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  stopSequences,\n  seed,\n  maxRetries\n}) {\n  if (maxTokens != null) {\n    if (!Number.isInteger(maxTokens)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be an integer\"\n      });\n    }\n    if (maxTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (topK != null) {\n    if (typeof topK !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topK\",\n        value: topK,\n        message: \"topK must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  return {\n    maxTokens,\n    temperature: temperature != null ? temperature : 0,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,\n    seed,\n    maxRetries: maxRetries != null ? maxRetries : 2\n  };\n}\n\n// core/prompt/validate-prompt.ts\n\n\n\n\n// core/prompt/message.ts\n\n\n// core/types/provider-metadata.ts\n\n\n// core/types/json-value.ts\n\nvar jsonValueSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.lazy(\n  () => zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.null(),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.number(),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.boolean(),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.record(zod__WEBPACK_IMPORTED_MODULE_4__.z.string(), jsonValueSchema),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.array(jsonValueSchema)\n  ])\n);\n\n// core/types/provider-metadata.ts\nvar providerMetadataSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.record(\n  zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  zod__WEBPACK_IMPORTED_MODULE_4__.z.record(zod__WEBPACK_IMPORTED_MODULE_4__.z.string(), jsonValueSchema)\n);\n\n// core/prompt/content-part.ts\n\nvar textPartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"text\"),\n  text: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"image\"),\n  image: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([dataContentSchema, zod__WEBPACK_IMPORTED_MODULE_4__.z.instanceof(URL)]),\n  mimeType: zod__WEBPACK_IMPORTED_MODULE_4__.z.string().optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"file\"),\n  data: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([dataContentSchema, zod__WEBPACK_IMPORTED_MODULE_4__.z.instanceof(URL)]),\n  mimeType: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"tool-call\"),\n  toolCallId: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  toolName: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  args: zod__WEBPACK_IMPORTED_MODULE_4__.z.unknown()\n});\nvar toolResultPartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"tool-result\"),\n  toolCallId: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  toolName: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  result: zod__WEBPACK_IMPORTED_MODULE_4__.z.unknown(),\n  isError: zod__WEBPACK_IMPORTED_MODULE_4__.z.boolean().optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\n\n// core/prompt/message.ts\nvar coreSystemMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"system\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreUserMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"user\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.array(zod__WEBPACK_IMPORTED_MODULE_4__.z.union([textPartSchema, imagePartSchema, filePartSchema]))\n  ]),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreAssistantMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"assistant\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.array(zod__WEBPACK_IMPORTED_MODULE_4__.z.union([textPartSchema, toolCallPartSchema]))\n  ]),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreToolMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"tool\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_4__.z.array(toolResultPartSchema),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n  coreSystemMessageSchema,\n  coreUserMessageSchema,\n  coreAssistantMessageSchema,\n  coreToolMessageSchema\n]);\n\n// core/prompt/validate-prompt.ts\nfunction validatePrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  if (prompt.system != null && typeof prompt.system !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"system must be a string\"\n    });\n  }\n  if (prompt.prompt != null) {\n    if (typeof prompt.prompt !== \"string\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n        prompt,\n        message: \"prompt must be a string\"\n      });\n    }\n    return {\n      type: \"prompt\",\n      prompt: prompt.prompt,\n      messages: void 0,\n      system: prompt.system\n    };\n  }\n  if (prompt.messages != null) {\n    const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n      value: prompt.messages,\n      schema: zod__WEBPACK_IMPORTED_MODULE_4__.z.array(coreMessageSchema)\n    });\n    if (!validationResult.success) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n        prompt,\n        message: \"messages must be an array of CoreMessage\",\n        cause: validationResult.error\n      });\n    }\n    return {\n      type: \"messages\",\n      prompt: void 0,\n      messages: prompt.messages,\n      // only possible case bc of checks above\n      system: prompt.system\n    };\n  }\n  throw new Error(\"unreachable\");\n}\n\n// core/types/usage.ts\nfunction calculateLanguageModelUsage(usage) {\n  return {\n    promptTokens: usage.promptTokens,\n    completionTokens: usage.completionTokens,\n    totalTokens: usage.promptTokens + usage.completionTokens\n  };\n}\n\n// core/util/prepare-response-headers.ts\nfunction prepareResponseHeaders(init, {\n  contentType,\n  dataStreamVersion\n}) {\n  var _a11;\n  const headers = new Headers((_a11 = init == null ? void 0 : init.headers) != null ? _a11 : {});\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", contentType);\n  }\n  if (dataStreamVersion !== void 0) {\n    headers.set(\"X-Vercel-AI-Data-Stream\", dataStreamVersion);\n  }\n  return headers;\n}\n\n// core/generate-object/inject-json-instruction.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nvar DEFAULT_GENERIC_SUFFIX = \"You MUST answer with JSON.\";\nfunction injectJsonInstruction({\n  prompt,\n  schema,\n  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0,\n  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX\n}) {\n  return [\n    prompt != null && prompt.length > 0 ? prompt : void 0,\n    prompt != null && prompt.length > 0 ? \"\" : void 0,\n    // add a newline if prompt is not null\n    schemaPrefix,\n    schema != null ? JSON.stringify(schema) : void 0,\n    schemaSuffix\n  ].filter((line) => line != null).join(\"\\n\");\n}\n\n// core/generate-object/no-object-generated-error.ts\n\nvar name6 = \"AI_NoObjectGeneratedError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  // used in isInstance\n  constructor({ message = \"No object generated.\" } = {}) {\n    super({ name: name6, message });\n    this[_a6] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker6);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isNoObjectGeneratedError(error) {\n    return error instanceof Error && error.name === name6;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      cause: this.cause,\n      message: this.message,\n      stack: this.stack\n    };\n  }\n};\n_a6 = symbol6;\n\n// core/generate-object/output-strategy.ts\n\n\n\n\n// core/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source, transformer) {\n  const transformedStream = source.pipeThrough(\n    new TransformStream(transformer)\n  );\n  transformedStream[Symbol.asyncIterator] = () => {\n    const reader = transformedStream.getReader();\n    return {\n      async next() {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: void 0 } : { done: false, value };\n      }\n    };\n  };\n  return transformedStream;\n}\n\n// core/generate-object/output-strategy.ts\nvar noSchemaOutputStrategy = {\n  type: \"no-schema\",\n  jsonSchema: void 0,\n  validatePartialResult({ value, textDelta }) {\n    return { success: true, value: { partial: value, textDelta } };\n  },\n  validateFinalResult(value) {\n    return value === void 0 ? { success: false, error: new NoObjectGeneratedError() } : { success: true, value };\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n      functionality: \"element streams in no-schema mode\"\n    });\n  }\n};\nvar objectOutputStrategy = (schema) => ({\n  type: \"object\",\n  jsonSchema: schema.jsonSchema,\n  validatePartialResult({ value, textDelta }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value,\n        textDelta\n      }\n    };\n  },\n  validateFinalResult(value) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({ value, schema });\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n      functionality: \"element streams in object mode\"\n    });\n  }\n});\nvar arrayOutputStrategy = (schema) => {\n  const { $schema, ...itemSchema } = schema.jsonSchema;\n  return {\n    type: \"enum\",\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        elements: { type: \"array\", items: itemSchema }\n      },\n      required: [\"elements\"],\n      additionalProperties: false\n    },\n    validatePartialResult({ value, latestObject, isFirstDelta, isFinalDelta }) {\n      var _a11;\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      const resultArray = [];\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({ value: element, schema });\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n        if (!result.success) {\n          return result;\n        }\n        resultArray.push(result.value);\n      }\n      const publishedElementCount = (_a11 = latestObject == null ? void 0 : latestObject.length) != null ? _a11 : 0;\n      let textDelta = \"\";\n      if (isFirstDelta) {\n        textDelta += \"[\";\n      }\n      if (publishedElementCount > 0) {\n        textDelta += \",\";\n      }\n      textDelta += resultArray.slice(publishedElementCount).map((element) => JSON.stringify(element)).join(\",\");\n      if (isFinalDelta) {\n        textDelta += \"]\";\n      }\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta\n        }\n      };\n    },\n    validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      for (const element of inputArray) {\n        const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({ value: element, schema });\n        if (!result.success) {\n          return result;\n        }\n      }\n      return { success: true, value: inputArray };\n    },\n    createElementStream(originalStream) {\n      let publishedElements = 0;\n      return createAsyncIterableStream(originalStream, {\n        transform(chunk, controller) {\n          switch (chunk.type) {\n            case \"object\": {\n              const array = chunk.object;\n              for (; publishedElements < array.length; publishedElements++) {\n                controller.enqueue(array[publishedElements]);\n              }\n              break;\n            }\n            case \"text-delta\":\n            case \"finish\":\n              break;\n            case \"error\":\n              controller.error(chunk.error);\n              break;\n            default: {\n              const _exhaustiveCheck = chunk;\n              throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n            }\n          }\n        }\n      });\n    }\n  };\n};\nvar enumOutputStrategy = (enumValues) => {\n  return {\n    type: \"enum\",\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        result: { type: \"string\", enum: enumValues }\n      },\n      required: [\"result\"],\n      additionalProperties: false\n    },\n    validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      return enumValues.includes(result) ? { success: true, value: result } : {\n        success: false,\n        error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n          value,\n          cause: \"value must be a string in the enum\"\n        })\n      };\n    },\n    validatePartialResult() {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n        functionality: \"partial results in enum mode\"\n      });\n    },\n    createElementStream() {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n        functionality: \"element streams in enum mode\"\n      });\n    }\n  };\n};\nfunction getOutputStrategy({\n  output,\n  schema,\n  enumValues\n}) {\n  switch (output) {\n    case \"object\":\n      return objectOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.asSchema)(schema));\n    case \"array\":\n      return arrayOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.asSchema)(schema));\n    case \"enum\":\n      return enumOutputStrategy(enumValues);\n    case \"no-schema\":\n      return noSchemaOutputStrategy;\n    default: {\n      const _exhaustiveCheck = output;\n      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n    }\n  }\n}\n\n// core/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({\n  output,\n  mode,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues\n}) {\n  if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n    throw new InvalidArgumentError({\n      parameter: \"output\",\n      value: output,\n      message: \"Invalid output type.\"\n    });\n  }\n  if (output === \"no-schema\") {\n    if (mode === \"auto\" || mode === \"tool\") {\n      throw new InvalidArgumentError({\n        parameter: \"mode\",\n        value: mode,\n        message: 'Mode must be \"json\" for no-schema output.'\n      });\n    }\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for no-schema output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for no-schema output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for no-schema output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for no-schema output.\"\n      });\n    }\n  }\n  if (output === \"object\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is required for object output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for object output.\"\n      });\n    }\n  }\n  if (output === \"array\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Element schema is required for array output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for array output.\"\n      });\n    }\n  }\n  if (output === \"enum\") {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for enum output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for enum output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for enum output.\"\n      });\n    }\n    if (enumValues == null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are required for enum output.\"\n      });\n    }\n    for (const value of enumValues) {\n      if (typeof value !== \"string\") {\n        throw new InvalidArgumentError({\n          parameter: \"enumValues\",\n          value,\n          message: \"Enum values must be strings.\"\n        });\n      }\n    }\n  }\n}\n\n// core/generate-object/generate-object.ts\nvar originalGenerateId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({ prefix: \"aiobj-\", size: 24 });\nasync function generateObject({\n  model,\n  enum: enumValues,\n  // rename bc enum is reserved by typescript\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = \"object\",\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata: providerMetadata,\n  _internal: {\n    generateId: generateId3 = originalGenerateId,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  ...settings\n}) {\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n    mode = \"json\";\n  }\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.generateObject\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: \"ai.generateObject\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.schema\": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,\n        \"ai.schema.name\": schemaName,\n        \"ai.schema.description\": schemaDescription,\n        \"ai.settings.output\": outputStrategy.type,\n        \"ai.settings.mode\": mode\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      if (mode === \"auto\" || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n      let result;\n      let finishReason;\n      let usage;\n      let warnings;\n      let rawResponse;\n      let response;\n      let logprobs;\n      let resultProviderMetadata;\n      switch (mode) {\n        case \"json\": {\n          const validatedPrompt = validatePrompt({\n            system: outputStrategy.jsonSchema == null ? injectJsonInstruction({ prompt: system }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n              prompt: system,\n              schema: outputStrategy.jsonSchema\n            }),\n            prompt,\n            messages\n          });\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: validatedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls\n          });\n          const inputFormat = validatedPrompt.type;\n          const generateResult = await retry(\n            () => recordSpan({\n              name: \"ai.generateObject.doGenerate\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.generateObject.doGenerate\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  \"ai.prompt.format\": {\n                    input: () => inputFormat\n                  },\n                  \"ai.prompt.messages\": {\n                    input: () => JSON.stringify(promptMessages)\n                  },\n                  \"ai.settings.mode\": mode,\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.system\": model.provider,\n                  \"gen_ai.request.model\": model.modelId,\n                  \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                  \"gen_ai.request.max_tokens\": settings.maxTokens,\n                  \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                  \"gen_ai.request.temperature\": settings.temperature,\n                  \"gen_ai.request.top_k\": settings.topK,\n                  \"gen_ai.request.top_p\": settings.topP\n                }\n              }),\n              tracer,\n              fn: async (span2) => {\n                var _a11, _b, _c, _d, _e, _f;\n                const result2 = await model.doGenerate({\n                  mode: {\n                    type: \"object-json\",\n                    schema: outputStrategy.jsonSchema,\n                    name: schemaName,\n                    description: schemaDescription\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat,\n                  prompt: promptMessages,\n                  providerMetadata,\n                  abortSignal,\n                  headers\n                });\n                if (result2.text === void 0) {\n                  throw new NoObjectGeneratedError();\n                }\n                const responseData = {\n                  id: (_b = (_a11 = result2.response) == null ? void 0 : _a11.id) != null ? _b : generateId3(),\n                  timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),\n                  modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId\n                };\n                span2.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": result2.finishReason,\n                      \"ai.response.object\": { output: () => result2.text },\n                      \"ai.response.id\": responseData.id,\n                      \"ai.response.model\": responseData.modelId,\n                      \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                      \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                      \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                      // deprecated:\n                      \"ai.finishReason\": result2.finishReason,\n                      \"ai.result.object\": { output: () => result2.text },\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [result2.finishReason],\n                      \"gen_ai.response.id\": responseData.id,\n                      \"gen_ai.response.model\": responseData.modelId,\n                      \"gen_ai.usage.prompt_tokens\": result2.usage.promptTokens,\n                      \"gen_ai.usage.completion_tokens\": result2.usage.completionTokens\n                    }\n                  })\n                );\n                return { ...result2, objectText: result2.text, responseData };\n              }\n            })\n          );\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          response = generateResult.responseData;\n          break;\n        }\n        case \"tool\": {\n          const validatedPrompt = validatePrompt({\n            system,\n            prompt,\n            messages\n          });\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: validatedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls\n          });\n          const inputFormat = validatedPrompt.type;\n          const generateResult = await retry(\n            () => recordSpan({\n              name: \"ai.generateObject.doGenerate\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.generateObject.doGenerate\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  \"ai.prompt.format\": {\n                    input: () => inputFormat\n                  },\n                  \"ai.prompt.messages\": {\n                    input: () => JSON.stringify(promptMessages)\n                  },\n                  \"ai.settings.mode\": mode,\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.system\": model.provider,\n                  \"gen_ai.request.model\": model.modelId,\n                  \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                  \"gen_ai.request.max_tokens\": settings.maxTokens,\n                  \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                  \"gen_ai.request.temperature\": settings.temperature,\n                  \"gen_ai.request.top_k\": settings.topK,\n                  \"gen_ai.request.top_p\": settings.topP\n                }\n              }),\n              tracer,\n              fn: async (span2) => {\n                var _a11, _b, _c, _d, _e, _f, _g, _h;\n                const result2 = await model.doGenerate({\n                  mode: {\n                    type: \"object-tool\",\n                    tool: {\n                      type: \"function\",\n                      name: schemaName != null ? schemaName : \"json\",\n                      description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                      parameters: outputStrategy.jsonSchema\n                    }\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat,\n                  prompt: promptMessages,\n                  providerMetadata,\n                  abortSignal,\n                  headers\n                });\n                const objectText = (_b = (_a11 = result2.toolCalls) == null ? void 0 : _a11[0]) == null ? void 0 : _b.args;\n                if (objectText === void 0) {\n                  throw new NoObjectGeneratedError();\n                }\n                const responseData = {\n                  id: (_d = (_c = result2.response) == null ? void 0 : _c.id) != null ? _d : generateId3(),\n                  timestamp: (_f = (_e = result2.response) == null ? void 0 : _e.timestamp) != null ? _f : currentDate(),\n                  modelId: (_h = (_g = result2.response) == null ? void 0 : _g.modelId) != null ? _h : model.modelId\n                };\n                span2.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": result2.finishReason,\n                      \"ai.response.object\": { output: () => objectText },\n                      \"ai.response.id\": responseData.id,\n                      \"ai.response.model\": responseData.modelId,\n                      \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                      \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                      \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                      // deprecated:\n                      \"ai.finishReason\": result2.finishReason,\n                      \"ai.result.object\": { output: () => objectText },\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [result2.finishReason],\n                      \"gen_ai.response.id\": responseData.id,\n                      \"gen_ai.response.model\": responseData.modelId,\n                      \"gen_ai.usage.input_tokens\": result2.usage.promptTokens,\n                      \"gen_ai.usage.output_tokens\": result2.usage.completionTokens\n                    }\n                  })\n                );\n                return { ...result2, objectText, responseData };\n              }\n            })\n          );\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          response = generateResult.responseData;\n          break;\n        }\n        case void 0: {\n          throw new Error(\n            \"Model does not have a default object generation mode.\"\n          );\n        }\n        default: {\n          const _exhaustiveCheck = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n      const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeParseJSON)({ text: result });\n      if (!parseResult.success) {\n        throw parseResult.error;\n      }\n      const validationResult = outputStrategy.validateFinalResult(\n        parseResult.value\n      );\n      if (!validationResult.success) {\n        throw validationResult.error;\n      }\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.response.finishReason\": finishReason,\n            \"ai.response.object\": {\n              output: () => JSON.stringify(validationResult.value)\n            },\n            \"ai.usage.promptTokens\": usage.promptTokens,\n            \"ai.usage.completionTokens\": usage.completionTokens,\n            // deprecated:\n            \"ai.finishReason\": finishReason,\n            \"ai.result.object\": {\n              output: () => JSON.stringify(validationResult.value)\n            }\n          }\n        })\n      );\n      return new DefaultGenerateObjectResult({\n        object: validationResult.value,\n        finishReason,\n        usage: calculateLanguageModelUsage(usage),\n        warnings,\n        response: {\n          ...response,\n          headers: rawResponse == null ? void 0 : rawResponse.headers\n        },\n        logprobs,\n        providerMetadata: resultProviderMetadata\n      });\n    }\n  });\n}\nvar DefaultGenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.rawResponse = {\n      headers: options.response.headers\n    };\n    this.logprobs = options.logprobs;\n  }\n  toJsonResponse(init) {\n    var _a11;\n    return new Response(JSON.stringify(this.object), {\n      status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"application/json; charset=utf-8\"\n      })\n    });\n  }\n};\nvar experimental_generateObject = generateObject;\n\n// core/generate-object/stream-object.ts\n\n\n\n// util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\n\n// util/delayed-promise.ts\nvar DelayedPromise = class {\n  constructor() {\n    this.status = { type: \"pending\" };\n    this._resolve = void 0;\n    this._reject = void 0;\n  }\n  get value() {\n    if (this.promise) {\n      return this.promise;\n    }\n    this.promise = new Promise((resolve, reject) => {\n      if (this.status.type === \"resolved\") {\n        resolve(this.status.value);\n      } else if (this.status.type === \"rejected\") {\n        reject(this.status.error);\n      }\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n    return this.promise;\n  }\n  resolve(value) {\n    var _a11;\n    this.status = { type: \"resolved\", value };\n    if (this.promise) {\n      (_a11 = this._resolve) == null ? void 0 : _a11.call(this, value);\n    }\n  }\n  reject(error) {\n    var _a11;\n    this.status = { type: \"rejected\", error };\n    if (this.promise) {\n      (_a11 = this._reject) == null ? void 0 : _a11.call(this, error);\n    }\n  }\n};\n\n// core/util/now.ts\nfunction now() {\n  var _a11, _b;\n  return (_b = (_a11 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a11.now()) != null ? _b : Date.now();\n}\n\n// core/util/prepare-outgoing-http-headers.ts\nfunction prepareOutgoingHttpHeaders(init, {\n  contentType,\n  dataStreamVersion\n}) {\n  const headers = {};\n  if ((init == null ? void 0 : init.headers) != null) {\n    for (const [key, value] of Object.entries(init.headers)) {\n      headers[key] = value;\n    }\n  }\n  if (headers[\"Content-Type\"] == null) {\n    headers[\"Content-Type\"] = contentType;\n  }\n  if (dataStreamVersion !== void 0) {\n    headers[\"X-Vercel-AI-Data-Stream\"] = dataStreamVersion;\n  }\n  return headers;\n}\n\n// core/util/write-to-server-response.ts\nfunction writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream\n}) {\n  response.writeHead(status != null ? status : 200, statusText, headers);\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done)\n          break;\n        response.write(value);\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      response.end();\n    }\n  };\n  read();\n}\n\n// core/generate-object/stream-object.ts\nvar originalGenerateId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({ prefix: \"aiobj-\", size: 24 });\nasync function streamObject({\n  model,\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = \"object\",\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata: providerMetadata,\n  onFinish,\n  _internal: {\n    generateId: generateId3 = originalGenerateId2,\n    currentDate = () => /* @__PURE__ */ new Date(),\n    now: now2 = now\n  } = {},\n  ...settings\n}) {\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription\n  });\n  const outputStrategy = getOutputStrategy({ output, schema: inputSchema });\n  if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n    mode = \"json\";\n  }\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  return recordSpan({\n    name: \"ai.streamObject\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: \"ai.streamObject\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.schema\": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,\n        \"ai.schema.name\": schemaName,\n        \"ai.schema.description\": schemaDescription,\n        \"ai.settings.output\": outputStrategy.type,\n        \"ai.settings.mode\": mode\n      }\n    }),\n    tracer,\n    endWhenDone: false,\n    fn: async (rootSpan) => {\n      if (mode === \"auto\" || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n      let callOptions;\n      let transformer;\n      switch (mode) {\n        case \"json\": {\n          const validatedPrompt = validatePrompt({\n            system: outputStrategy.jsonSchema == null ? injectJsonInstruction({ prompt: system }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n              prompt: system,\n              schema: outputStrategy.jsonSchema\n            }),\n            prompt,\n            messages\n          });\n          callOptions = {\n            mode: {\n              type: \"object-json\",\n              schema: outputStrategy.jsonSchema,\n              name: schemaName,\n              description: schemaDescription\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: await convertToLanguageModelPrompt({\n              prompt: validatedPrompt,\n              modelSupportsImageUrls: model.supportsImageUrls\n            }),\n            providerMetadata,\n            abortSignal,\n            headers\n          };\n          transformer = {\n            transform: (chunk, controller) => {\n              switch (chunk.type) {\n                case \"text-delta\":\n                  controller.enqueue(chunk.textDelta);\n                  break;\n                case \"response-metadata\":\n                case \"finish\":\n                case \"error\":\n                  controller.enqueue(chunk);\n                  break;\n              }\n            }\n          };\n          break;\n        }\n        case \"tool\": {\n          const validatedPrompt = validatePrompt({\n            system,\n            prompt,\n            messages\n          });\n          callOptions = {\n            mode: {\n              type: \"object-tool\",\n              tool: {\n                type: \"function\",\n                name: schemaName != null ? schemaName : \"json\",\n                description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                parameters: outputStrategy.jsonSchema\n              }\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: await convertToLanguageModelPrompt({\n              prompt: validatedPrompt,\n              modelSupportsImageUrls: model.supportsImageUrls\n            }),\n            providerMetadata,\n            abortSignal,\n            headers\n          };\n          transformer = {\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case \"tool-call-delta\":\n                  controller.enqueue(chunk.argsTextDelta);\n                  break;\n                case \"response-metadata\":\n                case \"finish\":\n                case \"error\":\n                  controller.enqueue(chunk);\n                  break;\n              }\n            }\n          };\n          break;\n        }\n        case void 0: {\n          throw new Error(\n            \"Model does not have a default object generation mode.\"\n          );\n        }\n        default: {\n          const _exhaustiveCheck = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n      const {\n        result: { stream, warnings, rawResponse },\n        doStreamSpan,\n        startTimestampMs\n      } = await retry(\n        () => recordSpan({\n          name: \"ai.streamObject.doStream\",\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationId: \"ai.streamObject.doStream\",\n                telemetry\n              }),\n              ...baseTelemetryAttributes,\n              \"ai.prompt.format\": {\n                input: () => callOptions.inputFormat\n              },\n              \"ai.prompt.messages\": {\n                input: () => JSON.stringify(callOptions.prompt)\n              },\n              \"ai.settings.mode\": mode,\n              // standardized gen-ai llm span attributes:\n              \"gen_ai.system\": model.provider,\n              \"gen_ai.request.model\": model.modelId,\n              \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n              \"gen_ai.request.max_tokens\": settings.maxTokens,\n              \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n              \"gen_ai.request.temperature\": settings.temperature,\n              \"gen_ai.request.top_k\": settings.topK,\n              \"gen_ai.request.top_p\": settings.topP\n            }\n          }),\n          tracer,\n          endWhenDone: false,\n          fn: async (doStreamSpan2) => ({\n            startTimestampMs: now2(),\n            doStreamSpan: doStreamSpan2,\n            result: await model.doStream(callOptions)\n          })\n        })\n      );\n      return new DefaultStreamObjectResult({\n        outputStrategy,\n        stream: stream.pipeThrough(new TransformStream(transformer)),\n        warnings,\n        rawResponse,\n        onFinish,\n        rootSpan,\n        doStreamSpan,\n        telemetry,\n        startTimestampMs,\n        modelId: model.modelId,\n        now: now2,\n        currentDate,\n        generateId: generateId3\n      });\n    }\n  });\n}\nvar DefaultStreamObjectResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse,\n    outputStrategy,\n    onFinish,\n    rootSpan,\n    doStreamSpan,\n    telemetry,\n    startTimestampMs,\n    modelId,\n    now: now2,\n    currentDate,\n    generateId: generateId3\n  }) {\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n    this.outputStrategy = outputStrategy;\n    this.objectPromise = new DelayedPromise();\n    const { resolve: resolveUsage, promise: usagePromise } = createResolvablePromise();\n    this.usage = usagePromise;\n    const { resolve: resolveResponse, promise: responsePromise } = createResolvablePromise();\n    this.response = responsePromise;\n    const {\n      resolve: resolveProviderMetadata,\n      promise: providerMetadataPromise\n    } = createResolvablePromise();\n    this.experimental_providerMetadata = providerMetadataPromise;\n    let usage;\n    let finishReason;\n    let providerMetadata;\n    let object;\n    let error;\n    let accumulatedText = \"\";\n    let textDelta = \"\";\n    let response = {\n      id: generateId3(),\n      timestamp: currentDate(),\n      modelId\n    };\n    let latestObjectJson = void 0;\n    let latestObject = void 0;\n    let isFirstChunk = true;\n    let isFirstDelta = true;\n    const self = this;\n    this.originalStream = stream.pipeThrough(\n      new TransformStream({\n        async transform(chunk, controller) {\n          var _a11, _b, _c;\n          if (isFirstChunk) {\n            const msToFirstChunk = now2() - startTimestampMs;\n            isFirstChunk = false;\n            doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n              \"ai.stream.msToFirstChunk\": msToFirstChunk\n            });\n            doStreamSpan.setAttributes({\n              \"ai.stream.msToFirstChunk\": msToFirstChunk\n            });\n          }\n          if (typeof chunk === \"string\") {\n            accumulatedText += chunk;\n            textDelta += chunk;\n            const { value: currentObjectJson, state: parseState } = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.parsePartialJson)(accumulatedText);\n            if (currentObjectJson !== void 0 && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.isDeepEqualData)(latestObjectJson, currentObjectJson)) {\n              const validationResult = outputStrategy.validatePartialResult({\n                value: currentObjectJson,\n                textDelta,\n                latestObject,\n                isFirstDelta,\n                isFinalDelta: parseState === \"successful-parse\"\n              });\n              if (validationResult.success && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.isDeepEqualData)(latestObject, validationResult.value.partial)) {\n                latestObjectJson = currentObjectJson;\n                latestObject = validationResult.value.partial;\n                controller.enqueue({\n                  type: \"object\",\n                  object: latestObject\n                });\n                controller.enqueue({\n                  type: \"text-delta\",\n                  textDelta: validationResult.value.textDelta\n                });\n                textDelta = \"\";\n                isFirstDelta = false;\n              }\n            }\n            return;\n          }\n          switch (chunk.type) {\n            case \"response-metadata\": {\n              response = {\n                id: (_a11 = chunk.id) != null ? _a11 : response.id,\n                timestamp: (_b = chunk.timestamp) != null ? _b : response.timestamp,\n                modelId: (_c = chunk.modelId) != null ? _c : response.modelId\n              };\n              break;\n            }\n            case \"finish\": {\n              if (textDelta !== \"\") {\n                controller.enqueue({ type: \"text-delta\", textDelta });\n              }\n              finishReason = chunk.finishReason;\n              usage = calculateLanguageModelUsage(chunk.usage);\n              providerMetadata = chunk.providerMetadata;\n              controller.enqueue({ ...chunk, usage, response });\n              resolveUsage(usage);\n              resolveProviderMetadata(providerMetadata);\n              resolveResponse({\n                ...response,\n                headers: rawResponse == null ? void 0 : rawResponse.headers\n              });\n              const validationResult = outputStrategy.validateFinalResult(latestObjectJson);\n              if (validationResult.success) {\n                object = validationResult.value;\n                self.objectPromise.resolve(object);\n              } else {\n                error = validationResult.error;\n                self.objectPromise.reject(error);\n              }\n              break;\n            }\n            default: {\n              controller.enqueue(chunk);\n              break;\n            }\n          }\n        },\n        // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n        async flush(controller) {\n          try {\n            const finalUsage = usage != null ? usage : {\n              promptTokens: NaN,\n              completionTokens: NaN,\n              totalTokens: NaN\n            };\n            doStreamSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.response.finishReason\": finishReason,\n                  \"ai.response.object\": {\n                    output: () => JSON.stringify(object)\n                  },\n                  \"ai.response.id\": response.id,\n                  \"ai.response.model\": response.modelId,\n                  \"ai.response.timestamp\": response.timestamp.toISOString(),\n                  \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                  \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                  // deprecated\n                  \"ai.finishReason\": finishReason,\n                  \"ai.result.object\": { output: () => JSON.stringify(object) },\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.response.finish_reasons\": [finishReason],\n                  \"gen_ai.response.id\": response.id,\n                  \"gen_ai.response.model\": response.modelId,\n                  \"gen_ai.usage.input_tokens\": finalUsage.promptTokens,\n                  \"gen_ai.usage.output_tokens\": finalUsage.completionTokens\n                }\n              })\n            );\n            doStreamSpan.end();\n            rootSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                  \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                  \"ai.response.object\": {\n                    output: () => JSON.stringify(object)\n                  },\n                  // deprecated\n                  \"ai.result.object\": { output: () => JSON.stringify(object) }\n                }\n              })\n            );\n            await (onFinish == null ? void 0 : onFinish({\n              usage: finalUsage,\n              object,\n              error,\n              rawResponse,\n              response: {\n                ...response,\n                headers: rawResponse == null ? void 0 : rawResponse.headers\n              },\n              warnings,\n              experimental_providerMetadata: providerMetadata\n            }));\n          } catch (error2) {\n            controller.error(error2);\n          } finally {\n            rootSpan.end();\n          }\n        }\n      })\n    );\n  }\n  get object() {\n    return this.objectPromise.value;\n  }\n  get partialObjectStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        switch (chunk.type) {\n          case \"object\":\n            controller.enqueue(chunk.object);\n            break;\n          case \"text-delta\":\n          case \"finish\":\n            break;\n          case \"error\":\n            controller.error(chunk.error);\n            break;\n          default: {\n            const _exhaustiveCheck = chunk;\n            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n          }\n        }\n      }\n    });\n  }\n  get elementStream() {\n    return this.outputStrategy.createElementStream(this.originalStream);\n  }\n  get textStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        switch (chunk.type) {\n          case \"text-delta\":\n            controller.enqueue(chunk.textDelta);\n            break;\n          case \"object\":\n          case \"finish\":\n            break;\n          case \"error\":\n            controller.error(chunk.error);\n            break;\n          default: {\n            const _exhaustiveCheck = chunk;\n            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n          }\n        }\n      }\n    });\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      }\n    });\n  }\n  pipeTextStreamToResponse(response, init) {\n    writeToServerResponse({\n      response,\n      status: init == null ? void 0 : init.status,\n      statusText: init == null ? void 0 : init.statusText,\n      headers: prepareOutgoingHttpHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream())\n    });\n  }\n  toTextStreamResponse(init) {\n    var _a11;\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\nvar experimental_streamObject = streamObject;\n\n// core/generate-text/generate-text.ts\n\n\n// errors/index.ts\n\n\n// errors/invalid-tool-arguments-error.ts\n\nvar name7 = \"AI_InvalidToolArgumentsError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar InvalidToolArgumentsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolArgs,\n    toolName,\n    cause,\n    message = `Invalid arguments for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(\n      cause\n    )}`\n  }) {\n    super({ name: name7, message, cause });\n    this[_a7] = true;\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker7);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidToolArgumentsError(error) {\n    return error instanceof Error && error.name === name7 && typeof error.toolName === \"string\" && typeof error.toolArgs === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n      toolName: this.toolName,\n      toolArgs: this.toolArgs\n    };\n  }\n};\n_a7 = symbol7;\n\n// errors/no-such-tool-error.ts\n\nvar name8 = \"AI_NoSuchToolError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolName,\n    availableTools = void 0,\n    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}`\n  }) {\n    super({ name: name8, message });\n    this[_a8] = true;\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker8);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchToolError(error) {\n    return error instanceof Error && error.name === name8 && \"toolName\" in error && error.toolName != void 0 && typeof error.name === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      toolName: this.toolName,\n      availableTools: this.availableTools\n    };\n  }\n};\n_a8 = symbol8;\n\n// core/prompt/message-conversion-error.ts\n\nvar name9 = \"AI_MessageConversionError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    originalMessage,\n    message\n  }) {\n    super({ name: name9, message });\n    this[_a9] = true;\n    this.originalMessage = originalMessage;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker9);\n  }\n};\n_a9 = symbol9;\n\n// core/prompt/prepare-tools-and-tool-choice.ts\n\n\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object) {\n  return object != null && Object.keys(object).length > 0;\n}\n\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({\n  tools,\n  toolChoice\n}) {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: void 0,\n      toolChoice: void 0\n    };\n  }\n  return {\n    tools: Object.entries(tools).map(([name11, tool2]) => ({\n      type: \"function\",\n      name: name11,\n      description: tool2.description,\n      parameters: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.asSchema)(tool2.parameters).jsonSchema\n    })),\n    toolChoice: toolChoice == null ? { type: \"auto\" } : typeof toolChoice === \"string\" ? { type: toolChoice } : { type: \"tool\", toolName: toolChoice.toolName }\n  };\n}\n\n// core/util/split-on-last-whitespace.ts\nvar lastWhitespaceRegexp = /^([\\s\\S]*?)(\\s+)(\\S*)$/;\nfunction splitOnLastWhitespace(text) {\n  const match = text.match(lastWhitespaceRegexp);\n  return match ? { prefix: match[1], whitespace: match[2], suffix: match[3] } : void 0;\n}\n\n// core/util/remove-text-after-last-whitespace.ts\nfunction removeTextAfterLastWhitespace(text) {\n  const match = splitOnLastWhitespace(text);\n  return match ? match.prefix + match.whitespace : text;\n}\n\n// core/generate-text/parse-tool-call.ts\n\n\nfunction parseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  if (tools == null) {\n    throw new NoSuchToolError({ toolName: toolCall.toolName });\n  }\n  const tool2 = tools[toolName];\n  if (tool2 == null) {\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const schema = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.asSchema)(tool2.parameters);\n  const parseResult = toolCall.args.trim() === \"\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({ value: {}, schema }) : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeParseJSON)({ text: toolCall.args, schema });\n  if (parseResult.success === false) {\n    throw new InvalidToolArgumentsError({\n      toolName,\n      toolArgs: toolCall.args,\n      cause: parseResult.error\n    });\n  }\n  return {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    args: parseResult.value\n  };\n}\n\n// core/generate-text/to-response-messages.ts\nfunction toResponseMessages({\n  text = \"\",\n  toolCalls,\n  toolResults\n}) {\n  const responseMessages = [];\n  responseMessages.push({\n    role: \"assistant\",\n    content: [{ type: \"text\", text }, ...toolCalls]\n  });\n  if (toolResults.length > 0) {\n    responseMessages.push({\n      role: \"tool\",\n      content: toolResults.map((result) => ({\n        type: \"tool-result\",\n        toolCallId: result.toolCallId,\n        toolName: result.toolName,\n        result: result.result\n      }))\n    });\n  }\n  return responseMessages;\n}\n\n// core/generate-text/generate-text.ts\nvar originalGenerateId3 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({ prefix: \"aitxt-\", size: 24 });\nasync function generateText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxAutomaticRoundtrips = 0,\n  maxToolRoundtrips = maxAutomaticRoundtrips,\n  maxSteps = maxToolRoundtrips != null ? maxToolRoundtrips + 1 : 1,\n  experimental_continuationSteps,\n  experimental_continueSteps: continueSteps = experimental_continuationSteps != null ? experimental_continuationSteps : false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata: providerMetadata,\n  _internal: {\n    generateId: generateId3 = originalGenerateId3,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  onStepFinish,\n  ...settings\n}) {\n  if (maxSteps < 1) {\n    throw new InvalidArgumentError({\n      parameter: \"maxSteps\",\n      value: maxSteps,\n      message: \"maxSteps must be at least 1\"\n    });\n  }\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.generateText\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: \"ai.generateText\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.settings.maxSteps\": maxSteps\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      var _a11, _b, _c, _d, _e;\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const validatedPrompt = validatePrompt({\n        system,\n        prompt,\n        messages\n      });\n      const mode = {\n        type: \"regular\",\n        ...prepareToolsAndToolChoice({ tools, toolChoice })\n      };\n      const callSettings = prepareCallSettings(settings);\n      const promptMessages = await convertToLanguageModelPrompt({\n        prompt: validatedPrompt,\n        modelSupportsImageUrls: model.supportsImageUrls\n      });\n      let currentModelResponse;\n      let currentToolCalls = [];\n      let currentToolResults = [];\n      let stepCount = 0;\n      const responseMessages = [];\n      let text = \"\";\n      const steps = [];\n      const usage = {\n        completionTokens: 0,\n        promptTokens: 0,\n        totalTokens: 0\n      };\n      let stepType = \"initial\";\n      do {\n        const currentInputFormat = stepCount === 0 ? validatedPrompt.type : \"messages\";\n        currentModelResponse = await retry(\n          () => recordSpan({\n            name: \"ai.generateText.doGenerate\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.generateText.doGenerate\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.format\": { input: () => currentInputFormat },\n                \"ai.prompt.messages\": {\n                  input: () => JSON.stringify(promptMessages)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                \"gen_ai.request.temperature\": settings.temperature,\n                \"gen_ai.request.top_k\": settings.topK,\n                \"gen_ai.request.top_p\": settings.topP\n              }\n            }),\n            tracer,\n            fn: async (span2) => {\n              var _a12, _b2, _c2, _d2, _e2, _f;\n              const result = await model.doGenerate({\n                mode,\n                ...callSettings,\n                inputFormat: currentInputFormat,\n                prompt: promptMessages,\n                providerMetadata,\n                abortSignal,\n                headers\n              });\n              const responseData = {\n                id: (_b2 = (_a12 = result.response) == null ? void 0 : _a12.id) != null ? _b2 : generateId3(),\n                timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),\n                modelId: (_f = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f : model.modelId\n              };\n              span2.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.response.finishReason\": result.finishReason,\n                    \"ai.response.text\": {\n                      output: () => result.text\n                    },\n                    \"ai.response.toolCalls\": {\n                      output: () => JSON.stringify(result.toolCalls)\n                    },\n                    \"ai.response.id\": responseData.id,\n                    \"ai.response.model\": responseData.modelId,\n                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                    \"ai.usage.promptTokens\": result.usage.promptTokens,\n                    \"ai.usage.completionTokens\": result.usage.completionTokens,\n                    // deprecated:\n                    \"ai.finishReason\": result.finishReason,\n                    \"ai.result.text\": {\n                      output: () => result.text\n                    },\n                    \"ai.result.toolCalls\": {\n                      output: () => JSON.stringify(result.toolCalls)\n                    },\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.response.finish_reasons\": [result.finishReason],\n                    \"gen_ai.response.id\": responseData.id,\n                    \"gen_ai.response.model\": responseData.modelId,\n                    \"gen_ai.usage.input_tokens\": result.usage.promptTokens,\n                    \"gen_ai.usage.output_tokens\": result.usage.completionTokens\n                  }\n                })\n              );\n              return { ...result, response: responseData };\n            }\n          })\n        );\n        currentToolCalls = ((_a11 = currentModelResponse.toolCalls) != null ? _a11 : []).map(\n          (modelToolCall) => parseToolCall({ toolCall: modelToolCall, tools })\n        );\n        currentToolResults = tools == null ? [] : await executeTools({\n          toolCalls: currentToolCalls,\n          tools,\n          tracer,\n          telemetry,\n          abortSignal\n        });\n        const currentUsage = calculateLanguageModelUsage(\n          currentModelResponse.usage\n        );\n        usage.completionTokens += currentUsage.completionTokens;\n        usage.promptTokens += currentUsage.promptTokens;\n        usage.totalTokens += currentUsage.totalTokens;\n        let nextStepType = \"done\";\n        if (++stepCount < maxSteps) {\n          if (continueSteps && currentModelResponse.finishReason === \"length\" && // only use continue when there are no tool calls:\n          currentToolCalls.length === 0) {\n            nextStepType = \"continue\";\n          } else if (\n            // there are tool calls:\n            currentToolCalls.length > 0 && // all current tool calls have results:\n            currentToolResults.length === currentToolCalls.length\n          ) {\n            nextStepType = \"tool-result\";\n          }\n        }\n        const stepText = nextStepType === \"continue\" ? removeTextAfterLastWhitespace((_b = currentModelResponse.text) != null ? _b : \"\") : (_c = currentModelResponse.text) != null ? _c : \"\";\n        text = nextStepType === \"continue\" || stepType === \"continue\" ? text + stepText : stepText;\n        const currentStep = {\n          stepType,\n          text: stepText,\n          toolCalls: currentToolCalls,\n          toolResults: currentToolResults,\n          finishReason: currentModelResponse.finishReason,\n          usage: currentUsage,\n          warnings: currentModelResponse.warnings,\n          logprobs: currentModelResponse.logprobs,\n          response: {\n            ...currentModelResponse.response,\n            headers: (_d = currentModelResponse.rawResponse) == null ? void 0 : _d.headers\n          },\n          experimental_providerMetadata: currentModelResponse.providerMetadata,\n          isContinued: nextStepType === \"continue\"\n        };\n        steps.push(currentStep);\n        await (onStepFinish == null ? void 0 : onStepFinish(currentStep));\n        if (stepType === \"continue\") {\n          const lastResponseMessage = responseMessages.pop();\n          promptMessages.pop();\n          if (typeof lastResponseMessage.content === \"string\") {\n            lastResponseMessage.content = text;\n          } else {\n            lastResponseMessage.content.push({\n              text: stepText,\n              type: \"text\"\n            });\n          }\n          responseMessages.push(lastResponseMessage);\n          promptMessages.push(\n            convertToLanguageModelMessage(lastResponseMessage, null)\n          );\n        } else if (nextStepType === \"continue\") {\n          const newResponseMessages = toResponseMessages({\n            text,\n            toolCalls: currentToolCalls,\n            toolResults: currentToolResults\n          });\n          responseMessages.push(...newResponseMessages);\n          promptMessages.push(\n            ...newResponseMessages.map(\n              (message) => convertToLanguageModelMessage(message, null)\n            )\n          );\n        } else {\n          const newResponseMessages = toResponseMessages({\n            text: currentModelResponse.text,\n            toolCalls: currentToolCalls,\n            toolResults: currentToolResults\n          });\n          responseMessages.push(...newResponseMessages);\n          promptMessages.push(\n            ...newResponseMessages.map(\n              (message) => convertToLanguageModelMessage(message, null)\n            )\n          );\n        }\n        stepType = nextStepType;\n      } while (stepType !== \"done\");\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.response.finishReason\": currentModelResponse.finishReason,\n            \"ai.response.text\": {\n              output: () => currentModelResponse.text\n            },\n            \"ai.response.toolCalls\": {\n              output: () => JSON.stringify(currentModelResponse.toolCalls)\n            },\n            \"ai.usage.promptTokens\": currentModelResponse.usage.promptTokens,\n            \"ai.usage.completionTokens\": currentModelResponse.usage.completionTokens,\n            // deprecated:\n            \"ai.finishReason\": currentModelResponse.finishReason,\n            \"ai.result.text\": {\n              output: () => currentModelResponse.text\n            },\n            \"ai.result.toolCalls\": {\n              output: () => JSON.stringify(currentModelResponse.toolCalls)\n            }\n          }\n        })\n      );\n      return new DefaultGenerateTextResult({\n        text,\n        toolCalls: currentToolCalls,\n        toolResults: currentToolResults,\n        finishReason: currentModelResponse.finishReason,\n        usage,\n        warnings: currentModelResponse.warnings,\n        response: {\n          ...currentModelResponse.response,\n          headers: (_e = currentModelResponse.rawResponse) == null ? void 0 : _e.headers\n        },\n        logprobs: currentModelResponse.logprobs,\n        responseMessages,\n        steps,\n        providerMetadata: currentModelResponse.providerMetadata\n      });\n    }\n  });\n}\nasync function executeTools({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  abortSignal\n}) {\n  const toolResults = await Promise.all(\n    toolCalls.map(async (toolCall) => {\n      const tool2 = tools[toolCall.toolName];\n      if ((tool2 == null ? void 0 : tool2.execute) == null) {\n        return void 0;\n      }\n      const result = await recordSpan({\n        name: \"ai.toolCall\",\n        attributes: selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            ...assembleOperationName({\n              operationId: \"ai.toolCall\",\n              telemetry\n            }),\n            \"ai.toolCall.name\": toolCall.toolName,\n            \"ai.toolCall.id\": toolCall.toolCallId,\n            \"ai.toolCall.args\": {\n              output: () => JSON.stringify(toolCall.args)\n            }\n          }\n        }),\n        tracer,\n        fn: async (span) => {\n          const result2 = await tool2.execute(toolCall.args, { abortSignal });\n          try {\n            span.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.toolCall.result\": {\n                    output: () => JSON.stringify(result2)\n                  }\n                }\n              })\n            );\n          } catch (ignored) {\n          }\n          return result2;\n        }\n      });\n      return {\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        args: toolCall.args,\n        result\n      };\n    })\n  );\n  return toolResults.filter(\n    (result) => result != null\n  );\n}\nvar DefaultGenerateTextResult = class {\n  constructor(options) {\n    this.text = options.text;\n    this.toolCalls = options.toolCalls;\n    this.toolResults = options.toolResults;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.response = options.response;\n    this.responseMessages = options.responseMessages;\n    this.roundtrips = options.steps;\n    this.steps = options.steps;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.rawResponse = {\n      headers: options.response.headers\n    };\n    this.logprobs = options.logprobs;\n  }\n};\nvar experimental_generateText = generateText;\n\n// core/generate-text/stream-text.ts\n\n\n// core/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n  let innerStreamReaders = [];\n  let controller = null;\n  let isClosed = false;\n  const processPull = async () => {\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller == null ? void 0 : controller.close();\n      return;\n    }\n    if (innerStreamReaders.length === 0) {\n      return;\n    }\n    try {\n      const { value, done } = await innerStreamReaders[0].read();\n      if (done) {\n        innerStreamReaders.shift();\n        if (innerStreamReaders.length > 0) {\n          await processPull();\n        } else if (isClosed) {\n          controller == null ? void 0 : controller.close();\n        }\n      } else {\n        controller == null ? void 0 : controller.enqueue(value);\n      }\n    } catch (error) {\n      controller == null ? void 0 : controller.error(error);\n      innerStreamReaders.shift();\n      if (isClosed && innerStreamReaders.length === 0) {\n        controller == null ? void 0 : controller.close();\n      }\n    }\n  };\n  return {\n    stream: new ReadableStream({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      }\n    }),\n    addStream: (innerStream) => {\n      if (isClosed) {\n        throw new Error(\"Cannot add inner stream: outer stream is closed\");\n      }\n      innerStreamReaders.push(innerStream.getReader());\n    },\n    close: () => {\n      isClosed = true;\n      if (innerStreamReaders.length === 0) {\n        controller == null ? void 0 : controller.close();\n      }\n    }\n  };\n}\n\n// core/util/merge-streams.ts\nfunction mergeStreams(stream1, stream2) {\n  const reader1 = stream1.getReader();\n  const reader2 = stream2.getReader();\n  let lastRead1 = void 0;\n  let lastRead2 = void 0;\n  let stream1Done = false;\n  let stream2Done = false;\n  async function readStream1(controller) {\n    try {\n      if (lastRead1 == null) {\n        lastRead1 = reader1.read();\n      }\n      const result = await lastRead1;\n      lastRead1 = void 0;\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n  async function readStream2(controller) {\n    try {\n      if (lastRead2 == null) {\n        lastRead2 = reader2.read();\n      }\n      const result = await lastRead2;\n      lastRead2 = void 0;\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        if (stream1Done) {\n          await readStream2(controller);\n          return;\n        }\n        if (stream2Done) {\n          await readStream1(controller);\n          return;\n        }\n        if (lastRead1 == null) {\n          lastRead1 = reader1.read();\n        }\n        if (lastRead2 == null) {\n          lastRead2 = reader2.read();\n        }\n        const { result, reader } = await Promise.race([\n          lastRead1.then((result2) => ({ result: result2, reader: reader1 })),\n          lastRead2.then((result2) => ({ result: result2, reader: reader2 }))\n        ]);\n        if (!result.done) {\n          controller.enqueue(result.value);\n        }\n        if (reader === reader1) {\n          lastRead1 = void 0;\n          if (result.done) {\n            await readStream2(controller);\n            stream1Done = true;\n          }\n        } else {\n          lastRead2 = void 0;\n          if (result.done) {\n            stream2Done = true;\n            await readStream1(controller);\n          }\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    cancel() {\n      reader1.cancel();\n      reader2.cancel();\n    }\n  });\n}\n\n// core/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({\n  tools,\n  generatorStream,\n  toolCallStreaming,\n  tracer,\n  telemetry,\n  abortSignal\n}) {\n  let canClose = false;\n  const outstandingToolCalls = /* @__PURE__ */ new Set();\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const activeToolCalls = {};\n  const forwardStream = new TransformStream({\n    transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"text-delta\":\n        case \"response-metadata\":\n        case \"error\": {\n          controller.enqueue(chunk);\n          break;\n        }\n        case \"tool-call-delta\": {\n          if (toolCallStreaming) {\n            if (!activeToolCalls[chunk.toolCallId]) {\n              controller.enqueue({\n                type: \"tool-call-streaming-start\",\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName\n              });\n              activeToolCalls[chunk.toolCallId] = true;\n            }\n            controller.enqueue({\n              type: \"tool-call-delta\",\n              toolCallId: chunk.toolCallId,\n              toolName: chunk.toolName,\n              argsTextDelta: chunk.argsTextDelta\n            });\n          }\n          break;\n        }\n        case \"tool-call\": {\n          const toolName = chunk.toolName;\n          if (tools == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new NoSuchToolError({ toolName: chunk.toolName })\n            });\n            break;\n          }\n          const tool2 = tools[toolName];\n          if (tool2 == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new NoSuchToolError({\n                toolName: chunk.toolName,\n                availableTools: Object.keys(tools)\n              })\n            });\n            break;\n          }\n          try {\n            const toolCall = parseToolCall({\n              toolCall: chunk,\n              tools\n            });\n            controller.enqueue(toolCall);\n            if (tool2.execute != null) {\n              const toolExecutionId = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_6__.generateId)();\n              outstandingToolCalls.add(toolExecutionId);\n              recordSpan({\n                name: \"ai.toolCall\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.toolCall\",\n                      telemetry\n                    }),\n                    \"ai.toolCall.name\": toolCall.toolName,\n                    \"ai.toolCall.id\": toolCall.toolCallId,\n                    \"ai.toolCall.args\": {\n                      output: () => JSON.stringify(toolCall.args)\n                    }\n                  }\n                }),\n                tracer,\n                fn: async (span) => tool2.execute(toolCall.args, { abortSignal }).then(\n                  (result) => {\n                    toolResultsStreamController.enqueue({\n                      ...toolCall,\n                      type: \"tool-result\",\n                      result\n                    });\n                    outstandingToolCalls.delete(toolExecutionId);\n                    if (canClose && outstandingToolCalls.size === 0) {\n                      toolResultsStreamController.close();\n                    }\n                    try {\n                      span.setAttributes(\n                        selectTelemetryAttributes({\n                          telemetry,\n                          attributes: {\n                            \"ai.toolCall.result\": {\n                              output: () => JSON.stringify(result)\n                            }\n                          }\n                        })\n                      );\n                    } catch (ignored) {\n                    }\n                  },\n                  (error) => {\n                    toolResultsStreamController.enqueue({\n                      type: \"error\",\n                      error\n                    });\n                    outstandingToolCalls.delete(toolExecutionId);\n                    if (canClose && outstandingToolCalls.size === 0) {\n                      toolResultsStreamController.close();\n                    }\n                  }\n                )\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error\n            });\n          }\n          break;\n        }\n        case \"finish\": {\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: chunk.finishReason,\n            logprobs: chunk.logprobs,\n            usage: calculateLanguageModelUsage(chunk.usage),\n            experimental_providerMetadata: chunk.providerMetadata\n          });\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    flush() {\n      canClose = true;\n      if (outstandingToolCalls.size === 0) {\n        toolResultsStreamController.close();\n      }\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n            }\n          })\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            }\n          })\n        )\n      ]);\n    }\n  });\n}\n\n// core/generate-text/stream-text.ts\nvar originalGenerateId4 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({ prefix: \"aitxt-\", size: 24 });\nasync function streamText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxToolRoundtrips = 0,\n  maxSteps = maxToolRoundtrips != null ? maxToolRoundtrips + 1 : 1,\n  experimental_continueSteps: continueSteps = false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata: providerMetadata,\n  experimental_toolCallStreaming: toolCallStreaming = false,\n  onChunk,\n  onFinish,\n  onStepFinish,\n  _internal: {\n    now: now2 = now,\n    generateId: generateId3 = originalGenerateId4,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  ...settings\n}) {\n  if (maxSteps < 1) {\n    throw new InvalidArgumentError({\n      parameter: \"maxSteps\",\n      value: maxSteps,\n      message: \"maxSteps must be at least 1\"\n    });\n  }\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.streamText\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.streamText\", telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.settings.maxSteps\": maxSteps\n      }\n    }),\n    tracer,\n    endWhenDone: false,\n    fn: async (rootSpan) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const startStep = async ({\n        promptMessages: promptMessages2,\n        promptType\n      }) => {\n        const {\n          result: { stream: stream2, warnings: warnings2, rawResponse: rawResponse2 },\n          doStreamSpan: doStreamSpan2,\n          startTimestampMs: startTimestampMs2\n        } = await retry(\n          () => recordSpan({\n            name: \"ai.streamText.doStream\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.streamText.doStream\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.format\": {\n                  input: () => promptType\n                },\n                \"ai.prompt.messages\": {\n                  input: () => JSON.stringify(promptMessages2)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                \"gen_ai.request.temperature\": settings.temperature,\n                \"gen_ai.request.top_k\": settings.topK,\n                \"gen_ai.request.top_p\": settings.topP\n              }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (doStreamSpan3) => ({\n              startTimestampMs: now2(),\n              // get before the call\n              doStreamSpan: doStreamSpan3,\n              result: await model.doStream({\n                mode: {\n                  type: \"regular\",\n                  ...prepareToolsAndToolChoice({ tools, toolChoice })\n                },\n                ...prepareCallSettings(settings),\n                inputFormat: promptType,\n                prompt: promptMessages2,\n                providerMetadata,\n                abortSignal,\n                headers\n              })\n            })\n          })\n        );\n        return {\n          result: {\n            stream: runToolsTransformation({\n              tools,\n              generatorStream: stream2,\n              toolCallStreaming,\n              tracer,\n              telemetry,\n              abortSignal\n            }),\n            warnings: warnings2,\n            rawResponse: rawResponse2\n          },\n          doStreamSpan: doStreamSpan2,\n          startTimestampMs: startTimestampMs2\n        };\n      };\n      const promptMessages = await convertToLanguageModelPrompt({\n        prompt: validatePrompt({ system, prompt, messages }),\n        modelSupportsImageUrls: model.supportsImageUrls\n      });\n      const {\n        result: { stream, warnings, rawResponse },\n        doStreamSpan,\n        startTimestampMs\n      } = await startStep({\n        promptType: validatePrompt({ system, prompt, messages }).type,\n        promptMessages\n      });\n      return new DefaultStreamTextResult({\n        stream,\n        warnings,\n        rawResponse,\n        onChunk,\n        onFinish,\n        onStepFinish,\n        rootSpan,\n        doStreamSpan,\n        telemetry,\n        startTimestampMs,\n        maxSteps,\n        continueSteps,\n        startStep,\n        promptMessages,\n        modelId: model.modelId,\n        now: now2,\n        currentDate,\n        generateId: generateId3\n      });\n    }\n  });\n}\nvar DefaultStreamTextResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse,\n    onChunk,\n    onFinish,\n    onStepFinish,\n    rootSpan,\n    doStreamSpan,\n    telemetry,\n    startTimestampMs,\n    maxSteps,\n    continueSteps,\n    startStep,\n    promptMessages,\n    modelId,\n    now: now2,\n    currentDate,\n    generateId: generateId3\n  }) {\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n    const { resolve: resolveUsage, promise: usagePromise } = createResolvablePromise();\n    this.usage = usagePromise;\n    const { resolve: resolveFinishReason, promise: finishReasonPromise } = createResolvablePromise();\n    this.finishReason = finishReasonPromise;\n    const { resolve: resolveText, promise: textPromise } = createResolvablePromise();\n    this.text = textPromise;\n    const { resolve: resolveToolCalls, promise: toolCallsPromise } = createResolvablePromise();\n    this.toolCalls = toolCallsPromise;\n    const { resolve: resolveToolResults, promise: toolResultsPromise } = createResolvablePromise();\n    this.toolResults = toolResultsPromise;\n    const { resolve: resolveSteps, promise: stepsPromise } = createResolvablePromise();\n    this.steps = stepsPromise;\n    const {\n      resolve: resolveProviderMetadata,\n      promise: providerMetadataPromise\n    } = createResolvablePromise();\n    this.experimental_providerMetadata = providerMetadataPromise;\n    const { resolve: resolveResponse, promise: responsePromise } = createResolvablePromise();\n    this.response = responsePromise;\n    const {\n      resolve: resolveResponseMessages,\n      promise: responseMessagesPromise\n    } = createResolvablePromise();\n    this.responseMessages = responseMessagesPromise;\n    const {\n      stream: stitchableStream,\n      addStream,\n      close: closeStitchableStream\n    } = createStitchableStream();\n    this.originalStream = stitchableStream;\n    const stepResults = [];\n    const self = this;\n    function addStepStream({\n      stream: stream2,\n      startTimestamp,\n      doStreamSpan: doStreamSpan2,\n      currentStep,\n      promptMessages: promptMessages2,\n      usage = {\n        promptTokens: 0,\n        completionTokens: 0,\n        totalTokens: 0\n      },\n      stepType,\n      previousStepText = \"\"\n    }) {\n      const stepToolCalls = [];\n      const stepToolResults = [];\n      let stepFinishReason = \"unknown\";\n      let stepUsage = {\n        promptTokens: 0,\n        completionTokens: 0,\n        totalTokens: 0\n      };\n      let stepProviderMetadata;\n      let stepFirstChunk = true;\n      let stepText = \"\";\n      let fullStepText = stepType === \"continue\" ? previousStepText : \"\";\n      let stepLogProbs;\n      let stepResponse = {\n        id: generateId3(),\n        timestamp: currentDate(),\n        modelId\n      };\n      let chunkBuffer = \"\";\n      let chunkTextPublished = false;\n      async function publishTextChunk({\n        controller,\n        chunk\n      }) {\n        controller.enqueue(chunk);\n        stepText += chunk.textDelta;\n        fullStepText += chunk.textDelta;\n        chunkTextPublished = true;\n        await (onChunk == null ? void 0 : onChunk({ chunk }));\n      }\n      addStream(\n        stream2.pipeThrough(\n          new TransformStream({\n            async transform(chunk, controller) {\n              var _a11, _b, _c;\n              if (stepFirstChunk) {\n                const msToFirstChunk = now2() - startTimestamp;\n                stepFirstChunk = false;\n                doStreamSpan2.addEvent(\"ai.stream.firstChunk\", {\n                  \"ai.response.msToFirstChunk\": msToFirstChunk,\n                  // deprecated:\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n                doStreamSpan2.setAttributes({\n                  \"ai.response.msToFirstChunk\": msToFirstChunk,\n                  // deprecated:\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n              }\n              if (chunk.type === \"text-delta\" && chunk.textDelta.length === 0) {\n                return;\n              }\n              const chunkType = chunk.type;\n              switch (chunkType) {\n                case \"text-delta\": {\n                  if (continueSteps) {\n                    chunkBuffer += chunk.textDelta;\n                    const split = splitOnLastWhitespace(chunkBuffer);\n                    if (split != null) {\n                      chunkBuffer = split.suffix;\n                      await publishTextChunk({\n                        controller,\n                        chunk: {\n                          type: \"text-delta\",\n                          textDelta: split.prefix + split.whitespace\n                        }\n                      });\n                    }\n                  } else {\n                    await publishTextChunk({ controller, chunk });\n                  }\n                  break;\n                }\n                case \"tool-call\": {\n                  controller.enqueue(chunk);\n                  stepToolCalls.push(chunk);\n                  await (onChunk == null ? void 0 : onChunk({ chunk }));\n                  break;\n                }\n                case \"tool-result\": {\n                  controller.enqueue(chunk);\n                  stepToolResults.push(chunk);\n                  await (onChunk == null ? void 0 : onChunk({ chunk }));\n                  break;\n                }\n                case \"response-metadata\": {\n                  stepResponse = {\n                    id: (_a11 = chunk.id) != null ? _a11 : stepResponse.id,\n                    timestamp: (_b = chunk.timestamp) != null ? _b : stepResponse.timestamp,\n                    modelId: (_c = chunk.modelId) != null ? _c : stepResponse.modelId\n                  };\n                  break;\n                }\n                case \"finish\": {\n                  stepUsage = chunk.usage;\n                  stepFinishReason = chunk.finishReason;\n                  stepProviderMetadata = chunk.experimental_providerMetadata;\n                  stepLogProbs = chunk.logprobs;\n                  const msToFinish = now2() - startTimestamp;\n                  doStreamSpan2.addEvent(\"ai.stream.finish\");\n                  doStreamSpan2.setAttributes({\n                    \"ai.response.msToFinish\": msToFinish,\n                    \"ai.response.avgCompletionTokensPerSecond\": 1e3 * stepUsage.completionTokens / msToFinish\n                  });\n                  break;\n                }\n                case \"tool-call-streaming-start\":\n                case \"tool-call-delta\": {\n                  controller.enqueue(chunk);\n                  await (onChunk == null ? void 0 : onChunk({ chunk }));\n                  break;\n                }\n                case \"error\": {\n                  controller.enqueue(chunk);\n                  stepFinishReason = \"error\";\n                  break;\n                }\n                default: {\n                  const exhaustiveCheck = chunkType;\n                  throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                }\n              }\n            },\n            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n            async flush(controller) {\n              const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n              let nextStepType = \"done\";\n              if (currentStep + 1 < maxSteps) {\n                if (continueSteps && stepFinishReason === \"length\" && // only use continue when there are no tool calls:\n                stepToolCalls.length === 0) {\n                  nextStepType = \"continue\";\n                } else if (\n                  // there are tool calls:\n                  stepToolCalls.length > 0 && // all current tool calls have results:\n                  stepToolResults.length === stepToolCalls.length\n                ) {\n                  nextStepType = \"tool-result\";\n                }\n              }\n              if (continueSteps && chunkBuffer.length > 0 && (nextStepType !== \"continue\" || // when the next step is a regular step, publish the buffer\n              stepType === \"continue\" && !chunkTextPublished)) {\n                await publishTextChunk({\n                  controller,\n                  chunk: {\n                    type: \"text-delta\",\n                    textDelta: chunkBuffer\n                  }\n                });\n                chunkBuffer = \"\";\n              }\n              try {\n                doStreamSpan2.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": stepFinishReason,\n                      \"ai.response.text\": { output: () => stepText },\n                      \"ai.response.toolCalls\": {\n                        output: () => stepToolCallsJson\n                      },\n                      \"ai.response.id\": stepResponse.id,\n                      \"ai.response.model\": stepResponse.modelId,\n                      \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                      \"ai.usage.promptTokens\": stepUsage.promptTokens,\n                      \"ai.usage.completionTokens\": stepUsage.completionTokens,\n                      // deprecated\n                      \"ai.finishReason\": stepFinishReason,\n                      \"ai.result.text\": { output: () => stepText },\n                      \"ai.result.toolCalls\": {\n                        output: () => stepToolCallsJson\n                      },\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [stepFinishReason],\n                      \"gen_ai.response.id\": stepResponse.id,\n                      \"gen_ai.response.model\": stepResponse.modelId,\n                      \"gen_ai.usage.input_tokens\": stepUsage.promptTokens,\n                      \"gen_ai.usage.output_tokens\": stepUsage.completionTokens\n                    }\n                  })\n                );\n              } catch (error) {\n              } finally {\n                doStreamSpan2.end();\n              }\n              controller.enqueue({\n                type: \"step-finish\",\n                finishReason: stepFinishReason,\n                usage: stepUsage,\n                experimental_providerMetadata: stepProviderMetadata,\n                logprobs: stepLogProbs,\n                response: stepResponse,\n                isContinued: nextStepType === \"continue\"\n              });\n              const stepResult = {\n                stepType,\n                text: stepText,\n                toolCalls: stepToolCalls,\n                toolResults: stepToolResults,\n                finishReason: stepFinishReason,\n                usage: stepUsage,\n                warnings: self.warnings,\n                logprobs: stepLogProbs,\n                response: stepResponse,\n                rawResponse: self.rawResponse,\n                experimental_providerMetadata: stepProviderMetadata,\n                isContinued: nextStepType === \"continue\"\n              };\n              stepResults.push(stepResult);\n              await (onStepFinish == null ? void 0 : onStepFinish(stepResult));\n              const combinedUsage = {\n                promptTokens: usage.promptTokens + stepUsage.promptTokens,\n                completionTokens: usage.completionTokens + stepUsage.completionTokens,\n                totalTokens: usage.totalTokens + stepUsage.totalTokens\n              };\n              if (nextStepType !== \"done\") {\n                if (stepType === \"continue\") {\n                  const lastPromptMessage = promptMessages2[promptMessages2.length - 1];\n                  lastPromptMessage.content.push({\n                    text: stepText,\n                    type: \"text\"\n                  });\n                } else {\n                  promptMessages2.push(\n                    ...toResponseMessages({\n                      text: stepText,\n                      toolCalls: stepToolCalls,\n                      toolResults: stepToolResults\n                    }).map(\n                      (message) => convertToLanguageModelMessage(message, null)\n                    )\n                  );\n                }\n                const {\n                  result,\n                  doStreamSpan: doStreamSpan3,\n                  startTimestampMs: startTimestamp2\n                } = await startStep({\n                  promptType: \"messages\",\n                  promptMessages: promptMessages2\n                });\n                self.warnings = result.warnings;\n                self.rawResponse = result.rawResponse;\n                addStepStream({\n                  stream: result.stream,\n                  startTimestamp: startTimestamp2,\n                  doStreamSpan: doStreamSpan3,\n                  currentStep: currentStep + 1,\n                  promptMessages: promptMessages2,\n                  usage: combinedUsage,\n                  stepType: nextStepType,\n                  previousStepText: fullStepText\n                });\n                return;\n              }\n              try {\n                controller.enqueue({\n                  type: \"finish\",\n                  finishReason: stepFinishReason,\n                  usage: combinedUsage,\n                  experimental_providerMetadata: stepProviderMetadata,\n                  logprobs: stepLogProbs,\n                  response: stepResponse\n                });\n                closeStitchableStream();\n                rootSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": stepFinishReason,\n                      \"ai.response.text\": { output: () => fullStepText },\n                      \"ai.response.toolCalls\": {\n                        output: () => stepToolCallsJson\n                      },\n                      \"ai.usage.promptTokens\": combinedUsage.promptTokens,\n                      \"ai.usage.completionTokens\": combinedUsage.completionTokens,\n                      // deprecated\n                      \"ai.finishReason\": stepFinishReason,\n                      \"ai.result.text\": { output: () => fullStepText },\n                      \"ai.result.toolCalls\": {\n                        output: () => stepToolCallsJson\n                      }\n                    }\n                  })\n                );\n                const responseMessages = stepResults.reduce((responseMessages2, step) => {\n                  if (step.stepType === \"continue\") {\n                    const lastResponseMessage = responseMessages2.pop();\n                    if (typeof lastResponseMessage.content === \"string\") {\n                      lastResponseMessage.content += step.text;\n                    } else {\n                      lastResponseMessage.content.push({\n                        text: step.text,\n                        type: \"text\"\n                      });\n                    }\n                    return [...responseMessages2, lastResponseMessage];\n                  }\n                  return [\n                    ...responseMessages2,\n                    ...toResponseMessages({\n                      text: step.text,\n                      toolCalls: step.toolCalls,\n                      toolResults: step.toolResults\n                    })\n                  ];\n                }, []);\n                resolveUsage(combinedUsage);\n                resolveFinishReason(stepFinishReason);\n                resolveText(fullStepText);\n                resolveToolCalls(stepToolCalls);\n                resolveProviderMetadata(stepProviderMetadata);\n                resolveToolResults(stepToolResults);\n                resolveResponse({\n                  ...stepResponse,\n                  headers: rawResponse == null ? void 0 : rawResponse.headers\n                });\n                resolveSteps(stepResults);\n                resolveResponseMessages(responseMessages);\n                await (onFinish == null ? void 0 : onFinish({\n                  finishReason: stepFinishReason,\n                  logprobs: stepLogProbs,\n                  usage: combinedUsage,\n                  text: fullStepText,\n                  toolCalls: stepToolCalls,\n                  // The tool results are inferred as a never[] type, because they are\n                  // optional and the execute method with an inferred result type is\n                  // optional as well. Therefore we need to cast the toolResults to any.\n                  // The type exposed to the users will be correctly inferred.\n                  toolResults: stepToolResults,\n                  rawResponse,\n                  response: {\n                    ...stepResponse,\n                    headers: rawResponse == null ? void 0 : rawResponse.headers\n                  },\n                  warnings,\n                  experimental_providerMetadata: stepProviderMetadata,\n                  steps: stepResults,\n                  responseMessages\n                }));\n              } catch (error) {\n                controller.error(error);\n              } finally {\n                rootSpan.end();\n              }\n            }\n          })\n        )\n      );\n    }\n    addStepStream({\n      stream,\n      startTimestamp: startTimestampMs,\n      doStreamSpan,\n      currentStep: 0,\n      promptMessages,\n      usage: void 0,\n      stepType: \"initial\"\n    });\n  }\n  /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */\n  teeStream() {\n    const [stream1, stream2] = this.originalStream.tee();\n    this.originalStream = stream2;\n    return stream1;\n  }\n  get textStream() {\n    return createAsyncIterableStream(this.teeStream(), {\n      transform(chunk, controller) {\n        if (chunk.type === \"text-delta\") {\n          controller.enqueue(chunk.textDelta);\n        } else if (chunk.type === \"error\") {\n          controller.error(chunk.error);\n        }\n      }\n    });\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.teeStream(), {\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      }\n    });\n  }\n  toAIStream(callbacks = {}) {\n    return this.toDataStreamInternal({ callbacks });\n  }\n  toDataStreamInternal({\n    callbacks = {},\n    getErrorMessage: getErrorMessage4 = () => \"\",\n    // mask error messages for safety by default\n    sendUsage = true\n  } = {}) {\n    let aggregatedResponse = \"\";\n    const callbackTransformer = new TransformStream({\n      async start() {\n        if (callbacks.onStart)\n          await callbacks.onStart();\n      },\n      async transform(chunk, controller) {\n        controller.enqueue(chunk);\n        if (chunk.type === \"text-delta\") {\n          const textDelta = chunk.textDelta;\n          aggregatedResponse += textDelta;\n          if (callbacks.onToken)\n            await callbacks.onToken(textDelta);\n          if (callbacks.onText)\n            await callbacks.onText(textDelta);\n        }\n      },\n      async flush() {\n        if (callbacks.onCompletion)\n          await callbacks.onCompletion(aggregatedResponse);\n        if (callbacks.onFinal)\n          await callbacks.onFinal(aggregatedResponse);\n      }\n    });\n    const streamPartsTransformer = new TransformStream({\n      transform: async (chunk, controller) => {\n        const chunkType = chunk.type;\n        switch (chunkType) {\n          case \"text-delta\": {\n            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"text\", chunk.textDelta));\n            break;\n          }\n          case \"tool-call-streaming-start\": {\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"tool_call_streaming_start\", {\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName\n              })\n            );\n            break;\n          }\n          case \"tool-call-delta\": {\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"tool_call_delta\", {\n                toolCallId: chunk.toolCallId,\n                argsTextDelta: chunk.argsTextDelta\n              })\n            );\n            break;\n          }\n          case \"tool-call\": {\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"tool_call\", {\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                args: chunk.args\n              })\n            );\n            break;\n          }\n          case \"tool-result\": {\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"tool_result\", {\n                toolCallId: chunk.toolCallId,\n                result: chunk.result\n              })\n            );\n            break;\n          }\n          case \"error\": {\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"error\", getErrorMessage4(chunk.error))\n            );\n            break;\n          }\n          case \"step-finish\": {\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"finish_step\", {\n                finishReason: chunk.finishReason,\n                usage: sendUsage ? {\n                  promptTokens: chunk.usage.promptTokens,\n                  completionTokens: chunk.usage.completionTokens\n                } : void 0,\n                isContinued: chunk.isContinued\n              })\n            );\n            break;\n          }\n          case \"finish\": {\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"finish_message\", {\n                finishReason: chunk.finishReason,\n                usage: sendUsage ? {\n                  promptTokens: chunk.usage.promptTokens,\n                  completionTokens: chunk.usage.completionTokens\n                } : void 0\n              })\n            );\n            break;\n          }\n          default: {\n            const exhaustiveCheck = chunkType;\n            throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n          }\n        }\n      }\n    });\n    return this.fullStream.pipeThrough(callbackTransformer).pipeThrough(streamPartsTransformer).pipeThrough(new TextEncoderStream());\n  }\n  pipeAIStreamToResponse(response, init) {\n    return this.pipeDataStreamToResponse(response, init);\n  }\n  pipeDataStreamToResponse(response, options) {\n    const init = options == null ? void 0 : \"init\" in options ? options.init : {\n      headers: \"headers\" in options ? options.headers : void 0,\n      status: \"status\" in options ? options.status : void 0,\n      statusText: \"statusText\" in options ? options.statusText : void 0\n    };\n    const data = options == null ? void 0 : \"data\" in options ? options.data : void 0;\n    const getErrorMessage4 = options == null ? void 0 : \"getErrorMessage\" in options ? options.getErrorMessage : void 0;\n    const sendUsage = options == null ? void 0 : \"sendUsage\" in options ? options.sendUsage : void 0;\n    writeToServerResponse({\n      response,\n      status: init == null ? void 0 : init.status,\n      statusText: init == null ? void 0 : init.statusText,\n      headers: prepareOutgoingHttpHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\",\n        dataStreamVersion: \"v1\"\n      }),\n      stream: this.toDataStream({ data, getErrorMessage: getErrorMessage4, sendUsage })\n    });\n  }\n  pipeTextStreamToResponse(response, init) {\n    writeToServerResponse({\n      response,\n      status: init == null ? void 0 : init.status,\n      statusText: init == null ? void 0 : init.statusText,\n      headers: prepareOutgoingHttpHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream())\n    });\n  }\n  toAIStreamResponse(options) {\n    return this.toDataStreamResponse(options);\n  }\n  toDataStream(options) {\n    const stream = this.toDataStreamInternal({\n      getErrorMessage: options == null ? void 0 : options.getErrorMessage,\n      sendUsage: options == null ? void 0 : options.sendUsage\n    });\n    return (options == null ? void 0 : options.data) ? mergeStreams(options == null ? void 0 : options.data.stream, stream) : stream;\n  }\n  toDataStreamResponse(options) {\n    var _a11;\n    const init = options == null ? void 0 : \"init\" in options ? options.init : {\n      headers: \"headers\" in options ? options.headers : void 0,\n      status: \"status\" in options ? options.status : void 0,\n      statusText: \"statusText\" in options ? options.statusText : void 0\n    };\n    const data = options == null ? void 0 : \"data\" in options ? options.data : void 0;\n    const getErrorMessage4 = options == null ? void 0 : \"getErrorMessage\" in options ? options.getErrorMessage : void 0;\n    const sendUsage = options == null ? void 0 : \"sendUsage\" in options ? options.sendUsage : void 0;\n    return new Response(\n      this.toDataStream({ data, getErrorMessage: getErrorMessage4, sendUsage }),\n      {\n        status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n        statusText: init == null ? void 0 : init.statusText,\n        headers: prepareResponseHeaders(init, {\n          contentType: \"text/plain; charset=utf-8\",\n          dataStreamVersion: \"v1\"\n        })\n      }\n    );\n  }\n  toTextStreamResponse(init) {\n    var _a11;\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\nvar experimental_streamText = streamText;\n\n// core/middleware/wrap-language-model.ts\nvar experimental_wrapLanguageModel = ({\n  model,\n  middleware: { transformParams, wrapGenerate, wrapStream },\n  modelId,\n  providerId\n}) => {\n  async function doTransform({\n    params,\n    type\n  }) {\n    return transformParams ? await transformParams({ params, type }) : params;\n  }\n  return {\n    specificationVersion: \"v1\",\n    provider: providerId != null ? providerId : model.provider,\n    modelId: modelId != null ? modelId : model.modelId,\n    defaultObjectGenerationMode: model.defaultObjectGenerationMode,\n    supportsImageUrls: model.supportsImageUrls,\n    supportsStructuredOutputs: model.supportsStructuredOutputs,\n    async doGenerate(params) {\n      const transformedParams = await doTransform({ params, type: \"generate\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      return wrapGenerate ? wrapGenerate({ doGenerate, params: transformedParams, model }) : doGenerate();\n    },\n    async doStream(params) {\n      const transformedParams = await doTransform({ params, type: \"stream\" });\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapStream ? wrapStream({ doStream, params: transformedParams, model }) : doStream();\n    }\n  };\n};\n\n// core/prompt/attachments-to-parts.ts\nfunction attachmentsToParts(attachments) {\n  var _a11, _b, _c;\n  const parts = [];\n  for (const attachment of attachments) {\n    let url;\n    try {\n      url = new URL(attachment.url);\n    } catch (error) {\n      throw new Error(`Invalid URL: ${attachment.url}`);\n    }\n    switch (url.protocol) {\n      case \"http:\":\n      case \"https:\": {\n        if ((_a11 = attachment.contentType) == null ? void 0 : _a11.startsWith(\"image/\")) {\n          parts.push({ type: \"image\", image: url });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\n              \"If the attachment is not an image, it must specify a content type\"\n            );\n          }\n          parts.push({\n            type: \"file\",\n            data: url,\n            mimeType: attachment.contentType\n          });\n        }\n        break;\n      }\n      case \"data:\": {\n        let header;\n        let base64Content;\n        let mimeType;\n        try {\n          [header, base64Content] = attachment.url.split(\",\");\n          mimeType = header.split(\";\")[0].split(\":\")[1];\n        } catch (error) {\n          throw new Error(`Error processing data URL: ${attachment.url}`);\n        }\n        if (mimeType == null || base64Content == null) {\n          throw new Error(`Invalid data URL format: ${attachment.url}`);\n        }\n        if ((_b = attachment.contentType) == null ? void 0 : _b.startsWith(\"image/\")) {\n          parts.push({\n            type: \"image\",\n            image: convertDataContentToUint8Array(base64Content)\n          });\n        } else if ((_c = attachment.contentType) == null ? void 0 : _c.startsWith(\"text/\")) {\n          parts.push({\n            type: \"text\",\n            text: convertUint8ArrayToText(\n              convertDataContentToUint8Array(base64Content)\n            )\n          });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\n              \"If the attachment is not an image or text, it must specify a content type\"\n            );\n          }\n          parts.push({\n            type: \"file\",\n            data: base64Content,\n            mimeType: attachment.contentType\n          });\n        }\n        break;\n      }\n      default: {\n        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n      }\n    }\n  }\n  return parts;\n}\n\n// core/prompt/convert-to-core-messages.ts\nfunction convertToCoreMessages(messages) {\n  const coreMessages = [];\n  for (const message of messages) {\n    const { role, content, toolInvocations, experimental_attachments } = message;\n    switch (role) {\n      case \"system\": {\n        coreMessages.push({\n          role: \"system\",\n          content\n        });\n        break;\n      }\n      case \"user\": {\n        coreMessages.push({\n          role: \"user\",\n          content: experimental_attachments ? [\n            { type: \"text\", text: content },\n            ...attachmentsToParts(experimental_attachments)\n          ] : content\n        });\n        break;\n      }\n      case \"assistant\": {\n        if (toolInvocations == null) {\n          coreMessages.push({ role: \"assistant\", content });\n          break;\n        }\n        coreMessages.push({\n          role: \"assistant\",\n          content: [\n            { type: \"text\", text: content },\n            ...toolInvocations.map(({ toolCallId, toolName, args }) => ({\n              type: \"tool-call\",\n              toolCallId,\n              toolName,\n              args\n            }))\n          ]\n        });\n        coreMessages.push({\n          role: \"tool\",\n          content: toolInvocations.map((ToolInvocation) => {\n            if (!(\"result\" in ToolInvocation)) {\n              throw new MessageConversionError({\n                originalMessage: message,\n                message: \"ToolInvocation must have a result: \" + JSON.stringify(ToolInvocation)\n              });\n            }\n            const { toolCallId, toolName, args, result } = ToolInvocation;\n            return {\n              type: \"tool-result\",\n              toolCallId,\n              toolName,\n              args,\n              result\n            };\n          })\n        });\n        break;\n      }\n      case \"function\":\n      case \"data\":\n      case \"tool\": {\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`\n        });\n      }\n    }\n  }\n  return coreMessages;\n}\n\n// core/registry/custom-provider.ts\n\nfunction experimental_customProvider({\n  languageModels,\n  textEmbeddingModels,\n  fallbackProvider\n}) {\n  return {\n    languageModel(modelId) {\n      if (languageModels != null && modelId in languageModels) {\n        return languageModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.languageModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"languageModel\" });\n    },\n    textEmbeddingModel(modelId) {\n      if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n        return textEmbeddingModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.textEmbeddingModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"textEmbeddingModel\" });\n    }\n  };\n}\n\n// core/registry/no-such-provider-error.ts\n\nvar name10 = \"AI_NoSuchProviderError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError {\n  constructor({\n    modelId,\n    modelType,\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`\n  }) {\n    super({ errorName: name10, modelId, modelType, message });\n    this[_a10] = true;\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker10);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchProviderError(error) {\n    return error instanceof Error && error.name === name10 && typeof error.providerId === \"string\" && Array.isArray(error.availableProviders);\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      modelId: this.modelId,\n      modelType: this.modelType,\n      providerId: this.providerId,\n      availableProviders: this.availableProviders\n    };\n  }\n};\n_a10 = symbol10;\n\n// core/registry/provider-registry.ts\n\nfunction experimental_createProviderRegistry(providers) {\n  const registry = new DefaultProviderRegistry();\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider });\n  }\n  return registry;\n}\nvar experimental_createModelRegistry = experimental_createProviderRegistry;\nvar DefaultProviderRegistry = class {\n  constructor() {\n    this.providers = {};\n  }\n  registerProvider({\n    id,\n    provider\n  }) {\n    this.providers[id] = provider;\n  }\n  getProvider(id) {\n    const provider = this.providers[id];\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        modelId: id,\n        modelType: \"languageModel\",\n        providerId: id,\n        availableProviders: Object.keys(this.providers)\n      });\n    }\n    return provider;\n  }\n  splitId(id, modelType) {\n    const index = id.indexOf(\":\");\n    if (index === -1) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType,\n        message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId:modelId\")`\n      });\n    }\n    return [id.slice(0, index), id.slice(index + 1)];\n  }\n  languageModel(id) {\n    var _a11, _b;\n    const [providerId, modelId] = this.splitId(id, \"languageModel\");\n    const model = (_b = (_a11 = this.getProvider(providerId)).languageModel) == null ? void 0 : _b.call(_a11, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"languageModel\" });\n    }\n    return model;\n  }\n  textEmbeddingModel(id) {\n    var _a11, _b, _c;\n    const [providerId, modelId] = this.splitId(id, \"textEmbeddingModel\");\n    const provider = this.getProvider(providerId);\n    const model = (_c = (_a11 = provider.textEmbeddingModel) == null ? void 0 : _a11.call(provider, modelId)) != null ? _c : \"textEmbedding\" in provider ? (_b = provider.textEmbedding) == null ? void 0 : _b.call(provider, modelId) : void 0;\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType: \"textEmbeddingModel\"\n      });\n    }\n    return model;\n  }\n  /**\n   * @deprecated Use `textEmbeddingModel` instead.\n   */\n  textEmbedding(id) {\n    return this.textEmbeddingModel(id);\n  }\n};\n\n// core/tool/tool.ts\nfunction tool(tool2) {\n  return tool2;\n}\n\n// core/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n  if (vector1.length !== vector2.length) {\n    throw new Error(\n      `Vectors must have the same length (vector1: ${vector1.length} elements, vector2: ${vector2.length} elements)`\n    );\n  }\n  return dotProduct(vector1, vector2) / (magnitude(vector1) * magnitude(vector2));\n}\nfunction dotProduct(vector1, vector2) {\n  return vector1.reduce(\n    (accumulator, value, index) => accumulator + value * vector2[index],\n    0\n  );\n}\nfunction magnitude(vector) {\n  return Math.sqrt(dotProduct(vector, vector));\n}\n\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n  const textDecoder = new TextDecoder();\n  let eventSourceParser;\n  return new TransformStream({\n    async start(controller) {\n      eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_7__.createParser)(\n        (event) => {\n          if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n          // @see https://replicate.com/docs/streaming\n          event.event === \"done\") {\n            controller.terminate();\n            return;\n          }\n          if (\"data\" in event) {\n            const parsedMessage = customParser ? customParser(event.data, {\n              event: event.event\n            }) : event.data;\n            if (parsedMessage)\n              controller.enqueue(parsedMessage);\n          }\n        }\n      );\n    },\n    transform(chunk) {\n      eventSourceParser.feed(textDecoder.decode(chunk));\n    }\n  });\n}\nfunction createCallbacksTransformer(cb) {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = \"\";\n  const callbacks = cb || {};\n  return new TransformStream({\n    async start() {\n      if (callbacks.onStart)\n        await callbacks.onStart();\n    },\n    async transform(message, controller) {\n      const content = typeof message === \"string\" ? message : message.content;\n      controller.enqueue(textEncoder.encode(content));\n      aggregatedResponse += content;\n      if (callbacks.onToken)\n        await callbacks.onToken(content);\n      if (callbacks.onText && typeof message === \"string\") {\n        await callbacks.onText(message);\n      }\n    },\n    async flush() {\n      const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal && !isOpenAICallbacks) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    }\n  });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n  return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n  let isStreamStart = true;\n  return (text) => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text)\n        isStreamStart = false;\n    }\n    return text;\n  };\n}\nfunction AIStream(response, customParser, callbacks) {\n  if (!response.ok) {\n    if (response.body) {\n      const reader = response.body.getReader();\n      return new ReadableStream({\n        async start(controller) {\n          const { done, value } = await reader.read();\n          if (!done) {\n            const errorText = new TextDecoder().decode(value);\n            controller.error(new Error(`Response error: ${errorText}`));\n          }\n        }\n      });\n    } else {\n      return new ReadableStream({\n        start(controller) {\n          controller.error(new Error(\"Response error: No response body\"));\n        }\n      });\n    }\n  }\n  const responseBodyStream = response.body || createEmptyReadableStream();\n  return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n  return new ReadableStream({\n    start(controller) {\n      controller.close();\n    }\n  });\n}\nfunction readableFromAsyncIterable(iterable) {\n  let it = iterable[Symbol.asyncIterator]();\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await it.next();\n      if (done)\n        controller.close();\n      else\n        controller.enqueue(value);\n    },\n    async cancel(reason) {\n      var _a11;\n      await ((_a11 = it.return) == null ? void 0 : _a11.call(it, reason));\n    }\n  });\n}\n\n// streams/stream-data.ts\n\n\n// util/constants.ts\nvar HANGING_STREAM_WARNING_TIME_MS = 15 * 1e3;\n\n// streams/stream-data.ts\nvar StreamData2 = class {\n  constructor() {\n    this.encoder = new TextEncoder();\n    this.controller = null;\n    this.isClosed = false;\n    this.warningTimeout = null;\n    const self = this;\n    this.stream = new ReadableStream({\n      start: async (controller) => {\n        self.controller = controller;\n        if (true) {\n          self.warningTimeout = setTimeout(() => {\n            console.warn(\n              \"The data stream is hanging. Did you forget to close it with `data.close()`?\"\n            );\n          }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n      },\n      pull: (controller) => {\n      },\n      cancel: (reason) => {\n        this.isClosed = true;\n      }\n    });\n  }\n  async close() {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.close();\n    this.isClosed = true;\n    if (this.warningTimeout) {\n      clearTimeout(this.warningTimeout);\n    }\n  }\n  append(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.enqueue(\n      this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"data\", [value]))\n    );\n  }\n  appendMessageAnnotation(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.enqueue(\n      this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"message_annotations\", [value]))\n    );\n  }\n};\nfunction createStreamDataTransformer() {\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  return new TransformStream({\n    transform: async (chunk, controller) => {\n      const message = decoder.decode(chunk);\n      controller.enqueue(encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"text\", message)));\n    }\n  });\n}\nvar experimental_StreamData = class extends StreamData2 {\n};\n\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n  let previous = \"\";\n  return (data) => {\n    const json = JSON.parse(data);\n    if (\"error\" in json) {\n      throw new Error(`${json.error.type}: ${json.error.message}`);\n    }\n    if (!(\"completion\" in json)) {\n      return;\n    }\n    const text = json.completion;\n    if (!previous || text.length > previous.length && text.startsWith(previous)) {\n      const delta = text.slice(previous.length);\n      previous = text;\n      return delta;\n    }\n    return text;\n  };\n}\nasync function* streamable(stream) {\n  for await (const chunk of stream) {\n    if (\"completion\" in chunk) {\n      const text = chunk.completion;\n      if (text)\n        yield text;\n    } else if (\"delta\" in chunk) {\n      const { delta } = chunk;\n      if (\"text\" in delta) {\n        const text = delta.text;\n        if (text)\n          yield text;\n      }\n    }\n  }\n}\nfunction AnthropicStream(res, cb) {\n  if (Symbol.asyncIterator in res) {\n    return readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return AIStream(res, parseAnthropicStream(), cb).pipeThrough(\n      createStreamDataTransformer()\n    );\n  }\n}\n\n// streams/assistant-response.ts\n\nfunction AssistantResponse({ threadId, messageId }, process2) {\n  const stream = new ReadableStream({\n    async start(controller) {\n      var _a11;\n      const textEncoder = new TextEncoder();\n      const sendMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"assistant_message\", message))\n        );\n      };\n      const sendDataMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"data_message\", message))\n        );\n      };\n      const sendError = (errorMessage) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"error\", errorMessage))\n        );\n      };\n      const forwardStream = async (stream2) => {\n        var _a12, _b;\n        let result = void 0;\n        for await (const value of stream2) {\n          switch (value.event) {\n            case \"thread.message.created\": {\n              controller.enqueue(\n                textEncoder.encode(\n                  (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"assistant_message\", {\n                    id: value.data.id,\n                    role: \"assistant\",\n                    content: [{ type: \"text\", text: { value: \"\" } }]\n                  })\n                )\n              );\n              break;\n            }\n            case \"thread.message.delta\": {\n              const content = (_a12 = value.data.delta.content) == null ? void 0 : _a12[0];\n              if ((content == null ? void 0 : content.type) === \"text\" && ((_b = content.text) == null ? void 0 : _b.value) != null) {\n                controller.enqueue(\n                  textEncoder.encode(\n                    (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"text\", content.text.value)\n                  )\n                );\n              }\n              break;\n            }\n            case \"thread.run.completed\":\n            case \"thread.run.requires_action\": {\n              result = value.data;\n              break;\n            }\n          }\n        }\n        return result;\n      };\n      controller.enqueue(\n        textEncoder.encode(\n          (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"assistant_control_data\", {\n            threadId,\n            messageId\n          })\n        )\n      );\n      try {\n        await process2({\n          threadId,\n          messageId,\n          sendMessage,\n          sendDataMessage,\n          forwardStream\n        });\n      } catch (error) {\n        sendError((_a11 = error.message) != null ? _a11 : `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {\n    },\n    cancel() {\n    }\n  });\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      \"Content-Type\": \"text/plain; charset=utf-8\"\n    }\n  });\n}\nvar experimental_AssistantResponse = AssistantResponse;\n\n// streams/aws-bedrock-stream.ts\nasync function* asDeltaIterable(response, extractTextDeltaFromChunk) {\n  var _a11, _b;\n  const decoder = new TextDecoder();\n  for await (const chunk of (_a11 = response.body) != null ? _a11 : []) {\n    const bytes = (_b = chunk.chunk) == null ? void 0 : _b.bytes;\n    if (bytes != null) {\n      const chunkText = decoder.decode(bytes);\n      const chunkJSON = JSON.parse(chunkText);\n      const delta = extractTextDeltaFromChunk(chunkJSON);\n      if (delta != null) {\n        yield delta;\n      }\n    }\n  }\n}\nfunction AWSBedrockAnthropicMessagesStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => {\n    var _a11;\n    return (_a11 = chunk.delta) == null ? void 0 : _a11.text;\n  });\n}\nfunction AWSBedrockAnthropicStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.completion);\n}\nfunction AWSBedrockCohereStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk == null ? void 0 : chunk.text);\n}\nfunction AWSBedrockLlama2Stream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.generation);\n}\nfunction AWSBedrockStream(response, callbacks, extractTextDeltaFromChunk) {\n  return readableFromAsyncIterable(\n    asDeltaIterable(response, extractTextDeltaFromChunk)\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n  for (const line of lines) {\n    const { text, is_finished } = JSON.parse(line);\n    if (!is_finished) {\n      controller.enqueue(text);\n    }\n  }\n}\nasync function readAndProcessLines(reader, controller) {\n  let segment = \"\";\n  while (true) {\n    const { value: chunk, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    segment += utf8Decoder.decode(chunk, { stream: true });\n    const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n    segment = linesArray.pop() || \"\";\n    await processLines(linesArray, controller);\n  }\n  if (segment) {\n    const linesArray = [segment];\n    await processLines(linesArray, controller);\n  }\n  controller.close();\n}\nfunction createParser2(res) {\n  var _a11;\n  const reader = (_a11 = res.body) == null ? void 0 : _a11.getReader();\n  return new ReadableStream({\n    async start(controller) {\n      if (!reader) {\n        controller.close();\n        return;\n      }\n      await readAndProcessLines(reader, controller);\n    }\n  });\n}\nasync function* streamable2(stream) {\n  for await (const chunk of stream) {\n    if (chunk.eventType === \"text-generation\") {\n      const text = chunk.text;\n      if (text)\n        yield text;\n    }\n  }\n}\nfunction CohereStream(reader, callbacks) {\n  if (Symbol.asyncIterator in reader) {\n    return readableFromAsyncIterable(streamable2(reader)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return createParser2(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  }\n}\n\n// streams/google-generative-ai-stream.ts\nasync function* streamable3(response) {\n  var _a11, _b, _c;\n  for await (const chunk of response.stream) {\n    const parts = (_c = (_b = (_a11 = chunk.candidates) == null ? void 0 : _a11[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts;\n    if (parts === void 0) {\n      continue;\n    }\n    const firstPart = parts[0];\n    if (typeof firstPart.text === \"string\") {\n      yield firstPart.text;\n    }\n  }\n}\nfunction GoogleGenerativeAIStream(response, cb) {\n  return readableFromAsyncIterable(streamable3(response)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/huggingface-stream.ts\nfunction createParser3(res) {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  return new ReadableStream({\n    async pull(controller) {\n      var _a11, _b;\n      const { value, done } = await res.next();\n      if (done) {\n        controller.close();\n        return;\n      }\n      const text = trimStartOfStream((_b = (_a11 = value.token) == null ? void 0 : _a11.text) != null ? _b : \"\");\n      if (!text)\n        return;\n      if (value.generated_text != null && value.generated_text.length > 0) {\n        return;\n      }\n      if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n        return;\n      }\n      controller.enqueue(text);\n    }\n  });\n}\nfunction HuggingFaceStream(res, callbacks) {\n  return createParser3(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/inkeep-stream.ts\nfunction InkeepStream(res, callbacks) {\n  if (!res.body) {\n    throw new Error(\"Response body is null\");\n  }\n  let chat_session_id = \"\";\n  let records_cited;\n  const inkeepEventParser = (data, options) => {\n    var _a11, _b;\n    const { event } = options;\n    if (event === \"records_cited\") {\n      records_cited = JSON.parse(data);\n      (_a11 = callbacks == null ? void 0 : callbacks.onRecordsCited) == null ? void 0 : _a11.call(callbacks, records_cited);\n    }\n    if (event === \"message_chunk\") {\n      const inkeepMessageChunk = JSON.parse(data);\n      chat_session_id = (_b = inkeepMessageChunk.chat_session_id) != null ? _b : chat_session_id;\n      return inkeepMessageChunk.content_chunk;\n    }\n    return;\n  };\n  let { onRecordsCited, ...passThroughCallbacks } = callbacks || {};\n  passThroughCallbacks = {\n    ...passThroughCallbacks,\n    onFinal: (completion) => {\n      var _a11;\n      const inkeepOnFinalMetadata = {\n        chat_session_id,\n        records_cited\n      };\n      (_a11 = callbacks == null ? void 0 : callbacks.onFinal) == null ? void 0 : _a11.call(callbacks, completion, inkeepOnFinalMetadata);\n    }\n  };\n  return AIStream(res, inkeepEventParser, passThroughCallbacks).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// streams/langchain-adapter.ts\nvar langchain_adapter_exports = {};\n__export(langchain_adapter_exports, {\n  toAIStream: () => toAIStream,\n  toDataStream: () => toDataStream,\n  toDataStreamResponse: () => toDataStreamResponse\n});\nfunction toAIStream(stream, callbacks) {\n  return toDataStream(stream, callbacks);\n}\nfunction toDataStream(stream, callbacks) {\n  return stream.pipeThrough(\n    new TransformStream({\n      transform: async (value, controller) => {\n        var _a11;\n        if (typeof value === \"string\") {\n          controller.enqueue(value);\n          return;\n        }\n        if (\"event\" in value) {\n          if (value.event === \"on_chat_model_stream\") {\n            forwardAIMessageChunk(\n              (_a11 = value.data) == null ? void 0 : _a11.chunk,\n              controller\n            );\n          }\n          return;\n        }\n        forwardAIMessageChunk(value, controller);\n      }\n    })\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\nfunction toDataStreamResponse(stream, options) {\n  var _a11;\n  const dataStream = toDataStream(stream, options == null ? void 0 : options.callbacks);\n  const data = options == null ? void 0 : options.data;\n  const init = options == null ? void 0 : options.init;\n  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n  return new Response(responseStream, {\n    status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n    statusText: init == null ? void 0 : init.statusText,\n    headers: prepareResponseHeaders(init, {\n      contentType: \"text/plain; charset=utf-8\",\n      dataStreamVersion: \"v1\"\n    })\n  });\n}\nfunction forwardAIMessageChunk(chunk, controller) {\n  if (typeof chunk.content === \"string\") {\n    controller.enqueue(chunk.content);\n  } else {\n    const content = chunk.content;\n    for (const item of content) {\n      if (item.type === \"text\") {\n        controller.enqueue(item.text);\n      }\n    }\n  }\n}\n\n// streams/llamaindex-adapter.ts\nvar llamaindex_adapter_exports = {};\n__export(llamaindex_adapter_exports, {\n  toDataStream: () => toDataStream2,\n  toDataStreamResponse: () => toDataStreamResponse2\n});\nfunction toDataStream2(stream, callbacks) {\n  return toReadableStream(stream).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\nfunction toDataStreamResponse2(stream, options = {}) {\n  var _a11;\n  const { init, data, callbacks } = options;\n  const dataStream = toDataStream2(stream, callbacks);\n  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n  return new Response(responseStream, {\n    status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n    statusText: init == null ? void 0 : init.statusText,\n    headers: prepareResponseHeaders(init, {\n      contentType: \"text/plain; charset=utf-8\",\n      dataStreamVersion: \"v1\"\n    })\n  });\n}\nfunction toReadableStream(res) {\n  const it = res[Symbol.asyncIterator]();\n  const trimStartOfStream = trimStartOfStreamHelper();\n  return new ReadableStream({\n    async pull(controller) {\n      var _a11;\n      const { value, done } = await it.next();\n      if (done) {\n        controller.close();\n        return;\n      }\n      const text = trimStartOfStream((_a11 = value.delta) != null ? _a11 : \"\");\n      if (text) {\n        controller.enqueue(text);\n      }\n    }\n  });\n}\n\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n  const stream = new TransformStream();\n  const writer = stream.writable.getWriter();\n  const runs = /* @__PURE__ */ new Set();\n  const handleError = async (e, runId) => {\n    runs.delete(runId);\n    await writer.ready;\n    await writer.abort(e);\n  };\n  const handleStart = async (runId) => {\n    runs.add(runId);\n  };\n  const handleEnd = async (runId) => {\n    runs.delete(runId);\n    if (runs.size === 0) {\n      await writer.ready;\n      await writer.close();\n    }\n  };\n  return {\n    stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer()),\n    writer,\n    handlers: {\n      handleLLMNewToken: async (token) => {\n        await writer.ready;\n        await writer.write(token);\n      },\n      handleLLMStart: async (_llm, _prompts, runId) => {\n        handleStart(runId);\n      },\n      handleLLMEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleLLMError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleChainStart: async (_chain, _inputs, runId) => {\n        handleStart(runId);\n      },\n      handleChainEnd: async (_outputs, runId) => {\n        await handleEnd(runId);\n      },\n      handleChainError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleToolStart: async (_tool, _input, runId) => {\n        handleStart(runId);\n      },\n      handleToolEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleToolError: async (e, runId) => {\n        await handleError(e, runId);\n      }\n    }\n  };\n}\n\n// streams/mistral-stream.ts\nasync function* streamable4(stream) {\n  var _a11, _b;\n  for await (const chunk of stream) {\n    const content = (_b = (_a11 = chunk.choices[0]) == null ? void 0 : _a11.delta) == null ? void 0 : _b.content;\n    if (content === void 0 || content === \"\") {\n      continue;\n    }\n    yield content;\n  }\n}\nfunction MistralStream(response, callbacks) {\n  const stream = readableFromAsyncIterable(streamable4(response));\n  return stream.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/openai-stream.ts\n\nfunction parseOpenAIStream() {\n  const extract = chunkToText();\n  return (data) => extract(JSON.parse(data));\n}\nasync function* streamable5(stream) {\n  const extract = chunkToText();\n  for await (let chunk of stream) {\n    if (\"promptFilterResults\" in chunk) {\n      chunk = {\n        id: chunk.id,\n        created: chunk.created.getDate(),\n        object: chunk.object,\n        // not exposed by Azure API\n        model: chunk.model,\n        // not exposed by Azure API\n        choices: chunk.choices.map((choice) => {\n          var _a11, _b, _c, _d, _e, _f, _g;\n          return {\n            delta: {\n              content: (_a11 = choice.delta) == null ? void 0 : _a11.content,\n              function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n              role: (_c = choice.delta) == null ? void 0 : _c.role,\n              tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index) => ({\n                index,\n                id: toolCall.id,\n                function: toolCall.function,\n                type: toolCall.type\n              })) : void 0\n            },\n            finish_reason: choice.finishReason,\n            index: choice.index\n          };\n        })\n      };\n    }\n    const text = extract(chunk);\n    if (text)\n      yield text;\n  }\n}\nfunction chunkToText() {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  let isFunctionStreamingIn;\n  return (json) => {\n    var _a11, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n    if (isChatCompletionChunk(json)) {\n      const delta = (_a11 = json.choices[0]) == null ? void 0 : _a11.delta;\n      if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n        isFunctionStreamingIn = true;\n        return {\n          isText: false,\n          content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n        };\n      } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n        isFunctionStreamingIn = true;\n        const toolCall = delta.tool_calls[0];\n        if (toolCall.index === 0) {\n          return {\n            isText: false,\n            content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n          };\n        } else {\n          return {\n            isText: false,\n            content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n          };\n        }\n      } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n        };\n      } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n        };\n      } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}'\n        };\n      } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}]}'\n        };\n      }\n    }\n    const text = trimStartOfStream(\n      isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\"\n    );\n    return text;\n  };\n  function cleanupArguments(argumentChunk) {\n    let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n    return `${escapedPartialJson}`;\n  }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\n  \"internal_openai_fn_messages\"\n);\nfunction isChatCompletionChunk(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n  const cb = callbacks;\n  let stream;\n  if (Symbol.asyncIterator in res) {\n    stream = readableFromAsyncIterable(streamable5(res)).pipeThrough(\n      createCallbacksTransformer(\n        (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n          ...cb,\n          onFinal: void 0\n        } : {\n          ...cb\n        }\n      )\n    );\n  } else {\n    stream = AIStream(\n      res,\n      parseOpenAIStream(),\n      (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n        ...cb,\n        onFinal: void 0\n      } : {\n        ...cb\n      }\n    );\n  }\n  if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n    const functionCallTransformer = createFunctionCallTransformer(cb);\n    return stream.pipeThrough(functionCallTransformer);\n  } else {\n    return stream.pipeThrough(createStreamDataTransformer());\n  }\n}\nfunction createFunctionCallTransformer(callbacks) {\n  const textEncoder = new TextEncoder();\n  let isFirstChunk = true;\n  let aggregatedResponse = \"\";\n  let aggregatedFinalCompletionResponse = \"\";\n  let isFunctionStreamingIn = false;\n  let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n  const decode = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.createChunkDecoder)();\n  return new TransformStream({\n    async transform(chunk, controller) {\n      const message = decode(chunk);\n      aggregatedFinalCompletionResponse += message;\n      const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n      if (shouldHandleAsFunction) {\n        isFunctionStreamingIn = true;\n        aggregatedResponse += message;\n        isFirstChunk = false;\n        return;\n      }\n      if (!isFunctionStreamingIn) {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"text\", message))\n        );\n        return;\n      } else {\n        aggregatedResponse += message;\n      }\n    },\n    async flush(controller) {\n      try {\n        if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n          isFunctionStreamingIn = false;\n          const payload = JSON.parse(aggregatedResponse);\n          let newFunctionCallMessages = [\n            ...functionCallMessages\n          ];\n          let functionResponse = void 0;\n          if (callbacks.experimental_onFunctionCall) {\n            if (payload.function_call === void 0) {\n              console.warn(\n                \"experimental_onFunctionCall should not be defined when using tools\"\n              );\n            }\n            const argumentsPayload = JSON.parse(\n              payload.function_call.arguments\n            );\n            functionResponse = await callbacks.experimental_onFunctionCall(\n              {\n                name: payload.function_call.name,\n                arguments: argumentsPayload\n              },\n              (result) => {\n                newFunctionCallMessages = [\n                  ...functionCallMessages,\n                  {\n                    role: \"assistant\",\n                    content: \"\",\n                    function_call: payload.function_call\n                  },\n                  {\n                    role: \"function\",\n                    name: payload.function_call.name,\n                    content: JSON.stringify(result)\n                  }\n                ];\n                return newFunctionCallMessages;\n              }\n            );\n          }\n          if (callbacks.experimental_onToolCall) {\n            const toolCalls = {\n              tools: []\n            };\n            for (const tool2 of payload.tool_calls) {\n              toolCalls.tools.push({\n                id: tool2.id,\n                type: \"function\",\n                func: {\n                  name: tool2.function.name,\n                  arguments: JSON.parse(tool2.function.arguments)\n                }\n              });\n            }\n            let responseIndex = 0;\n            try {\n              functionResponse = await callbacks.experimental_onToolCall(\n                toolCalls,\n                (result) => {\n                  if (result) {\n                    const { tool_call_id, function_name, tool_call_result } = result;\n                    newFunctionCallMessages = [\n                      ...newFunctionCallMessages,\n                      // Only append the assistant message if it's the first response\n                      ...responseIndex === 0 ? [\n                        {\n                          role: \"assistant\",\n                          content: \"\",\n                          tool_calls: payload.tool_calls.map(\n                            (tc) => ({\n                              id: tc.id,\n                              type: \"function\",\n                              function: {\n                                name: tc.function.name,\n                                // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                arguments: JSON.stringify(\n                                  tc.function.arguments\n                                )\n                              }\n                            })\n                          )\n                        }\n                      ] : [],\n                      // Append the function call result message\n                      {\n                        role: \"tool\",\n                        tool_call_id,\n                        name: function_name,\n                        content: JSON.stringify(tool_call_result)\n                      }\n                    ];\n                    responseIndex++;\n                  }\n                  return newFunctionCallMessages;\n                }\n              );\n            } catch (e) {\n              console.error(\"Error calling experimental_onToolCall:\", e);\n            }\n          }\n          if (!functionResponse) {\n            controller.enqueue(\n              textEncoder.encode(\n                (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\n                  payload.function_call ? \"function_call\" : \"tool_calls\",\n                  // parse to prevent double-encoding:\n                  JSON.parse(aggregatedResponse)\n                )\n              )\n            );\n            return;\n          } else if (typeof functionResponse === \"string\") {\n            controller.enqueue(\n              textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"text\", functionResponse))\n            );\n            aggregatedFinalCompletionResponse = functionResponse;\n            return;\n          }\n          const filteredCallbacks = {\n            ...callbacks,\n            onStart: void 0\n          };\n          callbacks.onFinal = void 0;\n          const openAIStream = OpenAIStream(functionResponse, {\n            ...filteredCallbacks,\n            [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n          });\n          const reader = openAIStream.getReader();\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n              break;\n            }\n            controller.enqueue(value);\n          }\n        }\n      } finally {\n        if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n          await callbacks.onFinal(aggregatedFinalCompletionResponse);\n        }\n      }\n    }\n  });\n}\n\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb, options) {\n  var _a11;\n  const url = (_a11 = res.urls) == null ? void 0 : _a11.stream;\n  if (!url) {\n    if (res.error)\n      throw new Error(res.error);\n    else\n      throw new Error(\"Missing stream URL in Replicate response\");\n  }\n  const eventStream = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      Accept: \"text/event-stream\",\n      ...options == null ? void 0 : options.headers\n    }\n  });\n  return AIStream(eventStream, void 0, cb).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// streams/stream-to-response.ts\nfunction streamToResponse(res, response, init, data) {\n  var _a11;\n  response.writeHead((_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200, {\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    ...init == null ? void 0 : init.headers\n  });\n  let processedStream = res;\n  if (data) {\n    processedStream = mergeStreams(data.stream, res);\n  }\n  const reader = processedStream.getReader();\n  function read() {\n    reader.read().then(({ done, value }) => {\n      if (done) {\n        response.end();\n        return;\n      }\n      response.write(value);\n      read();\n    });\n  }\n  read();\n}\n\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n  constructor(res, init, data) {\n    let processedStream = res;\n    if (data) {\n      processedStream = mergeStreams(data.stream, res);\n    }\n    super(processedStream, {\n      ...init,\n      status: 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\n\n// streams/index.ts\nvar generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId;\nvar nanoid = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9DQUFvQztBQUNwRTs7QUFFQTtBQU0wQjtBQUM0Qzs7QUFFdEU7QUFDOEM7O0FBRTlDO0FBQ2dEO0FBQ3VCOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4QztBQUM5QztBQUNBLGdDQUFnQyxLQUFLO0FBQ3JDO0FBQ0E7QUFDQSwrQkFBK0Isd0RBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0RBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLElBQUk7QUFDSixRQUFRLG9FQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVyx3QkFBd0IsYUFBYTtBQUNqRjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esa0NBQWtDLDBEQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUVBQWlFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVcsc0NBQXNDLGFBQWE7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QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDhEQUFjO0FBQ2hDLGFBQWEsOERBQWM7QUEyRXpCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc3Npc3RhbnQtdWktc3RhcnRlci8uL25vZGVfbW9kdWxlcy9haS9kaXN0L2luZGV4Lm1qcz8yY2Q5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZTExIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lMTEsIHsgZ2V0OiBhbGxbbmFtZTExXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHN0cmVhbXMvaW5kZXgudHNcbmltcG9ydCB7XG4gIGZvcm1hdFN0cmVhbVBhcnQsXG4gIHBhcnNlU3RyZWFtUGFydCxcbiAgcmVhZERhdGFTdHJlYW0sXG4gIHByb2Nlc3NEYXRhUHJvdG9jb2xSZXNwb25zZVxufSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkSW1wbCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIGNvcmUvaW5kZXgudHNcbmltcG9ydCB7IGpzb25TY2hlbWEgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyB1dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IGdldEVycm9yTWVzc2FnZSwgaXNBYm9ydEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gdXRpbC9kZWxheS50c1xuYXN5bmMgZnVuY3Rpb24gZGVsYXkoZGVsYXlJbk1zKSB7XG4gIHJldHVybiBkZWxheUluTXMgPT09IHZvaWQgMCA/IFByb21pc2UucmVzb2x2ZSgpIDogbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXlJbk1zKSk7XG59XG5cbi8vIHV0aWwvcmV0cnktZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUgPSBcIkFJX1JldHJ5RXJyb3JcIjtcbnZhciBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBSZXRyeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgcmVhc29uLFxuICAgIGVycm9yc1xuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLmxhc3RFcnJvciA9IGVycm9yc1tlcnJvcnMubGVuZ3RoIC0gMV07XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzUmV0cnlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUgJiYgdHlwZW9mIGVycm9yLnJlYXNvbiA9PT0gXCJzdHJpbmdcIiAmJiBBcnJheS5pc0FycmF5KGVycm9yLmVycm9ycyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICByZWFzb246IHRoaXMucmVhc29uLFxuICAgICAgbGFzdEVycm9yOiB0aGlzLmxhc3RFcnJvcixcbiAgICAgIGVycm9yczogdGhpcy5lcnJvcnNcbiAgICB9O1xuICB9XG59O1xuX2EgPSBzeW1ib2w7XG5cbi8vIHV0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmLnRzXG52YXIgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmID0gKHtcbiAgbWF4UmV0cmllcyA9IDIsXG4gIGluaXRpYWxEZWxheUluTXMgPSAyZTMsXG4gIGJhY2tvZmZGYWN0b3IgPSAyXG59ID0ge30pID0+IGFzeW5jIChmKSA9PiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgbWF4UmV0cmllcyxcbiAgZGVsYXlJbk1zOiBpbml0aWFsRGVsYXlJbk1zLFxuICBiYWNrb2ZmRmFjdG9yXG59KTtcbmFzeW5jIGZ1bmN0aW9uIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3Jcbn0sIGVycm9ycyA9IFtdKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGYoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKTtcbiAgICBjb25zdCBuZXdFcnJvcnMgPSBbLi4uZXJyb3JzLCBlcnJvcl07XG4gICAgY29uc3QgdHJ5TnVtYmVyID0gbmV3RXJyb3JzLmxlbmd0aDtcbiAgICBpZiAodHJ5TnVtYmVyID4gbWF4UmV0cmllcykge1xuICAgICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cy4gTGFzdCBlcnJvcjogJHtlcnJvck1lc3NhZ2V9YCxcbiAgICAgICAgcmVhc29uOiBcIm1heFJldHJpZXNFeGNlZWRlZFwiLFxuICAgICAgICBlcnJvcnM6IG5ld0Vycm9yc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikgJiYgZXJyb3IuaXNSZXRyeWFibGUgPT09IHRydWUgJiYgdHJ5TnVtYmVyIDw9IG1heFJldHJpZXMpIHtcbiAgICAgIGF3YWl0IGRlbGF5KGRlbGF5SW5Ncyk7XG4gICAgICByZXR1cm4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICAgZixcbiAgICAgICAgeyBtYXhSZXRyaWVzLCBkZWxheUluTXM6IGJhY2tvZmZGYWN0b3IgKiBkZWxheUluTXMsIGJhY2tvZmZGYWN0b3IgfSxcbiAgICAgICAgbmV3RXJyb3JzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHJ5TnVtYmVyID09PSAxKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMgd2l0aCBub24tcmV0cnlhYmxlIGVycm9yOiAnJHtlcnJvck1lc3NhZ2V9J2AsXG4gICAgICByZWFzb246IFwiZXJyb3JOb3RSZXRyeWFibGVcIixcbiAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvYXNzZW1ibGUtb3BlcmF0aW9uLW5hbWUudHNcbmZ1bmN0aW9uIGFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gIG9wZXJhdGlvbklkLFxuICB0ZWxlbWV0cnlcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICAvLyBzdGFuZGFyZGl6ZWQgb3BlcmF0aW9uIGFuZCByZXNvdXJjZSBuYW1lOlxuICAgIFwib3BlcmF0aW9uLm5hbWVcIjogYCR7b3BlcmF0aW9uSWR9JHsodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZCkgIT0gbnVsbCA/IGAgJHt0ZWxlbWV0cnkuZnVuY3Rpb25JZH1gIDogXCJcIn1gLFxuICAgIFwicmVzb3VyY2UubmFtZVwiOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkLFxuICAgIC8vIGRldGFpbGVkLCBBSSBTREsgc3BlY2lmaWMgZGF0YTpcbiAgICBcImFpLm9wZXJhdGlvbklkXCI6IG9wZXJhdGlvbklkLFxuICAgIFwiYWkudGVsZW1ldHJ5LmZ1bmN0aW9uSWRcIjogdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZFxuICB9O1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9nZXQtYmFzZS10ZWxlbWV0cnktYXR0cmlidXRlcy50c1xuZnVuY3Rpb24gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICBtb2RlbCxcbiAgc2V0dGluZ3MsXG4gIHRlbGVtZXRyeSxcbiAgaGVhZGVyc1xufSkge1xuICB2YXIgX2ExMTtcbiAgcmV0dXJuIHtcbiAgICBcImFpLm1vZGVsLnByb3ZpZGVyXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgIFwiYWkubW9kZWwuaWRcIjogbW9kZWwubW9kZWxJZCxcbiAgICAvLyBzZXR0aW5nczpcbiAgICAuLi5PYmplY3QuZW50cmllcyhzZXR0aW5ncykucmVkdWNlKChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGF0dHJpYnV0ZXNbYGFpLnNldHRpbmdzLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LCB7fSksXG4gICAgLy8gYWRkIG1ldGFkYXRhIGFzIGF0dHJpYnV0ZXM6XG4gICAgLi4uT2JqZWN0LmVudHJpZXMoKF9hMTEgPSB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5tZXRhZGF0YSkgIT0gbnVsbCA/IF9hMTEgOiB7fSkucmVkdWNlKFxuICAgICAgKGF0dHJpYnV0ZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBhdHRyaWJ1dGVzW2BhaS50ZWxlbWV0cnkubWV0YWRhdGEuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICB9LFxuICAgICAge31cbiAgICApLFxuICAgIC8vIHJlcXVlc3QgaGVhZGVyc1xuICAgIC4uLk9iamVjdC5lbnRyaWVzKGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSkucmVkdWNlKChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYGFpLnJlcXVlc3QuaGVhZGVycy4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSwge30pXG4gIH07XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L2dldC10cmFjZXIudHNcbmltcG9ydCB7IHRyYWNlIH0gZnJvbSBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiO1xuXG4vLyBjb3JlL3RlbGVtZXRyeS9ub29wLXRyYWNlci50c1xudmFyIG5vb3BUcmFjZXIgPSB7XG4gIHN0YXJ0U3BhbigpIHtcbiAgICByZXR1cm4gbm9vcFNwYW47XG4gIH0sXG4gIHN0YXJ0QWN0aXZlU3BhbihuYW1lMTEsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzEobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzIobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzMobm9vcFNwYW4pO1xuICAgIH1cbiAgfVxufTtcbnZhciBub29wU3BhbiA9IHtcbiAgc3BhbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIG5vb3BTcGFuQ29udGV4dDtcbiAgfSxcbiAgc2V0QXR0cmlidXRlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGluaygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGlua3MoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldFN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdXBkYXRlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW5kKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBpc1JlY29yZGluZygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHJlY29yZEV4Y2VwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBub29wU3BhbkNvbnRleHQgPSB7XG4gIHRyYWNlSWQ6IFwiXCIsXG4gIHNwYW5JZDogXCJcIixcbiAgdHJhY2VGbGFnczogMFxufTtcblxuLy8gY29yZS90ZWxlbWV0cnkvZ2V0LXRyYWNlci50c1xuZnVuY3Rpb24gZ2V0VHJhY2VyKHtcbiAgaXNFbmFibGVkID0gZmFsc2UsXG4gIHRyYWNlclxufSA9IHt9KSB7XG4gIGlmICghaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIG5vb3BUcmFjZXI7XG4gIH1cbiAgaWYgKHRyYWNlcikge1xuICAgIHJldHVybiB0cmFjZXI7XG4gIH1cbiAgcmV0dXJuIHRyYWNlLmdldFRyYWNlcihcImFpXCIpO1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9yZWNvcmQtc3Bhbi50c1xuaW1wb3J0IHsgU3BhblN0YXR1c0NvZGUgfSBmcm9tIFwiQG9wZW50ZWxlbWV0cnkvYXBpXCI7XG5mdW5jdGlvbiByZWNvcmRTcGFuKHtcbiAgbmFtZTogbmFtZTExLFxuICB0cmFjZXIsXG4gIGF0dHJpYnV0ZXMsXG4gIGZuLFxuICBlbmRXaGVuRG9uZSA9IHRydWVcbn0pIHtcbiAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4obmFtZTExLCB7IGF0dHJpYnV0ZXMgfSwgYXN5bmMgKHNwYW4pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oc3Bhbik7XG4gICAgICBpZiAoZW5kV2hlbkRvbmUpIHtcbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24oe1xuICAgICAgICAgICAgbmFtZTogZXJyb3IubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICBjb2RlOiBTcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SIH0pO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvc2VsZWN0LXRlbGVtZXRyeS1hdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgdGVsZW1ldHJ5LFxuICBhdHRyaWJ1dGVzXG59KSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5yZWR1Y2UoKGF0dHJpYnV0ZXMyLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwiaW5wdXRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuaW5wdXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5yZWNvcmRJbnB1dHMpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlczI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5pbnB1dCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdm9pZCAwID8gYXR0cmlidXRlczIgOiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogcmVzdWx0IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJvdXRwdXRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUub3V0cHV0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkucmVjb3JkT3V0cHV0cykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLm91dHB1dCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdm9pZCAwID8gYXR0cmlidXRlczIgOiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogdmFsdWUgfTtcbiAgfSwge30pO1xufVxuXG4vLyBjb3JlL2VtYmVkL2VtYmVkLnRzXG5hc3luYyBmdW5jdGlvbiBlbWJlZCh7XG4gIG1vZGVsLFxuICB2YWx1ZSxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5lbWJlZFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5lbWJlZFwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICBcImFpLnZhbHVlXCI6IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICAgICAgY29uc3QgeyBlbWJlZGRpbmcsIHVzYWdlLCByYXdSZXNwb25zZSB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IChcbiAgICAgICAgICAvLyBuZXN0ZWQgc3BhbnMgdG8gYWxpZ24gd2l0aCB0aGUgZW1iZWRNYW55IHRlbGVtZXRyeSBkYXRhOlxuICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZC5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkLmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7IGlucHV0OiAoKSA9PiBbSlNPTi5zdHJpbmdpZnkodmFsdWUpXSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExMTtcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogW3ZhbHVlXSxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmcyID0gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzWzBdO1xuICAgICAgICAgICAgICBjb25zdCB1c2FnZTIgPSAoX2ExMSA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTExIDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICBkb0VtYmVkU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIChlbWJlZGRpbmczKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmczKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nOiBlbWJlZGRpbmcyLFxuICAgICAgICAgICAgICAgIHVzYWdlOiB1c2FnZTIsXG4gICAgICAgICAgICAgICAgcmF3UmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmF3UmVzcG9uc2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdcIjogeyBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlLnRva2Vuc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZFJlc3VsdCh7IHZhbHVlLCBlbWJlZGRpbmcsIHVzYWdlLCByYXdSZXNwb25zZSB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRFbWJlZFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHRoaXMuZW1iZWRkaW5nID0gb3B0aW9ucy5lbWJlZGRpbmc7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IG9wdGlvbnMucmF3UmVzcG9uc2U7XG4gIH1cbn07XG5cbi8vIGNvcmUvdXRpbC9zcGxpdC1hcnJheS50c1xuZnVuY3Rpb24gc3BsaXRBcnJheShhcnJheSwgY2h1bmtTaXplKSB7XG4gIGlmIChjaHVua1NpemUgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICByZXN1bHQucHVzaChhcnJheS5zbGljZShpLCBpICsgY2h1bmtTaXplKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gY29yZS9lbWJlZC9lbWJlZC1tYW55LnRzXG5hc3luYyBmdW5jdGlvbiBlbWJlZE1hbnkoe1xuICBtb2RlbCxcbiAgdmFsdWVzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5XG59KSB7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmVtYmVkTWFueVwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5lbWJlZE1hbnlcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gICAgICBjb25zdCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCA9IG1vZGVsLm1heEVtYmVkZGluZ3NQZXJDYWxsO1xuICAgICAgaWYgKG1heEVtYmVkZGluZ3NQZXJDYWxsID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMiwgdXNhZ2UgfSA9IGF3YWl0IHJldHJ5KCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTE7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nczMgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3M7XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTExID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMTEgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMy5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MzLCB1c2FnZTogdXNhZ2UyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMi5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UudG9rZW5zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRNYW55UmVzdWx0KHsgdmFsdWVzLCBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMiwgdXNhZ2UgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZUNodW5rcyA9IHNwbGl0QXJyYXkodmFsdWVzLCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCk7XG4gICAgICBjb25zdCBlbWJlZGRpbmdzID0gW107XG4gICAgICBsZXQgdG9rZW5zID0gMDtcbiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdmFsdWVDaHVua3MpIHtcbiAgICAgICAgY29uc3QgeyBlbWJlZGRpbmdzOiByZXNwb25zZUVtYmVkZGluZ3MsIHVzYWdlIH0gPSBhd2FpdCByZXRyeSgoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgIFwiYWkudmFsdWVzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBjaHVuay5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTE7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGNodW5rLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZ3MyID0gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzO1xuICAgICAgICAgICAgICBjb25zdCB1c2FnZTIgPSAoX2ExMSA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTExIDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICBkb0VtYmVkU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5nczIubWFwKChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlMi50b2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4geyBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMiwgdXNhZ2U6IHVzYWdlMiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZW1iZWRkaW5ncy5wdXNoKC4uLnJlc3BvbnNlRW1iZWRkaW5ncyk7XG4gICAgICAgIHRva2VucyArPSB1c2FnZS50b2tlbnM7XG4gICAgICB9XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MubWFwKChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdG9rZW5zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEVtYmVkTWFueVJlc3VsdCh7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgZW1iZWRkaW5ncyxcbiAgICAgICAgdXNhZ2U6IHsgdG9rZW5zIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdEVtYmVkTWFueVJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gICAgdGhpcy5lbWJlZGRpbmdzID0gb3B0aW9ucy5lbWJlZGRpbmdzO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICB9XG59O1xuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9nZW5lcmF0ZS1vYmplY3QudHNcbmltcG9ydCB7IGNyZWF0ZUlkR2VuZXJhdG9yLCBzYWZlUGFyc2VKU09OIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQudHNcbmltcG9ydCB7XG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQgYXMgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NDIsXG4gIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2UyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHV0aWwvZG93bmxvYWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUyID0gXCJBSV9Eb3dubG9hZEVycm9yXCI7XG52YXIgbWFya2VyMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMn1gO1xudmFyIHN5bWJvbDIgPSBTeW1ib2wuZm9yKG1hcmtlcjIpO1xudmFyIF9hMjtcbnZhciBEb3dubG9hZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgc3RhdHVzQ29kZSxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBjYXVzZSA9PSBudWxsID8gYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7c3RhdHVzQ29kZX0gJHtzdGF0dXNUZXh0fWAgOiBgRmFpbGVkIHRvIGRvd25sb2FkICR7dXJsfTogJHtjYXVzZX1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUyLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMl0gPSB0cnVlO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0Rvd25sb2FkRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMiAmJiB0eXBlb2YgZXJyb3IudXJsID09PSBcInN0cmluZ1wiICYmIChlcnJvci5zdGF0dXNDb2RlID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnN0YXR1c0NvZGUgPT09IFwibnVtYmVyXCIpICYmIChlcnJvci5zdGF0dXNUZXh0ID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZSxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlXG4gICAgfTtcbiAgfVxufTtcbl9hMiA9IHN5bWJvbDI7XG5cbi8vIHV0aWwvZG93bmxvYWQudHNcbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkKHtcbiAgdXJsLFxuICBmZXRjaEltcGxlbWVudGF0aW9uID0gZmV0Y2hcbn0pIHtcbiAgdmFyIF9hMTE7XG4gIGNvbnN0IHVybFRleHQgPSB1cmwudG9TdHJpbmcoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoSW1wbGVtZW50YXRpb24odXJsVGV4dCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3Ioe1xuICAgICAgICB1cmw6IHVybFRleHQsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKSxcbiAgICAgIG1pbWVUeXBlOiAoX2ExMSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpKSAhPSBudWxsID8gX2ExMSA6IHZvaWQgMFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKERvd25sb2FkRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7IHVybDogdXJsVGV4dCwgY2F1c2U6IGVycm9yIH0pO1xuICB9XG59XG5cbi8vIGNvcmUvdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUudHNcbnZhciBtaW1lVHlwZVNpZ25hdHVyZXMgPSBbXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2UvZ2lmXCIsIGJ5dGVzOiBbNzEsIDczLCA3MF0gfSxcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS9wbmdcIiwgYnl0ZXM6IFsxMzcsIDgwLCA3OCwgNzFdIH0sXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2UvanBlZ1wiLCBieXRlczogWzI1NSwgMjE2XSB9LFxuICB7IG1pbWVUeXBlOiBcImltYWdlL3dlYnBcIiwgYnl0ZXM6IFs4MiwgNzMsIDcwLCA3MF0gfVxuXTtcbmZ1bmN0aW9uIGRldGVjdEltYWdlTWltZVR5cGUoaW1hZ2UpIHtcbiAgZm9yIChjb25zdCB7IGJ5dGVzLCBtaW1lVHlwZSB9IG9mIG1pbWVUeXBlU2lnbmF0dXJlcykge1xuICAgIGlmIChpbWFnZS5sZW5ndGggPj0gYnl0ZXMubGVuZ3RoICYmIGJ5dGVzLmV2ZXJ5KChieXRlLCBpbmRleCkgPT4gaW1hZ2VbaW5kZXhdID09PSBieXRlKSkge1xuICAgICAgcmV0dXJuIG1pbWVUeXBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBjb3JlL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbmltcG9ydCB7XG4gIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXksXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS9wcm9tcHQvaW52YWxpZC1kYXRhLWNvbnRlbnQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUzID0gXCJBSV9JbnZhbGlkRGF0YUNvbnRlbnRFcnJvclwiO1xudmFyIG1hcmtlcjMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTN9YDtcbnZhciBzeW1ib2wzID0gU3ltYm9sLmZvcihtYXJrZXIzKTtcbnZhciBfYTM7XG52YXIgSW52YWxpZERhdGFDb250ZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRlbnQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGEgY29udGVudC4gRXhwZWN0ZWQgYSBiYXNlNjQgc3RyaW5nLCBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgQnVmZmVyLCBidXQgZ290ICR7dHlwZW9mIGNvbnRlbnR9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTMsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EzXSA9IHRydWU7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjMpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWREYXRhQ29udGVudEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTMgJiYgZXJyb3IuY29udGVudCAhPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudFxuICAgIH07XG4gIH1cbn07XG5fYTMgPSBzeW1ib2wzO1xuXG4vLyBjb3JlL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG52YXIgZGF0YUNvbnRlbnRTY2hlbWEgPSB6LnVuaW9uKFtcbiAgei5zdHJpbmcoKSxcbiAgei5pbnN0YW5jZW9mKFVpbnQ4QXJyYXkpLFxuICB6Lmluc3RhbmNlb2YoQXJyYXlCdWZmZXIpLFxuICB6LmN1c3RvbShcbiAgICAvLyBCdWZmZXIgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBpbiBzb21lIGVudmlyb25tZW50cyBzdWNoIGFzIENsb3VkRmxhcmU6XG4gICAgKHZhbHVlKSA9PiB7XG4gICAgICB2YXIgX2ExMSwgX2I7XG4gICAgICByZXR1cm4gKF9iID0gKF9hMTEgPSBnbG9iYWxUaGlzLkJ1ZmZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuaXNCdWZmZXIodmFsdWUpKSAhPSBudWxsID8gX2IgOiBmYWxzZTtcbiAgICB9LFxuICAgIHsgbWVzc2FnZTogXCJNdXN0IGJlIGEgQnVmZmVyXCIgfVxuICApXG5dKTtcbmZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nKGNvbnRlbnQpIHtcbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KG5ldyBVaW50OEFycmF5KGNvbnRlbnQpKTtcbiAgfVxuICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShjb250ZW50KSB7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29udmVydEJhc2U2NFRvVWludDhBcnJheShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIGRhdGEgY29udGVudC4gQ29udGVudCBzdHJpbmcgaXMgbm90IGEgYmFzZTY0LWVuY29kZWQgbWVkaWEuXCIsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cbiAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHsgY29udGVudCB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRVaW50OEFycmF5VG9UZXh0KHVpbnQ4QXJyYXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHVpbnQ4QXJyYXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGRlY29kaW5nIFVpbnQ4QXJyYXkgdG8gdGV4dFwiKTtcbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9pbnZhbGlkLW1lc3NhZ2Utcm9sZS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTQgPSBcIkFJX0ludmFsaWRNZXNzYWdlUm9sZUVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNH1gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNDtcbnZhciBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcm9sZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgbWVzc2FnZSByb2xlOiAnJHtyb2xlfScuIE11c3QgYmUgb25lIG9mOiBcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIiwgXCJ0b29sXCIuYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hNF0gPSB0cnVlO1xuICAgIHRoaXMucm9sZSA9IHJvbGU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjQuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI0KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU0ICYmIHR5cGVvZiBlcnJvci5yb2xlID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICByb2xlOiB0aGlzLnJvbGVcbiAgICB9O1xuICB9XG59O1xuX2E0ID0gc3ltYm9sNDtcblxuLy8gY29yZS9wcm9tcHQvc3BsaXQtZGF0YS11cmwudHNcbmZ1bmN0aW9uIHNwbGl0RGF0YVVybChkYXRhVXJsKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBkYXRhVXJsLnNwbGl0KFwiLFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWltZVR5cGU6IGhlYWRlci5zcGxpdChcIjtcIilbMF0uc3BsaXQoXCI6XCIpWzFdLFxuICAgICAgYmFzZTY0Q29udGVudFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbWVUeXBlOiB2b2lkIDAsXG4gICAgICBiYXNlNjRDb250ZW50OiB2b2lkIDBcbiAgICB9O1xuICB9XG59XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0LnRzXG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgcHJvbXB0LFxuICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzID0gdHJ1ZSxcbiAgZG93bmxvYWRJbXBsZW1lbnRhdGlvbiA9IGRvd25sb2FkXG59KSB7XG4gIGNvbnN0IGxhbmd1YWdlTW9kZWxNZXNzYWdlcyA9IFtdO1xuICBpZiAocHJvbXB0LnN5c3RlbSAhPSBudWxsKSB7XG4gICAgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzLnB1c2goeyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50OiBwcm9tcHQuc3lzdGVtIH0pO1xuICB9XG4gIGNvbnN0IGRvd25sb2FkZWRBc3NldHMgPSBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzIHx8IHByb21wdC5tZXNzYWdlcyA9PSBudWxsID8gbnVsbCA6IGF3YWl0IGRvd25sb2FkQXNzZXRzKHByb21wdC5tZXNzYWdlcywgZG93bmxvYWRJbXBsZW1lbnRhdGlvbik7XG4gIGNvbnN0IHByb21wdFR5cGUgPSBwcm9tcHQudHlwZTtcbiAgc3dpdGNoIChwcm9tcHRUeXBlKSB7XG4gICAgY2FzZSBcInByb21wdFwiOiB7XG4gICAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogcHJvbXB0LnByb21wdCB9XVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIm1lc3NhZ2VzXCI6IHtcbiAgICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKFxuICAgICAgICAuLi5wcm9tcHQubWVzc2FnZXMubWFwKFxuICAgICAgICAgIChtZXNzYWdlKSA9PiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZShtZXNzYWdlLCBkb3dubG9hZGVkQXNzZXRzKVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBwcm9tcHRUeXBlO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm9tcHQgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzO1xufVxuZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UobWVzc2FnZSwgZG93bmxvYWRlZEFzc2V0cykge1xuICBjb25zdCByb2xlID0gbWVzc2FnZS5yb2xlO1xuICBzd2l0Y2ggKHJvbGUpIHtcbiAgICBjYXNlIFwic3lzdGVtXCI6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQubWFwKFxuICAgICAgICAgIChwYXJ0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2ExMSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImltYWdlXCI6IHtcbiAgICAgICAgICAgICAgICBpZiAocGFydC5pbWFnZSBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkZWRBc3NldHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogcGFydC5pbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFydC5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3dubG9hZGVkSW1hZ2UgPSBkb3dubG9hZGVkQXNzZXRzW3BhcnQuaW1hZ2UudG9TdHJpbmcoKV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBkb3dubG9hZGVkSW1hZ2UuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogKF9hMTEgPSBwYXJ0Lm1pbWVUeXBlKSAhPSBudWxsID8gX2ExMSA6IGRvd25sb2FkZWRJbWFnZS5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC5pbWFnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChwYXJ0LmltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh1cmwucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cHM6XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb3dubG9hZGVkQXNzZXRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFydC5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3dubG9hZGVkSW1hZ2UgPSBkb3dubG9hZGVkQXNzZXRzW3VybC50b1N0cmluZygpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGRvd25sb2FkZWRJbWFnZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiAoX2IgPSBwYXJ0Lm1pbWVUeXBlKSAhPSBudWxsID8gX2IgOiBkb3dubG9hZGVkSW1hZ2UubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YTpcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBtaW1lVHlwZSwgYmFzZTY0Q29udGVudCB9ID0gc3BsaXREYXRhVXJsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQuaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIFVSTCBmb3JtYXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShiYXNlNjRDb250ZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYEVycm9yIHByb2Nlc3NpbmcgZGF0YSBVUkw6ICR7Z2V0RXJyb3JNZXNzYWdlMihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF9pZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlVWludDggPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkocGFydC5pbWFnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZVVpbnQ4LFxuICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IChfYyA9IHBhcnQubWltZVR5cGUpICE9IG51bGwgPyBfYyA6IGRldGVjdEltYWdlTWltZVR5cGUoaW1hZ2VVaW50OCksXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQuZGF0YSBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkZWRBc3NldHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHBhcnQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFydC5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3dubG9hZGVkSW1hZ2UgPSBkb3dubG9hZGVkQXNzZXRzW3BhcnQuZGF0YS50b1N0cmluZygpXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0Mihkb3dubG9hZGVkSW1hZ2UuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IChfZCA9IHBhcnQubWltZVR5cGUpICE9IG51bGwgPyBfZCA6IGRvd25sb2FkZWRJbWFnZS5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC5kYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhcnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodXJsLnByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImh0dHA6XCI6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImh0dHBzOlwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG93bmxvYWRlZEFzc2V0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkZWRJbWFnZSA9IGRvd25sb2FkZWRBc3NldHNbdXJsLnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRlZEltYWdlLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiAoX2UgPSBwYXJ0Lm1pbWVUeXBlKSAhPSBudWxsID8gX2UgOiBkb3dubG9hZGVkSW1hZ2UubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YTpcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBtaW1lVHlwZSwgYmFzZTY0Q29udGVudCB9ID0gc3BsaXREYXRhVXJsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQuZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWltZVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBFcnJvciBwcm9jZXNzaW5nIGRhdGEgVVJMOiAke2dldEVycm9yTWVzc2FnZTIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChfaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZUJhc2U2NCA9IGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nKFxuICAgICAgICAgICAgICAgICAgcGFydC5kYXRhXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICBkYXRhOiBpbWFnZUJhc2U2NCxcbiAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICkuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidGV4dFwiIHx8IHBhcnQudGV4dCAhPT0gXCJcIiksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LmZpbHRlcihcbiAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgdGV4dCBwYXJ0czpcbiAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlICE9PSBcInRleHRcIiB8fCBwYXJ0LnRleHQgIT09IFwiXCJcbiAgICAgICAgKS5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLCAuLi5yZXN0IH0gPSBwYXJ0O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoKHBhcnQpID0+ICh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICByZXN1bHQ6IHBhcnQucmVzdWx0LFxuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfSkpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcih7IHJvbGU6IF9leGhhdXN0aXZlQ2hlY2sgfSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEFzc2V0cyhtZXNzYWdlcywgZG93bmxvYWRJbXBsZW1lbnRhdGlvbikge1xuICBjb25zdCB1cmxzID0gbWVzc2FnZXMuZmlsdGVyKChtZXNzYWdlKSA9PiBtZXNzYWdlLnJvbGUgPT09IFwidXNlclwiKS5tYXAoKG1lc3NhZ2UpID0+IG1lc3NhZ2UuY29udGVudCkuZmlsdGVyKFxuICAgIChjb250ZW50KSA9PiBBcnJheS5pc0FycmF5KGNvbnRlbnQpXG4gICkuZmxhdCgpLmZpbHRlcihcbiAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcImltYWdlXCIgfHwgcGFydC50eXBlID09PSBcImZpbGVcIlxuICApLm1hcCgocGFydCkgPT4gcGFydC50eXBlID09PSBcImltYWdlXCIgPyBwYXJ0LmltYWdlIDogcGFydC5kYXRhKS5tYXAoXG4gICAgKHBhcnQpID0+IChcbiAgICAgIC8vIHN1cHBvcnQgc3RyaW5nIHVybHM6XG4gICAgICB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIiAmJiAocGFydC5zdGFydHNXaXRoKFwiaHR0cDpcIikgfHwgcGFydC5zdGFydHNXaXRoKFwiaHR0cHM6XCIpKSA/IG5ldyBVUkwocGFydCkgOiBwYXJ0XG4gICAgKVxuICApLmZpbHRlcigoaW1hZ2UpID0+IGltYWdlIGluc3RhbmNlb2YgVVJMKTtcbiAgY29uc3QgZG93bmxvYWRlZEltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHVybHMubWFwKGFzeW5jICh1cmwpID0+ICh7XG4gICAgICB1cmwsXG4gICAgICBkYXRhOiBhd2FpdCBkb3dubG9hZEltcGxlbWVudGF0aW9uKHsgdXJsIH0pXG4gICAgfSkpXG4gICk7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgZG93bmxvYWRlZEltYWdlcy5tYXAoKHsgdXJsLCBkYXRhIH0pID0+IFt1cmwudG9TdHJpbmcoKSwgZGF0YV0pXG4gICk7XG59XG5cbi8vIGVycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I1IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNSA9IFwiQUlfSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbnZhciBtYXJrZXI1ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU1fWA7XG52YXIgc3ltYm9sNSA9IFN5bWJvbC5mb3IobWFya2VyNSk7XG52YXIgX2E1O1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJhbWV0ZXIsXG4gICAgdmFsdWUsXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTUsXG4gICAgICBtZXNzYWdlOiBgSW52YWxpZCBhcmd1bWVudCBmb3IgcGFyYW1ldGVyICR7cGFyYW1ldGVyfTogJHttZXNzYWdlfWBcbiAgICB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjUpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRBcmd1bWVudEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTUgJiYgdHlwZW9mIGVycm9yLnBhcmFtZXRlciA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZXJyb3IudmFsdWUgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHBhcmFtZXRlcjogdGhpcy5wYXJhbWV0ZXIsXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgIH07XG4gIH1cbn07XG5fYTUgPSBzeW1ib2w1O1xuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLWNhbGwtc2V0dGluZ3MudHNcbmZ1bmN0aW9uIHByZXBhcmVDYWxsU2V0dGluZ3Moe1xuICBtYXhUb2tlbnMsXG4gIHRlbXBlcmF0dXJlLFxuICB0b3BQLFxuICB0b3BLLFxuICBwcmVzZW5jZVBlbmFsdHksXG4gIGZyZXF1ZW5jeVBlbmFsdHksXG4gIHN0b3BTZXF1ZW5jZXMsXG4gIHNlZWQsXG4gIG1heFJldHJpZXNcbn0pIHtcbiAgaWYgKG1heFRva2VucyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFRva2VucykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhUb2tlbnMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4VG9rZW5zIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFRva2Vuc1wiLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFRva2VucyBtdXN0IGJlID49IDFcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0ZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wZXJhdHVyZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRlbXBlcmF0dXJlXCIsXG4gICAgICAgIHZhbHVlOiB0ZW1wZXJhdHVyZSxcbiAgICAgICAgbWVzc2FnZTogXCJ0ZW1wZXJhdHVyZSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wUCAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BQICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wUFwiLFxuICAgICAgICB2YWx1ZTogdG9wUCxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BQIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0b3BLICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRvcEsgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0b3BLXCIsXG4gICAgICAgIHZhbHVlOiB0b3BLLFxuICAgICAgICBtZXNzYWdlOiBcInRvcEsgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBwcmVzZW5jZVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJwcmVzZW5jZVBlbmFsdHlcIixcbiAgICAgICAgdmFsdWU6IHByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogXCJwcmVzZW5jZVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZnJlcXVlbmN5UGVuYWx0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImZyZXF1ZW5jeVBlbmFsdHlcIixcbiAgICAgICAgdmFsdWU6IGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwiZnJlcXVlbmN5UGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoc2VlZCAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNlZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2VlZFwiLFxuICAgICAgICB2YWx1ZTogc2VlZCxcbiAgICAgICAgbWVzc2FnZTogXCJzZWVkIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXRyaWVzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlID49IDBcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbWF4VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlOiB0ZW1wZXJhdHVyZSAhPSBudWxsID8gdGVtcGVyYXR1cmUgOiAwLFxuICAgIHRvcFAsXG4gICAgdG9wSyxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBzdG9wU2VxdWVuY2VzOiBzdG9wU2VxdWVuY2VzICE9IG51bGwgJiYgc3RvcFNlcXVlbmNlcy5sZW5ndGggPiAwID8gc3RvcFNlcXVlbmNlcyA6IHZvaWQgMCxcbiAgICBzZWVkLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXMgIT0gbnVsbCA/IG1heFJldHJpZXMgOiAyXG4gIH07XG59XG5cbi8vIGNvcmUvcHJvbXB0L3ZhbGlkYXRlLXByb21wdC50c1xuaW1wb3J0IHsgSW52YWxpZFByb21wdEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVWYWxpZGF0ZVR5cGVzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejYgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvcHJvbXB0L21lc3NhZ2UudHNcbmltcG9ydCB7IHogYXMgejUgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvdHlwZXMvcHJvdmlkZXItbWV0YWRhdGEudHNcbmltcG9ydCB7IHogYXMgejMgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvdHlwZXMvanNvbi12YWx1ZS50c1xuaW1wb3J0IHsgeiBhcyB6MiB9IGZyb20gXCJ6b2RcIjtcbnZhciBqc29uVmFsdWVTY2hlbWEgPSB6Mi5sYXp5KFxuICAoKSA9PiB6Mi51bmlvbihbXG4gICAgejIubnVsbCgpLFxuICAgIHoyLnN0cmluZygpLFxuICAgIHoyLm51bWJlcigpLFxuICAgIHoyLmJvb2xlYW4oKSxcbiAgICB6Mi5yZWNvcmQoejIuc3RyaW5nKCksIGpzb25WYWx1ZVNjaGVtYSksXG4gICAgejIuYXJyYXkoanNvblZhbHVlU2NoZW1hKVxuICBdKVxuKTtcblxuLy8gY29yZS90eXBlcy9wcm92aWRlci1tZXRhZGF0YS50c1xudmFyIHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEgPSB6My5yZWNvcmQoXG4gIHozLnN0cmluZygpLFxuICB6My5yZWNvcmQoejMuc3RyaW5nKCksIGpzb25WYWx1ZVNjaGVtYSlcbik7XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnRlbnQtcGFydC50c1xuaW1wb3J0IHsgeiBhcyB6NCB9IGZyb20gXCJ6b2RcIjtcbnZhciB0ZXh0UGFydFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJ0ZXh0XCIpLFxuICB0ZXh0OiB6NC5zdHJpbmcoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgaW1hZ2VQYXJ0U2NoZW1hID0gejQub2JqZWN0KHtcbiAgdHlwZTogejQubGl0ZXJhbChcImltYWdlXCIpLFxuICBpbWFnZTogejQudW5pb24oW2RhdGFDb250ZW50U2NoZW1hLCB6NC5pbnN0YW5jZW9mKFVSTCldKSxcbiAgbWltZVR5cGU6IHo0LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGZpbGVQYXJ0U2NoZW1hID0gejQub2JqZWN0KHtcbiAgdHlwZTogejQubGl0ZXJhbChcImZpbGVcIiksXG4gIGRhdGE6IHo0LnVuaW9uKFtkYXRhQ29udGVudFNjaGVtYSwgejQuaW5zdGFuY2VvZihVUkwpXSksXG4gIG1pbWVUeXBlOiB6NC5zdHJpbmcoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgdG9vbENhbGxQYXJ0U2NoZW1hID0gejQub2JqZWN0KHtcbiAgdHlwZTogejQubGl0ZXJhbChcInRvb2wtY2FsbFwiKSxcbiAgdG9vbENhbGxJZDogejQuc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6NC5zdHJpbmcoKSxcbiAgYXJnczogejQudW5rbm93bigpXG59KTtcbnZhciB0b29sUmVzdWx0UGFydFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJ0b29sLXJlc3VsdFwiKSxcbiAgdG9vbENhbGxJZDogejQuc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6NC5zdHJpbmcoKSxcbiAgcmVzdWx0OiB6NC51bmtub3duKCksXG4gIGlzRXJyb3I6IHo0LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcblxuLy8gY29yZS9wcm9tcHQvbWVzc2FnZS50c1xudmFyIGNvcmVTeXN0ZW1NZXNzYWdlU2NoZW1hID0gejUub2JqZWN0KHtcbiAgcm9sZTogejUubGl0ZXJhbChcInN5c3RlbVwiKSxcbiAgY29udGVudDogejUuc3RyaW5nKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGNvcmVVc2VyTWVzc2FnZVNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHJvbGU6IHo1LmxpdGVyYWwoXCJ1c2VyXCIpLFxuICBjb250ZW50OiB6NS51bmlvbihbXG4gICAgejUuc3RyaW5nKCksXG4gICAgejUuYXJyYXkoejUudW5pb24oW3RleHRQYXJ0U2NoZW1hLCBpbWFnZVBhcnRTY2hlbWEsIGZpbGVQYXJ0U2NoZW1hXSkpXG4gIF0pLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBjb3JlQXNzaXN0YW50TWVzc2FnZVNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHJvbGU6IHo1LmxpdGVyYWwoXCJhc3Npc3RhbnRcIiksXG4gIGNvbnRlbnQ6IHo1LnVuaW9uKFtcbiAgICB6NS5zdHJpbmcoKSxcbiAgICB6NS5hcnJheSh6NS51bmlvbihbdGV4dFBhcnRTY2hlbWEsIHRvb2xDYWxsUGFydFNjaGVtYV0pKVxuICBdKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZVRvb2xNZXNzYWdlU2NoZW1hID0gejUub2JqZWN0KHtcbiAgcm9sZTogejUubGl0ZXJhbChcInRvb2xcIiksXG4gIGNvbnRlbnQ6IHo1LmFycmF5KHRvb2xSZXN1bHRQYXJ0U2NoZW1hKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZU1lc3NhZ2VTY2hlbWEgPSB6NS51bmlvbihbXG4gIGNvcmVTeXN0ZW1NZXNzYWdlU2NoZW1hLFxuICBjb3JlVXNlck1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVBc3Npc3RhbnRNZXNzYWdlU2NoZW1hLFxuICBjb3JlVG9vbE1lc3NhZ2VTY2hlbWFcbl0pO1xuXG4vLyBjb3JlL3Byb21wdC92YWxpZGF0ZS1wcm9tcHQudHNcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvbXB0KHByb21wdCkge1xuICBpZiAocHJvbXB0LnByb21wdCA9PSBudWxsICYmIHByb21wdC5tZXNzYWdlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBvciBtZXNzYWdlcyBtdXN0IGJlIGRlZmluZWRcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IGFuZCBtZXNzYWdlcyBjYW5ub3QgYmUgZGVmaW5lZCBhdCB0aGUgc2FtZSB0aW1lXCJcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvbXB0LnN5c3RlbSAhPSBudWxsICYmIHR5cGVvZiBwcm9tcHQuc3lzdGVtICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInN5c3RlbSBtdXN0IGJlIGEgc3RyaW5nXCJcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvbXB0LnByb21wdCAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9tcHQucHJvbXB0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlOiBcInByb21wdCBtdXN0IGJlIGEgc3RyaW5nXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwcm9tcHRcIixcbiAgICAgIHByb21wdDogcHJvbXB0LnByb21wdCxcbiAgICAgIG1lc3NhZ2VzOiB2b2lkIDAsXG4gICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW1cbiAgICB9O1xuICB9XG4gIGlmIChwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBzYWZlVmFsaWRhdGVUeXBlcyh7XG4gICAgICB2YWx1ZTogcHJvbXB0Lm1lc3NhZ2VzLFxuICAgICAgc2NoZW1hOiB6Ni5hcnJheShjb3JlTWVzc2FnZVNjaGVtYSlcbiAgICB9KTtcbiAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgbWVzc2FnZTogXCJtZXNzYWdlcyBtdXN0IGJlIGFuIGFycmF5IG9mIENvcmVNZXNzYWdlXCIsXG4gICAgICAgIGNhdXNlOiB2YWxpZGF0aW9uUmVzdWx0LmVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWVzc2FnZXNcIixcbiAgICAgIHByb21wdDogdm9pZCAwLFxuICAgICAgbWVzc2FnZXM6IHByb21wdC5tZXNzYWdlcyxcbiAgICAgIC8vIG9ubHkgcG9zc2libGUgY2FzZSBiYyBvZiBjaGVja3MgYWJvdmVcbiAgICAgIHN5c3RlbTogcHJvbXB0LnN5c3RlbVxuICAgIH07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwidW5yZWFjaGFibGVcIik7XG59XG5cbi8vIGNvcmUvdHlwZXMvdXNhZ2UudHNcbmZ1bmN0aW9uIGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSkge1xuICByZXR1cm4ge1xuICAgIHByb21wdFRva2VuczogdXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgIGNvbXBsZXRpb25Ub2tlbnM6IHVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgdG90YWxUb2tlbnM6IHVzYWdlLnByb21wdFRva2VucyArIHVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgfTtcbn1cblxuLy8gY29yZS91dGlsL3ByZXBhcmUtcmVzcG9uc2UtaGVhZGVycy50c1xuZnVuY3Rpb24gcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gIGNvbnRlbnRUeXBlLFxuICBkYXRhU3RyZWFtVmVyc2lvblxufSkge1xuICB2YXIgX2ExMTtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKChfYTExID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzKSAhPSBudWxsID8gX2ExMSA6IHt9KTtcbiAgaWYgKCFoZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKSkge1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIGNvbnRlbnRUeXBlKTtcbiAgfVxuICBpZiAoZGF0YVN0cmVhbVZlcnNpb24gIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnMuc2V0KFwiWC1WZXJjZWwtQUktRGF0YS1TdHJlYW1cIiwgZGF0YVN0cmVhbVZlcnNpb24pO1xuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9pbmplY3QtanNvbi1pbnN0cnVjdGlvbi50c1xudmFyIERFRkFVTFRfU0NIRU1BX1BSRUZJWCA9IFwiSlNPTiBzY2hlbWE6XCI7XG52YXIgREVGQVVMVF9TQ0hFTUFfU1VGRklYID0gXCJZb3UgTVVTVCBhbnN3ZXIgd2l0aCBhIEpTT04gb2JqZWN0IHRoYXQgbWF0Y2hlcyB0aGUgSlNPTiBzY2hlbWEgYWJvdmUuXCI7XG52YXIgREVGQVVMVF9HRU5FUklDX1NVRkZJWCA9IFwiWW91IE1VU1QgYW5zd2VyIHdpdGggSlNPTi5cIjtcbmZ1bmN0aW9uIGluamVjdEpzb25JbnN0cnVjdGlvbih7XG4gIHByb21wdCxcbiAgc2NoZW1hLFxuICBzY2hlbWFQcmVmaXggPSBzY2hlbWEgIT0gbnVsbCA/IERFRkFVTFRfU0NIRU1BX1BSRUZJWCA6IHZvaWQgMCxcbiAgc2NoZW1hU3VmZml4ID0gc2NoZW1hICE9IG51bGwgPyBERUZBVUxUX1NDSEVNQV9TVUZGSVggOiBERUZBVUxUX0dFTkVSSUNfU1VGRklYXG59KSB7XG4gIHJldHVybiBbXG4gICAgcHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lmxlbmd0aCA+IDAgPyBwcm9tcHQgOiB2b2lkIDAsXG4gICAgcHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lmxlbmd0aCA+IDAgPyBcIlwiIDogdm9pZCAwLFxuICAgIC8vIGFkZCBhIG5ld2xpbmUgaWYgcHJvbXB0IGlzIG5vdCBudWxsXG4gICAgc2NoZW1hUHJlZml4LFxuICAgIHNjaGVtYSAhPSBudWxsID8gSlNPTi5zdHJpbmdpZnkoc2NoZW1hKSA6IHZvaWQgMCxcbiAgICBzY2hlbWFTdWZmaXhcbiAgXS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT0gbnVsbCkuam9pbihcIlxcblwiKTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvbm8tb2JqZWN0LWdlbmVyYXRlZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTYgPSBcIkFJX05vT2JqZWN0R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXI2ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU2fWA7XG52YXIgc3ltYm9sNiA9IFN5bWJvbC5mb3IobWFya2VyNik7XG52YXIgX2E2O1xudmFyIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I2IHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9IFwiTm8gb2JqZWN0IGdlbmVyYXRlZC5cIiB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU2LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E2XSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjYuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc05vT2JqZWN0R2VuZXJhdGVkRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2tcbiAgICB9O1xuICB9XG59O1xuX2E2ID0gc3ltYm9sNjtcblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvb3V0cHV0LXN0cmF0ZWd5LnRzXG5pbXBvcnQge1xuICBpc0pTT05BcnJheSxcbiAgaXNKU09OT2JqZWN0LFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvclxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgc2FmZVZhbGlkYXRlVHlwZXMgYXMgc2FmZVZhbGlkYXRlVHlwZXMyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IGFzU2NoZW1hIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gY29yZS91dGlsL2FzeW5jLWl0ZXJhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShzb3VyY2UsIHRyYW5zZm9ybWVyKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVkU3RyZWFtID0gc291cmNlLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0odHJhbnNmb3JtZXIpXG4gICk7XG4gIHRyYW5zZm9ybWVkU3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9ICgpID0+IHtcbiAgICBjb25zdCByZWFkZXIgPSB0cmFuc2Zvcm1lZFN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgcmV0dXJuIGRvbmUgPyB7IGRvbmU6IHRydWUsIHZhbHVlOiB2b2lkIDAgfSA6IHsgZG9uZTogZmFsc2UsIHZhbHVlIH07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHRyYW5zZm9ybWVkU3RyZWFtO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9vdXRwdXQtc3RyYXRlZ3kudHNcbnZhciBub1NjaGVtYU91dHB1dFN0cmF0ZWd5ID0ge1xuICB0eXBlOiBcIm5vLXNjaGVtYVwiLFxuICBqc29uU2NoZW1hOiB2b2lkIDAsXG4gIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7IHZhbHVlLCB0ZXh0RGVsdGEgfSkge1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiB7IHBhcnRpYWw6IHZhbHVlLCB0ZXh0RGVsdGEgfSB9O1xuICB9LFxuICB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IoKSB9IDogeyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSB9O1xuICB9LFxuICBjcmVhdGVFbGVtZW50U3RyZWFtKCkge1xuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBuby1zY2hlbWEgbW9kZVwiXG4gICAgfSk7XG4gIH1cbn07XG52YXIgb2JqZWN0T3V0cHV0U3RyYXRlZ3kgPSAoc2NoZW1hKSA9PiAoe1xuICB0eXBlOiBcIm9iamVjdFwiLFxuICBqc29uU2NoZW1hOiBzY2hlbWEuanNvblNjaGVtYSxcbiAgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIHRleHREZWx0YSB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICB2YWx1ZToge1xuICAgICAgICAvLyBOb3RlOiBjdXJyZW50bHkgbm8gdmFsaWRhdGlvbiBvZiBwYXJ0aWFsIHJlc3VsdHM6XG4gICAgICAgIHBhcnRpYWw6IHZhbHVlLFxuICAgICAgICB0ZXh0RGVsdGFcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHNhZmVWYWxpZGF0ZVR5cGVzMih7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIG9iamVjdCBtb2RlXCJcbiAgICB9KTtcbiAgfVxufSk7XG52YXIgYXJyYXlPdXRwdXRTdHJhdGVneSA9IChzY2hlbWEpID0+IHtcbiAgY29uc3QgeyAkc2NoZW1hLCAuLi5pdGVtU2NoZW1hIH0gPSBzY2hlbWEuanNvblNjaGVtYTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICAvLyB3cmFwIGluIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFycmF5IG9mIGVsZW1lbnRzLCBzaW5jZSBtb3N0IExMTXMgd2lsbCBub3RcbiAgICAvLyBiZSBhYmxlIHRvIGdlbmVyYXRlIGFuIGFycmF5IGRpcmVjdGx5OlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IHVzZSBhcnJheXMgZGlyZWN0bHkgd2hlbiBtb2RlbCBzdXBwb3J0cyBncmFtbWFyLWd1aWRlZCBnZW5lcmF0aW9uXG4gICAganNvblNjaGVtYToge1xuICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGVsZW1lbnRzOiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IGl0ZW1TY2hlbWEgfVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkOiBbXCJlbGVtZW50c1wiXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH0sXG4gICAgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIGxhdGVzdE9iamVjdCwgaXNGaXJzdERlbHRhLCBpc0ZpbmFsRGVsdGEgfSkge1xuICAgICAgdmFyIF9hMTE7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgIWlzSlNPTkFycmF5KHZhbHVlLmVsZW1lbnRzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcih7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYW4gYXJyYXkgb2YgZWxlbWVudHNcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBpbnB1dEFycmF5ID0gdmFsdWUuZWxlbWVudHM7XG4gICAgICBjb25zdCByZXN1bHRBcnJheSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBpbnB1dEFycmF5W2ldO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzYWZlVmFsaWRhdGVUeXBlczIoeyB2YWx1ZTogZWxlbWVudCwgc2NoZW1hIH0pO1xuICAgICAgICBpZiAoaSA9PT0gaW5wdXRBcnJheS5sZW5ndGggLSAxICYmICFpc0ZpbmFsRGVsdGEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRBcnJheS5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwdWJsaXNoZWRFbGVtZW50Q291bnQgPSAoX2ExMSA9IGxhdGVzdE9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogbGF0ZXN0T2JqZWN0Lmxlbmd0aCkgIT0gbnVsbCA/IF9hMTEgOiAwO1xuICAgICAgbGV0IHRleHREZWx0YSA9IFwiXCI7XG4gICAgICBpZiAoaXNGaXJzdERlbHRhKSB7XG4gICAgICAgIHRleHREZWx0YSArPSBcIltcIjtcbiAgICAgIH1cbiAgICAgIGlmIChwdWJsaXNoZWRFbGVtZW50Q291bnQgPiAwKSB7XG4gICAgICAgIHRleHREZWx0YSArPSBcIixcIjtcbiAgICAgIH1cbiAgICAgIHRleHREZWx0YSArPSByZXN1bHRBcnJheS5zbGljZShwdWJsaXNoZWRFbGVtZW50Q291bnQpLm1hcCgoZWxlbWVudCkgPT4gSlNPTi5zdHJpbmdpZnkoZWxlbWVudCkpLmpvaW4oXCIsXCIpO1xuICAgICAgaWYgKGlzRmluYWxEZWx0YSkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCJdXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHBhcnRpYWw6IHJlc3VsdEFycmF5LFxuICAgICAgICAgIHRleHREZWx0YVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8ICFpc0pTT05BcnJheSh2YWx1ZS5lbGVtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRBcnJheSA9IHZhbHVlLmVsZW1lbnRzO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGlucHV0QXJyYXkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2FmZVZhbGlkYXRlVHlwZXMyKHsgdmFsdWU6IGVsZW1lbnQsIHNjaGVtYSB9KTtcbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiBpbnB1dEFycmF5IH07XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50U3RyZWFtKG9yaWdpbmFsU3RyZWFtKSB7XG4gICAgICBsZXQgcHVibGlzaGVkRWxlbWVudHMgPSAwO1xuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0ob3JpZ2luYWxTdHJlYW0sIHtcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBjaHVuay5vYmplY3Q7XG4gICAgICAgICAgICAgIGZvciAoOyBwdWJsaXNoZWRFbGVtZW50cyA8IGFycmF5Lmxlbmd0aDsgcHVibGlzaGVkRWxlbWVudHMrKykge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShhcnJheVtwdWJsaXNoZWRFbGVtZW50c10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihjaHVuay5lcnJvcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbnZhciBlbnVtT3V0cHV0U3RyYXRlZ3kgPSAoZW51bVZhbHVlcykgPT4ge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIC8vIHdyYXAgaW4gb2JqZWN0IHRoYXQgY29udGFpbnMgcmVzdWx0LCBzaW5jZSBtb3N0IExMTXMgd2lsbCBub3RcbiAgICAvLyBiZSBhYmxlIHRvIGdlbmVyYXRlIGFuIGVudW0gdmFsdWUgZGlyZWN0bHk6XG4gICAgLy8gcG9zc2libGUgZnV0dXJlIG9wdGltaXphdGlvbjogdXNlIGVudW1zIGRpcmVjdGx5IHdoZW4gbW9kZWwgc3VwcG9ydHMgdG9wLWxldmVsIGVudW1zXG4gICAganNvblNjaGVtYToge1xuICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHJlc3VsdDogeyB0eXBlOiBcInN0cmluZ1wiLCBlbnVtOiBlbnVtVmFsdWVzIH1cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogW1wicmVzdWx0XCJdLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlXG4gICAgfSxcbiAgICB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnJlc3VsdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcih7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiAndmFsdWUgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIHN0cmluZyBpbiB0aGUgXCJyZXN1bHRcIiBwcm9wZXJ0eS4nXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnJlc3VsdDtcbiAgICAgIHJldHVybiBlbnVtVmFsdWVzLmluY2x1ZGVzKHJlc3VsdCkgPyB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiByZXN1bHQgfSA6IHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcih7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgY2F1c2U6IFwidmFsdWUgbXVzdCBiZSBhIHN0cmluZyBpbiB0aGUgZW51bVwiXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0sXG4gICAgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KCkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJwYXJ0aWFsIHJlc3VsdHMgaW4gZW51bSBtb2RlXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudFN0cmVhbSgpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIGVudW0gbW9kZVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0T3V0cHV0U3RyYXRlZ3koe1xuICBvdXRwdXQsXG4gIHNjaGVtYSxcbiAgZW51bVZhbHVlc1xufSkge1xuICBzd2l0Y2ggKG91dHB1dCkge1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBvYmplY3RPdXRwdXRTdHJhdGVneShhc1NjaGVtYShzY2hlbWEpKTtcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIHJldHVybiBhcnJheU91dHB1dFN0cmF0ZWd5KGFzU2NoZW1hKHNjaGVtYSkpO1xuICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICByZXR1cm4gZW51bU91dHB1dFN0cmF0ZWd5KGVudW1WYWx1ZXMpO1xuICAgIGNhc2UgXCJuby1zY2hlbWFcIjpcbiAgICAgIHJldHVybiBub1NjaGVtYU91dHB1dFN0cmF0ZWd5O1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBvdXRwdXQ7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG91dHB1dDogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC92YWxpZGF0ZS1vYmplY3QtZ2VuZXJhdGlvbi1pbnB1dC50c1xuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3RHZW5lcmF0aW9uSW5wdXQoe1xuICBvdXRwdXQsXG4gIG1vZGUsXG4gIHNjaGVtYSxcbiAgc2NoZW1hTmFtZSxcbiAgc2NoZW1hRGVzY3JpcHRpb24sXG4gIGVudW1WYWx1ZXNcbn0pIHtcbiAgaWYgKG91dHB1dCAhPSBudWxsICYmIG91dHB1dCAhPT0gXCJvYmplY3RcIiAmJiBvdXRwdXQgIT09IFwiYXJyYXlcIiAmJiBvdXRwdXQgIT09IFwiZW51bVwiICYmIG91dHB1dCAhPT0gXCJuby1zY2hlbWFcIikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBwYXJhbWV0ZXI6IFwib3V0cHV0XCIsXG4gICAgICB2YWx1ZTogb3V0cHV0LFxuICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIG91dHB1dCB0eXBlLlwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJuby1zY2hlbWFcIikge1xuICAgIGlmIChtb2RlID09PSBcImF1dG9cIiB8fCBtb2RlID09PSBcInRvb2xcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1vZGVcIixcbiAgICAgICAgdmFsdWU6IG1vZGUsXG4gICAgICAgIG1lc3NhZ2U6ICdNb2RlIG11c3QgYmUgXCJqc29uXCIgZm9yIG5vLXNjaGVtYSBvdXRwdXQuJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWEgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFEZXNjcmlwdGlvblwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGRlc2NyaXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hTmFtZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hTmFtZVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hTmFtZSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgbmFtZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGlzIHJlcXVpcmVkIGZvciBvYmplY3Qgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIG9iamVjdCBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcImFycmF5XCIpIHtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJFbGVtZW50IHNjaGVtYSBpcyByZXF1aXJlZCBmb3IgYXJyYXkgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGFycmF5IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChvdXRwdXQgPT09IFwiZW51bVwiKSB7XG4gICAgaWYgKHNjaGVtYSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFEZXNjcmlwdGlvblwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGRlc2NyaXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYU5hbWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYU5hbWVcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYU5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIG5hbWUgaXMgbm90IHN1cHBvcnRlZCBmb3IgZW51bSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW51bVZhbHVlcyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZW51bVZhbHVlcyxcbiAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBhcmUgcmVxdWlyZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBlbnVtVmFsdWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIG11c3QgYmUgc3RyaW5ncy5cIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvZ2VuZXJhdGUtb2JqZWN0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkID0gY3JlYXRlSWRHZW5lcmF0b3IoeyBwcmVmaXg6IFwiYWlvYmotXCIsIHNpemU6IDI0IH0pO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVPYmplY3Qoe1xuICBtb2RlbCxcbiAgZW51bTogZW51bVZhbHVlcyxcbiAgLy8gcmVuYW1lIGJjIGVudW0gaXMgcmVzZXJ2ZWQgYnkgdHlwZXNjcmlwdFxuICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICBzY2hlbWFOYW1lLFxuICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgbW9kZSxcbiAgb3V0cHV0ID0gXCJvYmplY3RcIixcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YSxcbiAgX2ludGVybmFsOiB7XG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMgPSBvcmlnaW5hbEdlbmVyYXRlSWQsXG4gICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICB9ID0ge30sXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgICBvdXRwdXQsXG4gICAgbW9kZSxcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgY29uc3Qgb3V0cHV0U3RyYXRlZ3kgPSBnZXRPdXRwdXRTdHJhdGVneSh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgaWYgKG91dHB1dFN0cmF0ZWd5LnR5cGUgPT09IFwibm8tc2NoZW1hXCIgJiYgbW9kZSA9PT0gdm9pZCAwKSB7XG4gICAgbW9kZSA9IFwianNvblwiO1xuICB9XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IC4uLnNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5nZW5lcmF0ZU9iamVjdFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlT2JqZWN0XCIsXG4gICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgIH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWkuc2NoZW1hXCI6IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEgIT0gbnVsbCA/IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEpIH0gOiB2b2lkIDAsXG4gICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgXCJhaS5zY2hlbWEuZGVzY3JpcHRpb25cIjogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIFwiYWkuc2V0dGluZ3Mub3V0cHV0XCI6IG91dHB1dFN0cmF0ZWd5LnR5cGUsXG4gICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlXG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICAgICAgaWYgKG1vZGUgPT09IFwiYXV0b1wiIHx8IG1vZGUgPT0gbnVsbCkge1xuICAgICAgICBtb2RlID0gbW9kZWwuZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGxldCBmaW5pc2hSZWFzb247XG4gICAgICBsZXQgdXNhZ2U7XG4gICAgICBsZXQgd2FybmluZ3M7XG4gICAgICBsZXQgcmF3UmVzcG9uc2U7XG4gICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICBsZXQgbG9ncHJvYnM7XG4gICAgICBsZXQgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlIFwianNvblwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gdmFsaWRhdGVQcm9tcHQoe1xuICAgICAgICAgICAgc3lzdGVtOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hID09IG51bGwgPyBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oeyBwcm9tcHQ6IHN5c3RlbSB9KSA6IG1vZGVsLnN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMgPyBzeXN0ZW0gOiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICAgICAgICBwcm9tcHQ6IHN5c3RlbSxcbiAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDogdmFsaWRhdGVkUHJvbXB0LFxuICAgICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBpbnB1dEZvcm1hdCA9IHZhbGlkYXRlZFByb21wdC50eXBlO1xuICAgICAgICAgIGNvbnN0IGdlbmVyYXRlUmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgbmFtZTogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBpbnB1dEZvcm1hdFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHByb21wdE1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlLFxuICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMTEsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LWpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0LFxuICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Mi50ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgIGlkOiAoX2IgPSAoX2ExMSA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmlkKSAhPSBudWxsID8gX2IgOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2QgPSAoX2MgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MudGltZXN0YW1wKSAhPSBudWxsID8gX2QgOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9mID0gKF9lID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm1vZGVsSWQpICE9IG51bGwgPyBfZiA6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogcmVzdWx0Mi5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IHJlc3VsdDIudGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogcmVzcG9uc2VEYXRhLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZDpcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiByZXN1bHQyLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IHJlc3VsdDIudGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbcmVzdWx0Mi5maW5pc2hSZWFzb25dLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5wcm9tcHRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0Miwgb2JqZWN0VGV4dDogcmVzdWx0Mi50ZXh0LCByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlUmVzdWx0Lm9iamVjdFRleHQ7XG4gICAgICAgICAgZmluaXNoUmVhc29uID0gZ2VuZXJhdGVSZXN1bHQuZmluaXNoUmVhc29uO1xuICAgICAgICAgIHVzYWdlID0gZ2VuZXJhdGVSZXN1bHQudXNhZ2U7XG4gICAgICAgICAgd2FybmluZ3MgPSBnZW5lcmF0ZVJlc3VsdC53YXJuaW5ncztcbiAgICAgICAgICByYXdSZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJhd1Jlc3BvbnNlO1xuICAgICAgICAgIGxvZ3Byb2JzID0gZ2VuZXJhdGVSZXN1bHQubG9ncHJvYnM7XG4gICAgICAgICAgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YSA9IGdlbmVyYXRlUmVzdWx0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgcmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yZXNwb25zZURhdGE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IHZhbGlkYXRlUHJvbXB0KHtcbiAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDogdmFsaWRhdGVkUHJvbXB0LFxuICAgICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBpbnB1dEZvcm1hdCA9IHZhbGlkYXRlZFByb21wdC50eXBlO1xuICAgICAgICAgIGNvbnN0IGdlbmVyYXRlUmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgbmFtZTogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBpbnB1dEZvcm1hdFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHByb21wdE1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlLFxuICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMTEsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3QtdG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICB0b29sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUgIT0gbnVsbCA/IHNjaGVtYU5hbWUgOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb24gIT0gbnVsbCA/IHNjaGVtYURlc2NyaXB0aW9uIDogXCJSZXNwb25kIHdpdGggYSBKU09OIG9iamVjdC5cIixcbiAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0LFxuICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmplY3RUZXh0ID0gKF9iID0gKF9hMTEgPSByZXN1bHQyLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTFbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5hcmdzO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3RUZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgIGlkOiAoX2QgPSAoX2MgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MuaWQpICE9IG51bGwgPyBfZCA6IGdlbmVyYXRlSWQzKCksXG4gICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfZiA9IChfZSA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZS50aW1lc3RhbXApICE9IG51bGwgPyBfZiA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2ggPSAoX2cgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2cubW9kZWxJZCkgIT0gbnVsbCA/IF9oIDogbW9kZWwubW9kZWxJZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc3BhbjIuc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQyLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7IG91dHB1dDogKCkgPT4gb2JqZWN0VGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogcmVzcG9uc2VEYXRhLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZDpcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiByZXN1bHQyLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IG9iamVjdFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3Jlc3VsdDIuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQyLCBvYmplY3RUZXh0LCByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlUmVzdWx0Lm9iamVjdFRleHQ7XG4gICAgICAgICAgZmluaXNoUmVhc29uID0gZ2VuZXJhdGVSZXN1bHQuZmluaXNoUmVhc29uO1xuICAgICAgICAgIHVzYWdlID0gZ2VuZXJhdGVSZXN1bHQudXNhZ2U7XG4gICAgICAgICAgd2FybmluZ3MgPSBnZW5lcmF0ZVJlc3VsdC53YXJuaW5ncztcbiAgICAgICAgICByYXdSZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJhd1Jlc3BvbnNlO1xuICAgICAgICAgIGxvZ3Byb2JzID0gZ2VuZXJhdGVSZXN1bHQubG9ncHJvYnM7XG4gICAgICAgICAgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YSA9IGdlbmVyYXRlUmVzdWx0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgcmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yZXNwb25zZURhdGE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB2b2lkIDA6IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIk1vZGVsIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IG9iamVjdCBnZW5lcmF0aW9uIG1vZGUuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gbW9kZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1vZGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBzYWZlUGFyc2VKU09OKHsgdGV4dDogcmVzdWx0IH0pO1xuICAgICAgaWYgKCFwYXJzZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IHBhcnNlUmVzdWx0LmVycm9yO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlRmluYWxSZXN1bHQoXG4gICAgICAgIHBhcnNlUmVzdWx0LnZhbHVlXG4gICAgICApO1xuICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgdmFsaWRhdGlvblJlc3VsdC5lcnJvcjtcbiAgICAgIH1cbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh2YWxpZGF0aW9uUmVzdWx0LnZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiB1c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgLy8gZGVwcmVjYXRlZDpcbiAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkucmVzdWx0Lm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkodmFsaWRhdGlvblJlc3VsdC52YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQoe1xuICAgICAgICBvYmplY3Q6IHZhbGlkYXRpb25SZXN1bHQudmFsdWUsXG4gICAgICAgIGZpbmlzaFJlYXNvbixcbiAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSksXG4gICAgICAgIHdhcm5pbmdzLFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGxvZ3Byb2JzLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiByZXN1bHRQcm92aWRlck1ldGFkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRHZW5lcmF0ZU9iamVjdFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub2JqZWN0ID0gb3B0aW9ucy5vYmplY3Q7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBvcHRpb25zLmZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSB7XG4gICAgICBoZWFkZXJzOiBvcHRpb25zLnJlc3BvbnNlLmhlYWRlcnNcbiAgICB9O1xuICAgIHRoaXMubG9ncHJvYnMgPSBvcHRpb25zLmxvZ3Byb2JzO1xuICB9XG4gIHRvSnNvblJlc3BvbnNlKGluaXQpIHtcbiAgICB2YXIgX2ExMTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHRoaXMub2JqZWN0KSwge1xuICAgICAgc3RhdHVzOiAoX2ExMSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2ExMSA6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn07XG52YXIgZXhwZXJpbWVudGFsX2dlbmVyYXRlT2JqZWN0ID0gZ2VuZXJhdGVPYmplY3Q7XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L3N0cmVhbS1vYmplY3QudHNcbmltcG9ydCB7IGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQge1xuICBpc0RlZXBFcXVhbERhdGEsXG4gIHBhcnNlUGFydGlhbEpzb25cbn0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlLnRzXG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICByZXNvbHZlLFxuICAgIHJlamVjdFxuICB9O1xufVxuXG4vLyB1dGlsL2RlbGF5ZWQtcHJvbWlzZS50c1xudmFyIERlbGF5ZWRQcm9taXNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHsgdHlwZTogXCJwZW5kaW5nXCIgfTtcbiAgICB0aGlzLl9yZXNvbHZlID0gdm9pZCAwO1xuICAgIHRoaXMuX3JlamVjdCA9IHZvaWQgMDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgaWYgKHRoaXMucHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdHVzLnR5cGUgPT09IFwicmVzb2x2ZWRcIikge1xuICAgICAgICByZXNvbHZlKHRoaXMuc3RhdHVzLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMudHlwZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgIHJlamVjdCh0aGlzLnN0YXR1cy5lcnJvcik7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICB9XG4gIHJlc29sdmUodmFsdWUpIHtcbiAgICB2YXIgX2ExMTtcbiAgICB0aGlzLnN0YXR1cyA9IHsgdHlwZTogXCJyZXNvbHZlZFwiLCB2YWx1ZSB9O1xuICAgIGlmICh0aGlzLnByb21pc2UpIHtcbiAgICAgIChfYTExID0gdGhpcy5fcmVzb2x2ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJlamVjdChlcnJvcikge1xuICAgIHZhciBfYTExO1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInJlamVjdGVkXCIsIGVycm9yIH07XG4gICAgaWYgKHRoaXMucHJvbWlzZSkge1xuICAgICAgKF9hMTEgPSB0aGlzLl9yZWplY3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gY29yZS91dGlsL25vdy50c1xuZnVuY3Rpb24gbm93KCkge1xuICB2YXIgX2ExMSwgX2I7XG4gIHJldHVybiAoX2IgPSAoX2ExMSA9IGdsb2JhbFRoaXMgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMucGVyZm9ybWFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLm5vdygpKSAhPSBudWxsID8gX2IgOiBEYXRlLm5vdygpO1xufVxuXG4vLyBjb3JlL3V0aWwvcHJlcGFyZS1vdXRnb2luZy1odHRwLWhlYWRlcnMudHNcbmZ1bmN0aW9uIHByZXBhcmVPdXRnb2luZ0h0dHBIZWFkZXJzKGluaXQsIHtcbiAgY29udGVudFR5cGUsXG4gIGRhdGFTdHJlYW1WZXJzaW9uXG59KSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKChpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMpICE9IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhpbml0LmhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPT0gbnVsbCkge1xuICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBjb250ZW50VHlwZTtcbiAgfVxuICBpZiAoZGF0YVN0cmVhbVZlcnNpb24gIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnNbXCJYLVZlcmNlbC1BSS1EYXRhLVN0cmVhbVwiXSA9IGRhdGFTdHJlYW1WZXJzaW9uO1xuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxuXG4vLyBjb3JlL3V0aWwvd3JpdGUtdG8tc2VydmVyLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICByZXNwb25zZSxcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICBzdHJlYW1cbn0pIHtcbiAgcmVzcG9uc2Uud3JpdGVIZWFkKHN0YXR1cyAhPSBudWxsID8gc3RhdHVzIDogMjAwLCBzdGF0dXNUZXh0LCBoZWFkZXJzKTtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICBjb25zdCByZWFkID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgcmVzcG9uc2Uud3JpdGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgfVxuICB9O1xuICByZWFkKCk7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L3N0cmVhbS1vYmplY3QudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQyID0gY3JlYXRlSWRHZW5lcmF0b3IyKHsgcHJlZml4OiBcImFpb2JqLVwiLCBzaXplOiAyNCB9KTtcbmFzeW5jIGZ1bmN0aW9uIHN0cmVhbU9iamVjdCh7XG4gIG1vZGVsLFxuICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICBzY2hlbWFOYW1lLFxuICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgbW9kZSxcbiAgb3V0cHV0ID0gXCJvYmplY3RcIixcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YSxcbiAgb25GaW5pc2gsXG4gIF9pbnRlcm5hbDoge1xuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkMixcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgIG5vdzogbm93MiA9IG5vd1xuICB9ID0ge30sXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgICBvdXRwdXQsXG4gICAgbW9kZSxcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb25cbiAgfSk7XG4gIGNvbnN0IG91dHB1dFN0cmF0ZWd5ID0gZ2V0T3V0cHV0U3RyYXRlZ3koeyBvdXRwdXQsIHNjaGVtYTogaW5wdXRTY2hlbWEgfSk7XG4gIGlmIChvdXRwdXRTdHJhdGVneS50eXBlID09PSBcIm5vLXNjaGVtYVwiICYmIG1vZGUgPT09IHZvaWQgMCkge1xuICAgIG1vZGUgPSBcImpzb25cIjtcbiAgfVxuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyAuLi5zZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3RcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5zdHJlYW1PYmplY3RcIixcbiAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgfSxcbiAgICAgICAgXCJhaS5zY2hlbWFcIjogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSAhPSBudWxsID8geyBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSkgfSA6IHZvaWQgMCxcbiAgICAgICAgXCJhaS5zY2hlbWEubmFtZVwiOiBzY2hlbWFOYW1lLFxuICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5vdXRwdXRcIjogb3V0cHV0U3RyYXRlZ3kudHlwZSxcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGVcbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgIGZuOiBhc3luYyAocm9vdFNwYW4pID0+IHtcbiAgICAgIGlmIChtb2RlID09PSBcImF1dG9cIiB8fCBtb2RlID09IG51bGwpIHtcbiAgICAgICAgbW9kZSA9IG1vZGVsLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZTtcbiAgICAgIH1cbiAgICAgIGxldCBjYWxsT3B0aW9ucztcbiAgICAgIGxldCB0cmFuc2Zvcm1lcjtcbiAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlIFwianNvblwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gdmFsaWRhdGVQcm9tcHQoe1xuICAgICAgICAgICAgc3lzdGVtOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hID09IG51bGwgPyBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oeyBwcm9tcHQ6IHN5c3RlbSB9KSA6IG1vZGVsLnN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMgPyBzeXN0ZW0gOiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICAgICAgICBwcm9tcHQ6IHN5c3RlbSxcbiAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LWpzb25cIixcbiAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgICAgIHByb21wdDogYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICAgIHByb21wdDogdmFsaWRhdGVkUHJvbXB0LFxuICAgICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJsc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IHZhbGlkYXRlUHJvbXB0KHtcbiAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LXRvb2xcIixcbiAgICAgICAgICAgICAgdG9vbDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lICE9IG51bGwgPyBzY2hlbWFOYW1lIDogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwgPyBzY2hlbWFEZXNjcmlwdGlvbiA6IFwiUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QuXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICAgICAgICBwcm9tcHQ6IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgICBwcm9tcHQ6IHZhbGlkYXRlZFByb21wdCxcbiAgICAgICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHNcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgIH07XG4gICAgICAgICAgdHJhbnNmb3JtZXIgPSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLmFyZ3NUZXh0RGVsdGEpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIHZvaWQgMDoge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiTW9kZWwgZG9lcyBub3QgaGF2ZSBhIGRlZmF1bHQgb2JqZWN0IGdlbmVyYXRpb24gbW9kZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBtb2RlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbW9kZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlc3VsdDogeyBzdHJlYW0sIHdhcm5pbmdzLCByYXdSZXNwb25zZSB9LFxuICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgIHN0YXJ0VGltZXN0YW1wTXNcbiAgICAgIH0gPSBhd2FpdCByZXRyeShcbiAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3QuZG9TdHJlYW1cIixcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5zdHJlYW1PYmplY3QuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjoge1xuICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBjYWxsT3B0aW9ucy5pbnB1dEZvcm1hdFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGNhbGxPcHRpb25zLnByb21wdClcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGUsXG4gICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogc2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBzZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgICAgIGZuOiBhc3luYyAoZG9TdHJlYW1TcGFuMikgPT4gKHtcbiAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXM6IG5vdzIoKSxcbiAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMixcbiAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgbW9kZWwuZG9TdHJlYW0oY2FsbE9wdGlvbnMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQoe1xuICAgICAgICBvdXRwdXRTdHJhdGVneSxcbiAgICAgICAgc3RyZWFtOiBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRyYW5zZm9ybVN0cmVhbSh0cmFuc2Zvcm1lcikpLFxuICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgcmF3UmVzcG9uc2UsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICByb290U3BhbixcbiAgICAgICAgZG9TdHJlYW1TcGFuLFxuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIHN0YXJ0VGltZXN0YW1wTXMsXG4gICAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgIG5vdzogbm93MixcbiAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzdHJlYW0sXG4gICAgd2FybmluZ3MsXG4gICAgcmF3UmVzcG9uc2UsXG4gICAgb3V0cHV0U3RyYXRlZ3ksXG4gICAgb25GaW5pc2gsXG4gICAgcm9vdFNwYW4sXG4gICAgZG9TdHJlYW1TcGFuLFxuICAgIHRlbGVtZXRyeSxcbiAgICBzdGFydFRpbWVzdGFtcE1zLFxuICAgIG1vZGVsSWQsXG4gICAgbm93OiBub3cyLFxuICAgIGN1cnJlbnREYXRlLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzXG4gIH0pIHtcbiAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IHJhd1Jlc3BvbnNlO1xuICAgIHRoaXMub3V0cHV0U3RyYXRlZ3kgPSBvdXRwdXRTdHJhdGVneTtcbiAgICB0aGlzLm9iamVjdFByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVVc2FnZSwgcHJvbWlzZTogdXNhZ2VQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudXNhZ2UgPSB1c2FnZVByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlUmVzcG9uc2UsIHByb21pc2U6IHJlc3BvbnNlUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2VQcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc29sdmU6IHJlc29sdmVQcm92aWRlck1ldGFkYXRhLFxuICAgICAgcHJvbWlzZTogcHJvdmlkZXJNZXRhZGF0YVByb21pc2VcbiAgICB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhID0gcHJvdmlkZXJNZXRhZGF0YVByb21pc2U7XG4gICAgbGV0IHVzYWdlO1xuICAgIGxldCBmaW5pc2hSZWFzb247XG4gICAgbGV0IHByb3ZpZGVyTWV0YWRhdGE7XG4gICAgbGV0IG9iamVjdDtcbiAgICBsZXQgZXJyb3I7XG4gICAgbGV0IGFjY3VtdWxhdGVkVGV4dCA9IFwiXCI7XG4gICAgbGV0IHRleHREZWx0YSA9IFwiXCI7XG4gICAgbGV0IHJlc3BvbnNlID0ge1xuICAgICAgaWQ6IGdlbmVyYXRlSWQzKCksXG4gICAgICB0aW1lc3RhbXA6IGN1cnJlbnREYXRlKCksXG4gICAgICBtb2RlbElkXG4gICAgfTtcbiAgICBsZXQgbGF0ZXN0T2JqZWN0SnNvbiA9IHZvaWQgMDtcbiAgICBsZXQgbGF0ZXN0T2JqZWN0ID0gdm9pZCAwO1xuICAgIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICAgIGxldCBpc0ZpcnN0RGVsdGEgPSB0cnVlO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub3JpZ2luYWxTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgdmFyIF9hMTEsIF9iLCBfYztcbiAgICAgICAgICBpZiAoaXNGaXJzdENodW5rKSB7XG4gICAgICAgICAgICBjb25zdCBtc1RvRmlyc3RDaHVuayA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wTXM7XG4gICAgICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maXJzdENodW5rXCIsIHtcbiAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICBcImFpLnN0cmVhbS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dCArPSBjaHVuaztcbiAgICAgICAgICAgIHRleHREZWx0YSArPSBjaHVuaztcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsdWU6IGN1cnJlbnRPYmplY3RKc29uLCBzdGF0ZTogcGFyc2VTdGF0ZSB9ID0gcGFyc2VQYXJ0aWFsSnNvbihhY2N1bXVsYXRlZFRleHQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRPYmplY3RKc29uICE9PSB2b2lkIDAgJiYgIWlzRGVlcEVxdWFsRGF0YShsYXRlc3RPYmplY3RKc29uLCBjdXJyZW50T2JqZWN0SnNvbikpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlUGFydGlhbFJlc3VsdCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1cnJlbnRPYmplY3RKc29uLFxuICAgICAgICAgICAgICAgIHRleHREZWx0YSxcbiAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3QsXG4gICAgICAgICAgICAgICAgaXNGaXJzdERlbHRhLFxuICAgICAgICAgICAgICAgIGlzRmluYWxEZWx0YTogcGFyc2VTdGF0ZSA9PT0gXCJzdWNjZXNzZnVsLXBhcnNlXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MgJiYgIWlzRGVlcEVxdWFsRGF0YShsYXRlc3RPYmplY3QsIHZhbGlkYXRpb25SZXN1bHQudmFsdWUucGFydGlhbCkpIHtcbiAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3RKc29uID0gY3VycmVudE9iamVjdEpzb247XG4gICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0ID0gdmFsaWRhdGlvblJlc3VsdC52YWx1ZS5wYXJ0aWFsO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgb2JqZWN0OiBsYXRlc3RPYmplY3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IHZhbGlkYXRpb25SZXN1bHQudmFsdWUudGV4dERlbHRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGV4dERlbHRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpc0ZpcnN0RGVsdGEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGlkOiAoX2ExMSA9IGNodW5rLmlkKSAhPSBudWxsID8gX2ExMSA6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9iID0gY2h1bmsudGltZXN0YW1wKSAhPSBudWxsID8gX2IgOiByZXNwb25zZS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgbW9kZWxJZDogKF9jID0gY2h1bmsubW9kZWxJZCkgIT0gbnVsbCA/IF9jIDogcmVzcG9uc2UubW9kZWxJZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgICBpZiAodGV4dERlbHRhICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsIHRleHREZWx0YSB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBjaHVuay5maW5pc2hSZWFzb247XG4gICAgICAgICAgICAgIHVzYWdlID0gY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlKGNodW5rLnVzYWdlKTtcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IC4uLmNodW5rLCB1c2FnZSwgcmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgIHJlc29sdmVVc2FnZSh1c2FnZSk7XG4gICAgICAgICAgICAgIHJlc29sdmVQcm92aWRlck1ldGFkYXRhKHByb3ZpZGVyTWV0YWRhdGEpO1xuICAgICAgICAgICAgICByZXNvbHZlUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gb3V0cHV0U3RyYXRlZ3kudmFsaWRhdGVGaW5hbFJlc3VsdChsYXRlc3RPYmplY3RKc29uKTtcbiAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IHZhbGlkYXRpb25SZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgc2VsZi5vYmplY3RQcm9taXNlLnJlc29sdmUob2JqZWN0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IHZhbGlkYXRpb25SZXN1bHQuZXJyb3I7XG4gICAgICAgICAgICAgICAgc2VsZi5vYmplY3RQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsVXNhZ2UgPSB1c2FnZSAhPSBudWxsID8gdXNhZ2UgOiB7XG4gICAgICAgICAgICAgIHByb21wdFRva2VuczogTmFOLFxuICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBOYU4sXG4gICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQub2JqZWN0XCI6IHsgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QpIH0sXG4gICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBmaW5hbFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgIHJvb3RTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiBmaW5hbFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiBmaW5hbFVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0Lm9iamVjdFwiOiB7IG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGF3YWl0IChvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goe1xuICAgICAgICAgICAgICB1c2FnZTogZmluYWxVc2FnZSxcbiAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgcmF3UmVzcG9uc2UsXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogcmF3UmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJhd1Jlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgd2FybmluZ3MsXG4gICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yMik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGdldCBvYmplY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0UHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgcGFydGlhbE9iamVjdFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLm9iamVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihjaHVuay5lcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgZWxlbWVudFN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRTdHJhdGVneS5jcmVhdGVFbGVtZW50U3RyZWFtKHRoaXMub3JpZ2luYWxTdHJlYW0pO1xuICB9XG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMub3JpZ2luYWxTdHJlYW0sIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLnRleHREZWx0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGNodW5rLmVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVuaztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBmdWxsU3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMub3JpZ2luYWxTdHJlYW0sIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHN0YXR1czogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlT3V0Z29pbmdIdHRwSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSksXG4gICAgICBzdHJlYW06IHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSlcbiAgICB9KTtcbiAgfVxuICB0b1RleHRTdHJlYW1SZXNwb25zZShpbml0KSB7XG4gICAgdmFyIF9hMTE7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLnRleHRTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpLCB7XG4gICAgICBzdGF0dXM6IChfYTExID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTExIDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcbnZhciBleHBlcmltZW50YWxfc3RyZWFtT2JqZWN0ID0gc3RyZWFtT2JqZWN0O1xuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvZ2VuZXJhdGUtdGV4dC50c1xuaW1wb3J0IHsgY3JlYXRlSWRHZW5lcmF0b3IgYXMgY3JlYXRlSWRHZW5lcmF0b3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gZXJyb3JzL2luZGV4LnRzXG5pbXBvcnQge1xuICBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMCxcbiAgQVBJQ2FsbEVycm9yIGFzIEFQSUNhbGxFcnJvcjIsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvciBhcyBJbnZhbGlkUHJvbXB0RXJyb3IyLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3IyLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciBhcyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gZXJyb3JzL2ludmFsaWQtdG9vbC1hcmd1bWVudHMtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjcsIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2UzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNyA9IFwiQUlfSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvclwiO1xudmFyIG1hcmtlcjcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTd9YDtcbnZhciBzeW1ib2w3ID0gU3ltYm9sLmZvcihtYXJrZXI3KTtcbnZhciBfYTc7XG52YXIgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjcge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbEFyZ3MsXG4gICAgdG9vbE5hbWUsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgdG9vbCAke3Rvb2xOYW1lfTogJHtnZXRFcnJvck1lc3NhZ2UzKFxuICAgICAgY2F1c2VcbiAgICApfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTcsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E3XSA9IHRydWU7XG4gICAgdGhpcy50b29sQXJncyA9IHRvb2xBcmdzO1xuICAgIHRoaXMudG9vbE5hbWUgPSB0b29sTmFtZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjcpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRUb29sQXJndW1lbnRzRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNyAmJiB0eXBlb2YgZXJyb3IudG9vbE5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLnRvb2xBcmdzID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHRvb2xOYW1lOiB0aGlzLnRvb2xOYW1lLFxuICAgICAgdG9vbEFyZ3M6IHRoaXMudG9vbEFyZ3NcbiAgICB9O1xuICB9XG59O1xuX2E3ID0gc3ltYm9sNztcblxuLy8gZXJyb3JzL25vLXN1Y2gtdG9vbC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yOCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTggPSBcIkFJX05vU3VjaFRvb2xFcnJvclwiO1xudmFyIG1hcmtlcjggPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTh9YDtcbnZhciBzeW1ib2w4ID0gU3ltYm9sLmZvcihtYXJrZXI4KTtcbnZhciBfYTg7XG52YXIgTm9TdWNoVG9vbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yOCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0b29sTmFtZSxcbiAgICBhdmFpbGFibGVUb29scyA9IHZvaWQgMCxcbiAgICBtZXNzYWdlID0gYE1vZGVsIHRyaWVkIHRvIGNhbGwgdW5hdmFpbGFibGUgdG9vbCAnJHt0b29sTmFtZX0nLiAke2F2YWlsYWJsZVRvb2xzID09PSB2b2lkIDAgPyBcIk5vIHRvb2xzIGFyZSBhdmFpbGFibGUuXCIgOiBgQXZhaWxhYmxlIHRvb2xzOiAke2F2YWlsYWJsZVRvb2xzLmpvaW4oXCIsIFwiKX0uYH1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU4LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E4XSA9IHRydWU7XG4gICAgdGhpcy50b29sTmFtZSA9IHRvb2xOYW1lO1xuICAgIHRoaXMuYXZhaWxhYmxlVG9vbHMgPSBhdmFpbGFibGVUb29scztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yOC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjgpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc05vU3VjaFRvb2xFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU4ICYmIFwidG9vbE5hbWVcIiBpbiBlcnJvciAmJiBlcnJvci50b29sTmFtZSAhPSB2b2lkIDAgJiYgdHlwZW9mIGVycm9yLm5hbWUgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHRvb2xOYW1lOiB0aGlzLnRvb2xOYW1lLFxuICAgICAgYXZhaWxhYmxlVG9vbHM6IHRoaXMuYXZhaWxhYmxlVG9vbHNcbiAgICB9O1xuICB9XG59O1xuX2E4ID0gc3ltYm9sODtcblxuLy8gY29yZS9wcm9tcHQvbWVzc2FnZS1jb252ZXJzaW9uLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lOSA9IFwiQUlfTWVzc2FnZUNvbnZlcnNpb25FcnJvclwiO1xudmFyIG1hcmtlcjkgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTl9YDtcbnZhciBzeW1ib2w5ID0gU3ltYm9sLmZvcihtYXJrZXI5KTtcbnZhciBfYTk7XG52YXIgTWVzc2FnZUNvbnZlcnNpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3JpZ2luYWxNZXNzYWdlLFxuICAgIG1lc3NhZ2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTksIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTldID0gdHJ1ZTtcbiAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yOS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjkpO1xuICB9XG59O1xuX2E5ID0gc3ltYm9sOTtcblxuLy8gY29yZS9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UudHNcbmltcG9ydCB7IGFzU2NoZW1hIGFzIGFzU2NoZW1hMiB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGNvcmUvdXRpbC9pcy1ub24tZW1wdHktb2JqZWN0LnRzXG5mdW5jdGlvbiBpc05vbkVtcHR5T2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGggPiAwO1xufVxuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50c1xuZnVuY3Rpb24gcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7XG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlXG59KSB7XG4gIGlmICghaXNOb25FbXB0eU9iamVjdCh0b29scykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHM6IHZvaWQgMCxcbiAgICAgIHRvb2xDaG9pY2U6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b29sczogT2JqZWN0LmVudHJpZXModG9vbHMpLm1hcCgoW25hbWUxMSwgdG9vbDJdKSA9PiAoe1xuICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgbmFtZTogbmFtZTExLFxuICAgICAgZGVzY3JpcHRpb246IHRvb2wyLmRlc2NyaXB0aW9uLFxuICAgICAgcGFyYW1ldGVyczogYXNTY2hlbWEyKHRvb2wyLnBhcmFtZXRlcnMpLmpzb25TY2hlbWFcbiAgICB9KSksXG4gICAgdG9vbENob2ljZTogdG9vbENob2ljZSA9PSBudWxsID8geyB0eXBlOiBcImF1dG9cIiB9IDogdHlwZW9mIHRvb2xDaG9pY2UgPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IHRvb2xDaG9pY2UgfSA6IHsgdHlwZTogXCJ0b29sXCIsIHRvb2xOYW1lOiB0b29sQ2hvaWNlLnRvb2xOYW1lIH1cbiAgfTtcbn1cblxuLy8gY29yZS91dGlsL3NwbGl0LW9uLWxhc3Qtd2hpdGVzcGFjZS50c1xudmFyIGxhc3RXaGl0ZXNwYWNlUmVnZXhwID0gL14oW1xcc1xcU10qPykoXFxzKykoXFxTKikkLztcbmZ1bmN0aW9uIHNwbGl0T25MYXN0V2hpdGVzcGFjZSh0ZXh0KSB7XG4gIGNvbnN0IG1hdGNoID0gdGV4dC5tYXRjaChsYXN0V2hpdGVzcGFjZVJlZ2V4cCk7XG4gIHJldHVybiBtYXRjaCA/IHsgcHJlZml4OiBtYXRjaFsxXSwgd2hpdGVzcGFjZTogbWF0Y2hbMl0sIHN1ZmZpeDogbWF0Y2hbM10gfSA6IHZvaWQgMDtcbn1cblxuLy8gY29yZS91dGlsL3JlbW92ZS10ZXh0LWFmdGVyLWxhc3Qtd2hpdGVzcGFjZS50c1xuZnVuY3Rpb24gcmVtb3ZlVGV4dEFmdGVyTGFzdFdoaXRlc3BhY2UodGV4dCkge1xuICBjb25zdCBtYXRjaCA9IHNwbGl0T25MYXN0V2hpdGVzcGFjZSh0ZXh0KTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2gucHJlZml4ICsgbWF0Y2gud2hpdGVzcGFjZSA6IHRleHQ7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9wYXJzZS10b29sLWNhbGwudHNcbmltcG9ydCB7IHNhZmVQYXJzZUpTT04gYXMgc2FmZVBhcnNlSlNPTjIsIHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyBhc1NjaGVtYSBhcyBhc1NjaGVtYTMgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuZnVuY3Rpb24gcGFyc2VUb29sQ2FsbCh7XG4gIHRvb2xDYWxsLFxuICB0b29sc1xufSkge1xuICBjb25zdCB0b29sTmFtZSA9IHRvb2xDYWxsLnRvb2xOYW1lO1xuICBpZiAodG9vbHMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3IoeyB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUgfSk7XG4gIH1cbiAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gIGlmICh0b29sMiA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hID0gYXNTY2hlbWEzKHRvb2wyLnBhcmFtZXRlcnMpO1xuICBjb25zdCBwYXJzZVJlc3VsdCA9IHRvb2xDYWxsLmFyZ3MudHJpbSgpID09PSBcIlwiID8gc2FmZVZhbGlkYXRlVHlwZXMzKHsgdmFsdWU6IHt9LCBzY2hlbWEgfSkgOiBzYWZlUGFyc2VKU09OMih7IHRleHQ6IHRvb2xDYWxsLmFyZ3MsIHNjaGVtYSB9KTtcbiAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUb29sQXJndW1lbnRzRXJyb3Ioe1xuICAgICAgdG9vbE5hbWUsXG4gICAgICB0b29sQXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIHRvb2xOYW1lLFxuICAgIGFyZ3M6IHBhcnNlUmVzdWx0LnZhbHVlXG4gIH07XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC90by1yZXNwb25zZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gdG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgdGV4dCA9IFwiXCIsXG4gIHRvb2xDYWxscyxcbiAgdG9vbFJlc3VsdHNcbn0pIHtcbiAgY29uc3QgcmVzcG9uc2VNZXNzYWdlcyA9IFtdO1xuICByZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQgfSwgLi4udG9vbENhbGxzXVxuICB9KTtcbiAgaWYgKHRvb2xSZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICBjb250ZW50OiB0b29sUmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICB0b29sQ2FsbElkOiByZXN1bHQudG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWU6IHJlc3VsdC50b29sTmFtZSxcbiAgICAgICAgcmVzdWx0OiByZXN1bHQucmVzdWx0XG4gICAgICB9KSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzcG9uc2VNZXNzYWdlcztcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L2dlbmVyYXRlLXRleHQudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQzID0gY3JlYXRlSWRHZW5lcmF0b3IzKHsgcHJlZml4OiBcImFpdHh0LVwiLCBzaXplOiAyNCB9KTtcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVGV4dCh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgbWF4QXV0b21hdGljUm91bmR0cmlwcyA9IDAsXG4gIG1heFRvb2xSb3VuZHRyaXBzID0gbWF4QXV0b21hdGljUm91bmR0cmlwcyxcbiAgbWF4U3RlcHMgPSBtYXhUb29sUm91bmR0cmlwcyAhPSBudWxsID8gbWF4VG9vbFJvdW5kdHJpcHMgKyAxIDogMSxcbiAgZXhwZXJpbWVudGFsX2NvbnRpbnVhdGlvblN0ZXBzLFxuICBleHBlcmltZW50YWxfY29udGludWVTdGVwczogY29udGludWVTdGVwcyA9IGV4cGVyaW1lbnRhbF9jb250aW51YXRpb25TdGVwcyAhPSBudWxsID8gZXhwZXJpbWVudGFsX2NvbnRpbnVhdGlvblN0ZXBzIDogZmFsc2UsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGEsXG4gIF9pbnRlcm5hbDoge1xuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkMyxcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gIH0gPSB7fSxcbiAgb25TdGVwRmluaXNoLFxuICAuLi5zZXR0aW5nc1xufSkge1xuICBpZiAobWF4U3RlcHMgPCAxKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgIHBhcmFtZXRlcjogXCJtYXhTdGVwc1wiLFxuICAgICAgdmFsdWU6IG1heFN0ZXBzLFxuICAgICAgbWVzc2FnZTogXCJtYXhTdGVwcyBtdXN0IGJlIGF0IGxlYXN0IDFcIlxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IC4uLnNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5nZW5lcmF0ZVRleHRcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZVRleHRcIixcbiAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgfSxcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5tYXhTdGVwc1wiOiBtYXhTdGVwc1xuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIHZhciBfYTExLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IHZhbGlkYXRlUHJvbXB0KHtcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2VzXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vZGUgPSB7XG4gICAgICAgIHR5cGU6IFwicmVndWxhclwiLFxuICAgICAgICAuLi5wcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHsgdG9vbHMsIHRvb2xDaG9pY2UgfSlcbiAgICAgIH07XG4gICAgICBjb25zdCBjYWxsU2V0dGluZ3MgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgIHByb21wdDogdmFsaWRhdGVkUHJvbXB0LFxuICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJsc1xuICAgICAgfSk7XG4gICAgICBsZXQgY3VycmVudE1vZGVsUmVzcG9uc2U7XG4gICAgICBsZXQgY3VycmVudFRvb2xDYWxscyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnRUb29sUmVzdWx0cyA9IFtdO1xuICAgICAgbGV0IHN0ZXBDb3VudCA9IDA7XG4gICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2VzID0gW107XG4gICAgICBsZXQgdGV4dCA9IFwiXCI7XG4gICAgICBjb25zdCBzdGVwcyA9IFtdO1xuICAgICAgY29uc3QgdXNhZ2UgPSB7XG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IDAsXG4gICAgICAgIHByb21wdFRva2VuczogMCxcbiAgICAgICAgdG90YWxUb2tlbnM6IDBcbiAgICAgIH07XG4gICAgICBsZXQgc3RlcFR5cGUgPSBcImluaXRpYWxcIjtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgY3VycmVudElucHV0Rm9ybWF0ID0gc3RlcENvdW50ID09PSAwID8gdmFsaWRhdGVkUHJvbXB0LnR5cGUgOiBcIm1lc3NhZ2VzXCI7XG4gICAgICAgIGN1cnJlbnRNb2RlbFJlc3BvbnNlID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlVGV4dC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlVGV4dC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjogeyBpbnB1dDogKCkgPT4gY3VycmVudElucHV0Rm9ybWF0IH0sXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHByb21wdE1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnN0b3Bfc2VxdWVuY2VzXCI6IHNldHRpbmdzLnN0b3BTZXF1ZW5jZXMsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBzZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IHNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChzcGFuMikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExMiwgX2IyLCBfYzIsIF9kMiwgX2UyLCBfZjtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICAuLi5jYWxsU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IGN1cnJlbnRJbnB1dEZvcm1hdCxcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0ge1xuICAgICAgICAgICAgICAgIGlkOiAoX2IyID0gKF9hMTIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTEyLmlkKSAhPSBudWxsID8gX2IyIDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfZDIgPSAoX2MyID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MyLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9kMiA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICAgICAgbW9kZWxJZDogKF9mID0gKF9lMiA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lMi5tb2RlbElkKSAhPSBudWxsID8gX2YgOiBtb2RlbC5tb2RlbElkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IHJlc3VsdC5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiByZXN1bHQudGV4dFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShyZXN1bHQudG9vbENhbGxzKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogcmVzcG9uc2VEYXRhLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiByZXN1bHQudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogcmVzdWx0LnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQ6XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IHJlc3VsdC5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0LnRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gcmVzdWx0LnRleHRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdC50b29sQ2FsbHMpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3Jlc3VsdC5maW5pc2hSZWFzb25dLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5pbnB1dF90b2tlbnNcIjogcmVzdWx0LnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2Uub3V0cHV0X3Rva2Vuc1wiOiByZXN1bHQudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLnJlc3VsdCwgcmVzcG9uc2U6IHJlc3BvbnNlRGF0YSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJlbnRUb29sQ2FsbHMgPSAoKF9hMTEgPSBjdXJyZW50TW9kZWxSZXNwb25zZS50b29sQ2FsbHMpICE9IG51bGwgPyBfYTExIDogW10pLm1hcChcbiAgICAgICAgICAobW9kZWxUb29sQ2FsbCkgPT4gcGFyc2VUb29sQ2FsbCh7IHRvb2xDYWxsOiBtb2RlbFRvb2xDYWxsLCB0b29scyB9KVxuICAgICAgICApO1xuICAgICAgICBjdXJyZW50VG9vbFJlc3VsdHMgPSB0b29scyA9PSBudWxsID8gW10gOiBhd2FpdCBleGVjdXRlVG9vbHMoe1xuICAgICAgICAgIHRvb2xDYWxsczogY3VycmVudFRvb2xDYWxscyxcbiAgICAgICAgICB0b29scyxcbiAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGFib3J0U2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjdXJyZW50VXNhZ2UgPSBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UoXG4gICAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2VcbiAgICAgICAgKTtcbiAgICAgICAgdXNhZ2UuY29tcGxldGlvblRva2VucyArPSBjdXJyZW50VXNhZ2UuY29tcGxldGlvblRva2VucztcbiAgICAgICAgdXNhZ2UucHJvbXB0VG9rZW5zICs9IGN1cnJlbnRVc2FnZS5wcm9tcHRUb2tlbnM7XG4gICAgICAgIHVzYWdlLnRvdGFsVG9rZW5zICs9IGN1cnJlbnRVc2FnZS50b3RhbFRva2VucztcbiAgICAgICAgbGV0IG5leHRTdGVwVHlwZSA9IFwiZG9uZVwiO1xuICAgICAgICBpZiAoKytzdGVwQ291bnQgPCBtYXhTdGVwcykge1xuICAgICAgICAgIGlmIChjb250aW51ZVN0ZXBzICYmIGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbiA9PT0gXCJsZW5ndGhcIiAmJiAvLyBvbmx5IHVzZSBjb250aW51ZSB3aGVuIHRoZXJlIGFyZSBubyB0b29sIGNhbGxzOlxuICAgICAgICAgIGN1cnJlbnRUb29sQ2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBuZXh0U3RlcFR5cGUgPSBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIC8vIHRoZXJlIGFyZSB0b29sIGNhbGxzOlxuICAgICAgICAgICAgY3VycmVudFRvb2xDYWxscy5sZW5ndGggPiAwICYmIC8vIGFsbCBjdXJyZW50IHRvb2wgY2FsbHMgaGF2ZSByZXN1bHRzOlxuICAgICAgICAgICAgY3VycmVudFRvb2xSZXN1bHRzLmxlbmd0aCA9PT0gY3VycmVudFRvb2xDYWxscy5sZW5ndGhcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG5leHRTdGVwVHlwZSA9IFwidG9vbC1yZXN1bHRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RlcFRleHQgPSBuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIiA/IHJlbW92ZVRleHRBZnRlckxhc3RXaGl0ZXNwYWNlKChfYiA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRleHQpICE9IG51bGwgPyBfYiA6IFwiXCIpIDogKF9jID0gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dCkgIT0gbnVsbCA/IF9jIDogXCJcIjtcbiAgICAgICAgdGV4dCA9IG5leHRTdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiIHx8IHN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIgPyB0ZXh0ICsgc3RlcFRleHQgOiBzdGVwVGV4dDtcbiAgICAgICAgY29uc3QgY3VycmVudFN0ZXAgPSB7XG4gICAgICAgICAgc3RlcFR5cGUsXG4gICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHMsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgdXNhZ2U6IGN1cnJlbnRVc2FnZSxcbiAgICAgICAgICB3YXJuaW5nczogY3VycmVudE1vZGVsUmVzcG9uc2Uud2FybmluZ3MsXG4gICAgICAgICAgbG9ncHJvYnM6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmxvZ3Byb2JzLFxuICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAuLi5jdXJyZW50TW9kZWxSZXNwb25zZS5yZXNwb25zZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IChfZCA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2QuaGVhZGVyc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgaXNDb250aW51ZWQ6IG5leHRTdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiXG4gICAgICAgIH07XG4gICAgICAgIHN0ZXBzLnB1c2goY3VycmVudFN0ZXApO1xuICAgICAgICBhd2FpdCAob25TdGVwRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvblN0ZXBGaW5pc2goY3VycmVudFN0ZXApKTtcbiAgICAgICAgaWYgKHN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgICBjb25zdCBsYXN0UmVzcG9uc2VNZXNzYWdlID0gcmVzcG9uc2VNZXNzYWdlcy5wb3AoKTtcbiAgICAgICAgICBwcm9tcHRNZXNzYWdlcy5wb3AoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGxhc3RSZXNwb25zZU1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGFzdFJlc3BvbnNlTWVzc2FnZS5jb250ZW50ID0gdGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdFJlc3BvbnNlTWVzc2FnZS5jb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiBzdGVwVGV4dCxcbiAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2gobGFzdFJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICAgICAgcHJvbXB0TWVzc2FnZXMucHVzaChcbiAgICAgICAgICAgIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKGxhc3RSZXNwb25zZU1lc3NhZ2UsIG51bGwpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICAgIGNvbnN0IG5ld1Jlc3BvbnNlTWVzc2FnZXMgPSB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIHRvb2xDYWxsczogY3VycmVudFRvb2xDYWxscyxcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goLi4ubmV3UmVzcG9uc2VNZXNzYWdlcyk7XG4gICAgICAgICAgcHJvbXB0TWVzc2FnZXMucHVzaChcbiAgICAgICAgICAgIC4uLm5ld1Jlc3BvbnNlTWVzc2FnZXMubWFwKFxuICAgICAgICAgICAgICAobWVzc2FnZSkgPT4gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UobWVzc2FnZSwgbnVsbClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG5ld1Jlc3BvbnNlTWVzc2FnZXMgPSB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgICAgdGV4dDogY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dCxcbiAgICAgICAgICAgIHRvb2xDYWxsczogY3VycmVudFRvb2xDYWxscyxcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goLi4ubmV3UmVzcG9uc2VNZXNzYWdlcyk7XG4gICAgICAgICAgcHJvbXB0TWVzc2FnZXMucHVzaChcbiAgICAgICAgICAgIC4uLm5ld1Jlc3BvbnNlTWVzc2FnZXMubWFwKFxuICAgICAgICAgICAgICAobWVzc2FnZSkgPT4gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UobWVzc2FnZSwgbnVsbClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXBUeXBlID0gbmV4dFN0ZXBUeXBlO1xuICAgICAgfSB3aGlsZSAoc3RlcFR5cGUgIT09IFwiZG9uZVwiKTtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShjdXJyZW50TW9kZWxSZXNwb25zZS50b29sQ2FsbHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAvLyBkZXByZWNhdGVkOlxuICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgXCJhaS5yZXN1bHQudGV4dFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkucmVzdWx0LnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoY3VycmVudE1vZGVsUmVzcG9uc2UudG9vbENhbGxzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRHZW5lcmF0ZVRleHRSZXN1bHQoe1xuICAgICAgICB0ZXh0LFxuICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHMsXG4gICAgICAgIGZpbmlzaFJlYXNvbjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLFxuICAgICAgICB1c2FnZSxcbiAgICAgICAgd2FybmluZ3M6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIC4uLmN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlc3BvbnNlLFxuICAgICAgICAgIGhlYWRlcnM6IChfZSA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2UuaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBsb2dwcm9iczogY3VycmVudE1vZGVsUmVzcG9uc2UubG9ncHJvYnMsXG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgIHN0ZXBzLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjdXJyZW50TW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVRvb2xzKHtcbiAgdG9vbENhbGxzLFxuICB0b29scyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnksXG4gIGFib3J0U2lnbmFsXG59KSB7XG4gIGNvbnN0IHRvb2xSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdG9vbENhbGxzLm1hcChhc3luYyAodG9vbENhbGwpID0+IHtcbiAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhlY3V0ZSkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVjb3JkU3Bhbih7XG4gICAgICAgIG5hbWU6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBcImFpLnRvb2xDYWxsLm5hbWVcIjogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICBcImFpLnRvb2xDYWxsLmlkXCI6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICBcImFpLnRvb2xDYWxsLmFyZ3NcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHRvb2xDYWxsLmFyZ3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgdHJhY2VyLFxuICAgICAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgdG9vbDIuZXhlY3V0ZSh0b29sQ2FsbC5hcmdzLCB7IGFib3J0U2lnbmFsIH0pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLnJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocmVzdWx0MilcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICBhcmdzOiB0b29sQ2FsbC5hcmdzLFxuICAgICAgICByZXN1bHRcbiAgICAgIH07XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIHRvb2xSZXN1bHRzLmZpbHRlcihcbiAgICAocmVzdWx0KSA9PiByZXN1bHQgIT0gbnVsbFxuICApO1xufVxudmFyIERlZmF1bHRHZW5lcmF0ZVRleHRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRleHQgPSBvcHRpb25zLnRleHQ7XG4gICAgdGhpcy50b29sQ2FsbHMgPSBvcHRpb25zLnRvb2xDYWxscztcbiAgICB0aGlzLnRvb2xSZXN1bHRzID0gb3B0aW9ucy50b29sUmVzdWx0cztcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IG9wdGlvbnMuZmluaXNoUmVhc29uO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgIHRoaXMucmVzcG9uc2VNZXNzYWdlcyA9IG9wdGlvbnMucmVzcG9uc2VNZXNzYWdlcztcbiAgICB0aGlzLnJvdW5kdHJpcHMgPSBvcHRpb25zLnN0ZXBzO1xuICAgIHRoaXMuc3RlcHMgPSBvcHRpb25zLnN0ZXBzO1xuICAgIHRoaXMuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IHtcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMucmVzcG9uc2UuaGVhZGVyc1xuICAgIH07XG4gICAgdGhpcy5sb2dwcm9icyA9IG9wdGlvbnMubG9ncHJvYnM7XG4gIH1cbn07XG52YXIgZXhwZXJpbWVudGFsX2dlbmVyYXRlVGV4dCA9IGdlbmVyYXRlVGV4dDtcblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3N0cmVhbS10ZXh0LnRzXG5pbXBvcnQgeyBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL3V0aWwvY3JlYXRlLXN0aXRjaGFibGUtc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVTdGl0Y2hhYmxlU3RyZWFtKCkge1xuICBsZXQgaW5uZXJTdHJlYW1SZWFkZXJzID0gW107XG4gIGxldCBjb250cm9sbGVyID0gbnVsbDtcbiAgbGV0IGlzQ2xvc2VkID0gZmFsc2U7XG4gIGNvbnN0IHByb2Nlc3NQdWxsID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0Nsb3NlZCAmJiBpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpbm5lclN0cmVhbVJlYWRlcnNbMF0ucmVhZCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF3YWl0IHByb2Nlc3NQdWxsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDbG9zZWQpIHtcbiAgICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzLnNoaWZ0KCk7XG4gICAgICBpZiAoaXNDbG9zZWQgJiYgaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0KGNvbnRyb2xsZXJQYXJhbSkge1xuICAgICAgICBjb250cm9sbGVyID0gY29udHJvbGxlclBhcmFtO1xuICAgICAgfSxcbiAgICAgIHB1bGw6IHByb2Nlc3NQdWxsLFxuICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiBpbm5lclN0cmVhbVJlYWRlcnMpIHtcbiAgICAgICAgICBhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzID0gW107XG4gICAgICAgIGlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBhZGRTdHJlYW06IChpbm5lclN0cmVhbSkgPT4ge1xuICAgICAgaWYgKGlzQ2xvc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgaW5uZXIgc3RyZWFtOiBvdXRlciBzdHJlYW0gaXMgY2xvc2VkXCIpO1xuICAgICAgfVxuICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzLnB1c2goaW5uZXJTdHJlYW0uZ2V0UmVhZGVyKCkpO1xuICAgIH0sXG4gICAgY2xvc2U6ICgpID0+IHtcbiAgICAgIGlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIGNvcmUvdXRpbC9tZXJnZS1zdHJlYW1zLnRzXG5mdW5jdGlvbiBtZXJnZVN0cmVhbXMoc3RyZWFtMSwgc3RyZWFtMikge1xuICBjb25zdCByZWFkZXIxID0gc3RyZWFtMS5nZXRSZWFkZXIoKTtcbiAgY29uc3QgcmVhZGVyMiA9IHN0cmVhbTIuZ2V0UmVhZGVyKCk7XG4gIGxldCBsYXN0UmVhZDEgPSB2b2lkIDA7XG4gIGxldCBsYXN0UmVhZDIgPSB2b2lkIDA7XG4gIGxldCBzdHJlYW0xRG9uZSA9IGZhbHNlO1xuICBsZXQgc3RyZWFtMkRvbmUgPSBmYWxzZTtcbiAgYXN5bmMgZnVuY3Rpb24gcmVhZFN0cmVhbTEoY29udHJvbGxlcikge1xuICAgIHRyeSB7XG4gICAgICBpZiAobGFzdFJlYWQxID09IG51bGwpIHtcbiAgICAgICAgbGFzdFJlYWQxID0gcmVhZGVyMS5yZWFkKCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsYXN0UmVhZDE7XG4gICAgICBsYXN0UmVhZDEgPSB2b2lkIDA7XG4gICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVhZFN0cmVhbTIoY29udHJvbGxlcikge1xuICAgIHRyeSB7XG4gICAgICBpZiAobGFzdFJlYWQyID09IG51bGwpIHtcbiAgICAgICAgbGFzdFJlYWQyID0gcmVhZGVyMi5yZWFkKCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsYXN0UmVhZDI7XG4gICAgICBsYXN0UmVhZDIgPSB2b2lkIDA7XG4gICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc3RyZWFtMURvbmUpIHtcbiAgICAgICAgICBhd2FpdCByZWFkU3RyZWFtMihjb250cm9sbGVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbTJEb25lKSB7XG4gICAgICAgICAgYXdhaXQgcmVhZFN0cmVhbTEoY29udHJvbGxlcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UmVhZDEgPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RSZWFkMSA9IHJlYWRlcjEucmVhZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UmVhZDIgPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RSZWFkMiA9IHJlYWRlcjIucmVhZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0LCByZWFkZXIgfSA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgbGFzdFJlYWQxLnRoZW4oKHJlc3VsdDIpID0+ICh7IHJlc3VsdDogcmVzdWx0MiwgcmVhZGVyOiByZWFkZXIxIH0pKSxcbiAgICAgICAgICBsYXN0UmVhZDIudGhlbigocmVzdWx0MikgPT4gKHsgcmVzdWx0OiByZXN1bHQyLCByZWFkZXI6IHJlYWRlcjIgfSkpXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWRlciA9PT0gcmVhZGVyMSkge1xuICAgICAgICAgIGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0yKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgc3RyZWFtMURvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0UmVhZDIgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICBzdHJlYW0yRG9uZSA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCByZWFkU3RyZWFtMShjb250cm9sbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuY2VsKCkge1xuICAgICAgcmVhZGVyMS5jYW5jZWwoKTtcbiAgICAgIHJlYWRlcjIuY2FuY2VsKCk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3J1bi10b29scy10cmFuc2Zvcm1hdGlvbi50c1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgdG9vbHMsXG4gIGdlbmVyYXRvclN0cmVhbSxcbiAgdG9vbENhbGxTdHJlYW1pbmcsXG4gIHRyYWNlcixcbiAgdGVsZW1ldHJ5LFxuICBhYm9ydFNpZ25hbFxufSkge1xuICBsZXQgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgY29uc3Qgb3V0c3RhbmRpbmdUb29sQ2FsbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyID0gbnVsbDtcbiAgY29uc3QgdG9vbFJlc3VsdHNTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgYWN0aXZlVG9vbENhbGxzID0ge307XG4gIGNvbnN0IGZvcndhcmRTdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICBzd2l0Y2ggKGNodW5rVHlwZSkge1xuICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjpcbiAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjoge1xuICAgICAgICAgIGlmICh0b29sQ2FsbFN0cmVhbWluZykge1xuICAgICAgICAgICAgaWYgKCFhY3RpdmVUb29sQ2FsbHNbY2h1bmsudG9vbENhbGxJZF0pIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWN0aXZlVG9vbENhbGxzW2NodW5rLnRvb2xDYWxsSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsLWRlbHRhXCIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgYXJnc1RleHREZWx0YTogY2h1bmsuYXJnc1RleHREZWx0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gY2h1bmsudG9vbE5hbWU7XG4gICAgICAgICAgaWYgKHRvb2xzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IE5vU3VjaFRvb2xFcnJvcih7IHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVRvb2xzOiBPYmplY3Qua2V5cyh0b29scylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbCA9IHBhcnNlVG9vbENhbGwoe1xuICAgICAgICAgICAgICB0b29sQ2FsbDogY2h1bmssXG4gICAgICAgICAgICAgIHRvb2xzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0b29sQ2FsbCk7XG4gICAgICAgICAgICBpZiAodG9vbDIuZXhlY3V0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xFeGVjdXRpb25JZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sQ2FsbHMuYWRkKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5uYW1lXCI6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLmlkXCI6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwuYXJnc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbC5hcmdzKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbikgPT4gdG9vbDIuZXhlY3V0ZSh0b29sQ2FsbC5hcmdzLCB7IGFib3J0U2lnbmFsIH0pLnRoZW4oXG4gICAgICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi50b29sQ2FsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xDYWxscy5kZWxldGUodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbkNsb3NlICYmIG91dHN0YW5kaW5nVG9vbENhbGxzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLnJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbENhbGxzLmRlbGV0ZSh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuQ2xvc2UgJiYgb3V0c3RhbmRpbmdUb29sQ2FsbHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIGxvZ3Byb2JzOiBjaHVuay5sb2dwcm9icyxcbiAgICAgICAgICAgIHVzYWdlOiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UoY2h1bmsudXNhZ2UpLFxuICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoKCkge1xuICAgICAgY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgaWYgKG91dHN0YW5kaW5nVG9vbENhbGxzLnNpemUgPT09IDApIHtcbiAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2VuZXJhdG9yU3RyZWFtLnBpcGVUaHJvdWdoKGZvcndhcmRTdHJlYW0pLnBpcGVUbyhcbiAgICAgICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICB0b29sUmVzdWx0c1N0cmVhbS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICBdKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvc3RyZWFtLXRleHQudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQ0ID0gY3JlYXRlSWRHZW5lcmF0b3I0KHsgcHJlZml4OiBcImFpdHh0LVwiLCBzaXplOiAyNCB9KTtcbmFzeW5jIGZ1bmN0aW9uIHN0cmVhbVRleHQoe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIG1heFRvb2xSb3VuZHRyaXBzID0gMCxcbiAgbWF4U3RlcHMgPSBtYXhUb29sUm91bmR0cmlwcyAhPSBudWxsID8gbWF4VG9vbFJvdW5kdHJpcHMgKyAxIDogMSxcbiAgZXhwZXJpbWVudGFsX2NvbnRpbnVlU3RlcHM6IGNvbnRpbnVlU3RlcHMgPSBmYWxzZSxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YSxcbiAgZXhwZXJpbWVudGFsX3Rvb2xDYWxsU3RyZWFtaW5nOiB0b29sQ2FsbFN0cmVhbWluZyA9IGZhbHNlLFxuICBvbkNodW5rLFxuICBvbkZpbmlzaCxcbiAgb25TdGVwRmluaXNoLFxuICBfaW50ZXJuYWw6IHtcbiAgICBub3c6IG5vdzIgPSBub3csXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMgPSBvcmlnaW5hbEdlbmVyYXRlSWQ0LFxuICAgIGN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgfSA9IHt9LFxuICAuLi5zZXR0aW5nc1xufSkge1xuICBpZiAobWF4U3RlcHMgPCAxKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgIHBhcmFtZXRlcjogXCJtYXhTdGVwc1wiLFxuICAgICAgdmFsdWU6IG1heFN0ZXBzLFxuICAgICAgbWVzc2FnZTogXCJtYXhTdGVwcyBtdXN0IGJlIGF0IGxlYXN0IDFcIlxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IC4uLnNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5zdHJlYW1UZXh0XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbVRleHRcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWkuc2V0dGluZ3MubWF4U3RlcHNcIjogbWF4U3RlcHNcbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgIGZuOiBhc3luYyAocm9vdFNwYW4pID0+IHtcbiAgICAgIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgICAgIGNvbnN0IHN0YXJ0U3RlcCA9IGFzeW5jICh7XG4gICAgICAgIHByb21wdE1lc3NhZ2VzOiBwcm9tcHRNZXNzYWdlczIsXG4gICAgICAgIHByb21wdFR5cGVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlc3VsdDogeyBzdHJlYW06IHN0cmVhbTIsIHdhcm5pbmdzOiB3YXJuaW5nczIsIHJhd1Jlc3BvbnNlOiByYXdSZXNwb25zZTIgfSxcbiAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjIsXG4gICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogc3RhcnRUaW1lc3RhbXBNczJcbiAgICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5zdHJlYW1UZXh0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbVRleHQuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gcHJvbXB0VHlwZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHByb21wdE1lc3NhZ2VzMilcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogc2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5zdG9wX3NlcXVlbmNlc1wiOiBzZXR0aW5ncy5zdG9wU2VxdWVuY2VzLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogc2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9TdHJlYW1TcGFuMykgPT4gKHtcbiAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogbm93MigpLFxuICAgICAgICAgICAgICAvLyBnZXQgYmVmb3JlIHRoZSBjYWxsXG4gICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMyxcbiAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBtb2RlbC5kb1N0cmVhbSh7XG4gICAgICAgICAgICAgICAgbW9kZToge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWd1bGFyXCIsXG4gICAgICAgICAgICAgICAgICAuLi5wcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHsgdG9vbHMsIHRvb2xDaG9pY2UgfSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0OiBwcm9tcHRUeXBlLFxuICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMyLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgc3RyZWFtOiBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgIGdlbmVyYXRvclN0cmVhbTogc3RyZWFtMixcbiAgICAgICAgICAgICAgdG9vbENhbGxTdHJlYW1pbmcsXG4gICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MyLFxuICAgICAgICAgICAgcmF3UmVzcG9uc2U6IHJhd1Jlc3BvbnNlMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4yLFxuICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXM6IHN0YXJ0VGltZXN0YW1wTXMyXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgcHJvbXB0OiB2YWxpZGF0ZVByb21wdCh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KSxcbiAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHNcbiAgICAgIH0pO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXN1bHQ6IHsgc3RyZWFtLCB3YXJuaW5ncywgcmF3UmVzcG9uc2UgfSxcbiAgICAgICAgZG9TdHJlYW1TcGFuLFxuICAgICAgICBzdGFydFRpbWVzdGFtcE1zXG4gICAgICB9ID0gYXdhaXQgc3RhcnRTdGVwKHtcbiAgICAgICAgcHJvbXB0VHlwZTogdmFsaWRhdGVQcm9tcHQoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSkudHlwZSxcbiAgICAgICAgcHJvbXB0TWVzc2FnZXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0U3RyZWFtVGV4dFJlc3VsdCh7XG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgd2FybmluZ3MsXG4gICAgICAgIHJhd1Jlc3BvbnNlLFxuICAgICAgICBvbkNodW5rLFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgb25TdGVwRmluaXNoLFxuICAgICAgICByb290U3BhbixcbiAgICAgICAgZG9TdHJlYW1TcGFuLFxuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIHN0YXJ0VGltZXN0YW1wTXMsXG4gICAgICAgIG1heFN0ZXBzLFxuICAgICAgICBjb250aW51ZVN0ZXBzLFxuICAgICAgICBzdGFydFN0ZXAsXG4gICAgICAgIHByb21wdE1lc3NhZ2VzLFxuICAgICAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICBub3c6IG5vdzIsXG4gICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkM1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3RyZWFtVGV4dFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHN0cmVhbSxcbiAgICB3YXJuaW5ncyxcbiAgICByYXdSZXNwb25zZSxcbiAgICBvbkNodW5rLFxuICAgIG9uRmluaXNoLFxuICAgIG9uU3RlcEZpbmlzaCxcbiAgICByb290U3BhbixcbiAgICBkb1N0cmVhbVNwYW4sXG4gICAgdGVsZW1ldHJ5LFxuICAgIHN0YXJ0VGltZXN0YW1wTXMsXG4gICAgbWF4U3RlcHMsXG4gICAgY29udGludWVTdGVwcyxcbiAgICBzdGFydFN0ZXAsXG4gICAgcHJvbXB0TWVzc2FnZXMsXG4gICAgbW9kZWxJZCxcbiAgICBub3c6IG5vdzIsXG4gICAgY3VycmVudERhdGUsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDNcbiAgfSkge1xuICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0gcmF3UmVzcG9uc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVXNhZ2UsIHByb21pc2U6IHVzYWdlUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2VQcm9taXNlO1xuICAgIGNvbnN0IHsgcmVzb2x2ZTogcmVzb2x2ZUZpbmlzaFJlYXNvbiwgcHJvbWlzZTogZmluaXNoUmVhc29uUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IGZpbmlzaFJlYXNvblByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVGV4dCwgcHJvbWlzZTogdGV4dFByb21pc2UgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy50ZXh0ID0gdGV4dFByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVG9vbENhbGxzLCBwcm9taXNlOiB0b29sQ2FsbHNQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudG9vbENhbGxzID0gdG9vbENhbGxzUHJvbWlzZTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVUb29sUmVzdWx0cywgcHJvbWlzZTogdG9vbFJlc3VsdHNQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudG9vbFJlc3VsdHMgPSB0b29sUmVzdWx0c1Byb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlU3RlcHMsIHByb21pc2U6IHN0ZXBzUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnN0ZXBzID0gc3RlcHNQcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc29sdmU6IHJlc29sdmVQcm92aWRlck1ldGFkYXRhLFxuICAgICAgcHJvbWlzZTogcHJvdmlkZXJNZXRhZGF0YVByb21pc2VcbiAgICB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhID0gcHJvdmlkZXJNZXRhZGF0YVByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlUmVzcG9uc2UsIHByb21pc2U6IHJlc3BvbnNlUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2VQcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc29sdmU6IHJlc29sdmVSZXNwb25zZU1lc3NhZ2VzLFxuICAgICAgcHJvbWlzZTogcmVzcG9uc2VNZXNzYWdlc1Byb21pc2VcbiAgICB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnJlc3BvbnNlTWVzc2FnZXMgPSByZXNwb25zZU1lc3NhZ2VzUHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICBzdHJlYW06IHN0aXRjaGFibGVTdHJlYW0sXG4gICAgICBhZGRTdHJlYW0sXG4gICAgICBjbG9zZTogY2xvc2VTdGl0Y2hhYmxlU3RyZWFtXG4gICAgfSA9IGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKTtcbiAgICB0aGlzLm9yaWdpbmFsU3RyZWFtID0gc3RpdGNoYWJsZVN0cmVhbTtcbiAgICBjb25zdCBzdGVwUmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIGFkZFN0ZXBTdHJlYW0oe1xuICAgICAgc3RyZWFtOiBzdHJlYW0yLFxuICAgICAgc3RhcnRUaW1lc3RhbXAsXG4gICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjIsXG4gICAgICBjdXJyZW50U3RlcCxcbiAgICAgIHByb21wdE1lc3NhZ2VzOiBwcm9tcHRNZXNzYWdlczIsXG4gICAgICB1c2FnZSA9IHtcbiAgICAgICAgcHJvbXB0VG9rZW5zOiAwLFxuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiAwLFxuICAgICAgICB0b3RhbFRva2VuczogMFxuICAgICAgfSxcbiAgICAgIHN0ZXBUeXBlLFxuICAgICAgcHJldmlvdXNTdGVwVGV4dCA9IFwiXCJcbiAgICB9KSB7XG4gICAgICBjb25zdCBzdGVwVG9vbENhbGxzID0gW107XG4gICAgICBjb25zdCBzdGVwVG9vbFJlc3VsdHMgPSBbXTtcbiAgICAgIGxldCBzdGVwRmluaXNoUmVhc29uID0gXCJ1bmtub3duXCI7XG4gICAgICBsZXQgc3RlcFVzYWdlID0ge1xuICAgICAgICBwcm9tcHRUb2tlbnM6IDAsXG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IDAsXG4gICAgICAgIHRvdGFsVG9rZW5zOiAwXG4gICAgICB9O1xuICAgICAgbGV0IHN0ZXBQcm92aWRlck1ldGFkYXRhO1xuICAgICAgbGV0IHN0ZXBGaXJzdENodW5rID0gdHJ1ZTtcbiAgICAgIGxldCBzdGVwVGV4dCA9IFwiXCI7XG4gICAgICBsZXQgZnVsbFN0ZXBUZXh0ID0gc3RlcFR5cGUgPT09IFwiY29udGludWVcIiA/IHByZXZpb3VzU3RlcFRleHQgOiBcIlwiO1xuICAgICAgbGV0IHN0ZXBMb2dQcm9icztcbiAgICAgIGxldCBzdGVwUmVzcG9uc2UgPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICB0aW1lc3RhbXA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgIG1vZGVsSWRcbiAgICAgIH07XG4gICAgICBsZXQgY2h1bmtCdWZmZXIgPSBcIlwiO1xuICAgICAgbGV0IGNodW5rVGV4dFB1Ymxpc2hlZCA9IGZhbHNlO1xuICAgICAgYXN5bmMgZnVuY3Rpb24gcHVibGlzaFRleHRDaHVuayh7XG4gICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgIGNodW5rXG4gICAgICB9KSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIHN0ZXBUZXh0ICs9IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgZnVsbFN0ZXBUZXh0ICs9IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgY2h1bmtUZXh0UHVibGlzaGVkID0gdHJ1ZTtcbiAgICAgICAgYXdhaXQgKG9uQ2h1bmsgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2h1bmsoeyBjaHVuayB9KSk7XG4gICAgICB9XG4gICAgICBhZGRTdHJlYW0oXG4gICAgICAgIHN0cmVhbTIucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgdmFyIF9hMTEsIF9iLCBfYztcbiAgICAgICAgICAgICAgaWYgKHN0ZXBGaXJzdENodW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpcnN0Q2h1bmsgPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBzdGVwRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjIuYWRkRXZlbnQoXCJhaS5zdHJlYW0uZmlyc3RDaHVua1wiLCB7XG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rLFxuICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZDpcbiAgICAgICAgICAgICAgICAgIFwiYWkuc3RyZWFtLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuMi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmssXG4gICAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkOlxuICAgICAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIgJiYgY2h1bmsudGV4dERlbHRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlmIChjb250aW51ZVN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rQnVmZmVyICs9IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BsaXQgPSBzcGxpdE9uTGFzdFdoaXRlc3BhY2UoY2h1bmtCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNodW5rQnVmZmVyID0gc3BsaXQuc3VmZml4O1xuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHB1Ymxpc2hUZXh0Q2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IHNwbGl0LnByZWZpeCArIHNwbGl0LndoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHVibGlzaFRleHRDaHVuayh7IGNvbnRyb2xsZXIsIGNodW5rIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIHN0ZXBUb29sQ2FsbHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICBhd2FpdCAob25DaHVuayA9PSBudWxsID8gdm9pZCAwIDogb25DaHVuayh7IGNodW5rIH0pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIHN0ZXBUb29sUmVzdWx0cy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IChvbkNodW5rID09IG51bGwgPyB2b2lkIDAgOiBvbkNodW5rKHsgY2h1bmsgfSkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgICBzdGVwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAoX2ExMSA9IGNodW5rLmlkKSAhPSBudWxsID8gX2ExMSA6IHN0ZXBSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2IgPSBjaHVuay50aW1lc3RhbXApICE9IG51bGwgPyBfYiA6IHN0ZXBSZXNwb25zZS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfYyA9IGNodW5rLm1vZGVsSWQpICE9IG51bGwgPyBfYyA6IHN0ZXBSZXNwb25zZS5tb2RlbElkXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgICAgICAgc3RlcFVzYWdlID0gY2h1bmsudXNhZ2U7XG4gICAgICAgICAgICAgICAgICBzdGVwRmluaXNoUmVhc29uID0gY2h1bmsuZmluaXNoUmVhc29uO1xuICAgICAgICAgICAgICAgICAgc3RlcFByb3ZpZGVyTWV0YWRhdGEgPSBjaHVuay5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgIHN0ZXBMb2dQcm9icyA9IGNodW5rLmxvZ3Byb2JzO1xuICAgICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpbmlzaCA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wO1xuICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuMi5hZGRFdmVudChcImFpLnN0cmVhbS5maW5pc2hcIik7XG4gICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4yLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaW5pc2hcIjogbXNUb0ZpbmlzaCxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5hdmdDb21wbGV0aW9uVG9rZW5zUGVyU2Vjb25kXCI6IDFlMyAqIHN0ZXBVc2FnZS5jb21wbGV0aW9uVG9rZW5zIC8gbXNUb0ZpbmlzaFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBhd2FpdCAob25DaHVuayA9PSBudWxsID8gdm9pZCAwIDogb25DaHVuayh7IGNodW5rIH0pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIHN0ZXBGaW5pc2hSZWFzb24gPSBcImVycm9yXCI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNodW5rIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGludm9rZSBvbkZpbmlzaCBjYWxsYmFjayBhbmQgcmVzb2x2ZSB0b29sUmVzdWx0cyBwcm9taXNlIHdoZW4gdGhlIHN0cmVhbSBpcyBhYm91dCB0byBjbG9zZTpcbiAgICAgICAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxsc0pzb24gPSBzdGVwVG9vbENhbGxzLmxlbmd0aCA+IDAgPyBKU09OLnN0cmluZ2lmeShzdGVwVG9vbENhbGxzKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgbGV0IG5leHRTdGVwVHlwZSA9IFwiZG9uZVwiO1xuICAgICAgICAgICAgICBpZiAoY3VycmVudFN0ZXAgKyAxIDwgbWF4U3RlcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGludWVTdGVwcyAmJiBzdGVwRmluaXNoUmVhc29uID09PSBcImxlbmd0aFwiICYmIC8vIG9ubHkgdXNlIGNvbnRpbnVlIHdoZW4gdGhlcmUgYXJlIG5vIHRvb2wgY2FsbHM6XG4gICAgICAgICAgICAgICAgc3RlcFRvb2xDYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG5leHRTdGVwVHlwZSA9IFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgYXJlIHRvb2wgY2FsbHM6XG4gICAgICAgICAgICAgICAgICBzdGVwVG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgLy8gYWxsIGN1cnJlbnQgdG9vbCBjYWxscyBoYXZlIHJlc3VsdHM6XG4gICAgICAgICAgICAgICAgICBzdGVwVG9vbFJlc3VsdHMubGVuZ3RoID09PSBzdGVwVG9vbENhbGxzLmxlbmd0aFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgbmV4dFN0ZXBUeXBlID0gXCJ0b29sLXJlc3VsdFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29udGludWVTdGVwcyAmJiBjaHVua0J1ZmZlci5sZW5ndGggPiAwICYmIChuZXh0U3RlcFR5cGUgIT09IFwiY29udGludWVcIiB8fCAvLyB3aGVuIHRoZSBuZXh0IHN0ZXAgaXMgYSByZWd1bGFyIHN0ZXAsIHB1Ymxpc2ggdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICBzdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiICYmICFjaHVua1RleHRQdWJsaXNoZWQpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcHVibGlzaFRleHRDaHVuayh7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgY2h1bms6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgIHRleHREZWx0YTogY2h1bmtCdWZmZXJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjaHVua0J1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjogeyBvdXRwdXQ6ICgpID0+IHN0ZXBUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBzdGVwVG9vbENhbGxzSnNvblxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiBzdGVwUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiBzdGVwUmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiBzdGVwUmVzcG9uc2UudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogc3RlcFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogc3RlcFVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQudGV4dFwiOiB7IG91dHB1dDogKCkgPT4gc3RlcFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBzdGVwVG9vbENhbGxzSnNvblxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtzdGVwRmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiBzdGVwUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogc3RlcFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHN0ZXBVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2Uub3V0cHV0X3Rva2Vuc1wiOiBzdGVwVXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuMi5lbmQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcC1maW5pc2hcIixcbiAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHN0ZXBVc2FnZSxcbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgbG9ncHJvYnM6IHN0ZXBMb2dQcm9icyxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogc3RlcFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIGlzQ29udGludWVkOiBuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3Qgc3RlcFJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBzdGVwVHlwZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBzdGVwVGV4dCxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbHM6IHN0ZXBUb29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgdG9vbFJlc3VsdHM6IHN0ZXBUb29sUmVzdWx0cyxcbiAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHN0ZXBVc2FnZSxcbiAgICAgICAgICAgICAgICB3YXJuaW5nczogc2VsZi53YXJuaW5ncyxcbiAgICAgICAgICAgICAgICBsb2dwcm9iczogc3RlcExvZ1Byb2JzLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBzdGVwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcmF3UmVzcG9uc2U6IHNlbGYucmF3UmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHN0ZXBQcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGlzQ29udGludWVkOiBuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzdGVwUmVzdWx0cy5wdXNoKHN0ZXBSZXN1bHQpO1xuICAgICAgICAgICAgICBhd2FpdCAob25TdGVwRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvblN0ZXBGaW5pc2goc3RlcFJlc3VsdCkpO1xuICAgICAgICAgICAgICBjb25zdCBjb21iaW5lZFVzYWdlID0ge1xuICAgICAgICAgICAgICAgIHByb21wdFRva2VuczogdXNhZ2UucHJvbXB0VG9rZW5zICsgc3RlcFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiB1c2FnZS5jb21wbGV0aW9uVG9rZW5zICsgc3RlcFVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgdG90YWxUb2tlbnM6IHVzYWdlLnRvdGFsVG9rZW5zICsgc3RlcFVzYWdlLnRvdGFsVG9rZW5zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChuZXh0U3RlcFR5cGUgIT09IFwiZG9uZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RQcm9tcHRNZXNzYWdlID0gcHJvbXB0TWVzc2FnZXMyW3Byb21wdE1lc3NhZ2VzMi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgIGxhc3RQcm9tcHRNZXNzYWdlLmNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHN0ZXBUZXh0LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHByb21wdE1lc3NhZ2VzMi5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAuLi50b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHN0ZXBUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsczogc3RlcFRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0czogc3RlcFRvb2xSZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgIH0pLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZSkgPT4gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UobWVzc2FnZSwgbnVsbClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4zLFxuICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogc3RhcnRUaW1lc3RhbXAyXG4gICAgICAgICAgICAgICAgfSA9IGF3YWl0IHN0YXJ0U3RlcCh7XG4gICAgICAgICAgICAgICAgICBwcm9tcHRUeXBlOiBcIm1lc3NhZ2VzXCIsXG4gICAgICAgICAgICAgICAgICBwcm9tcHRNZXNzYWdlczogcHJvbXB0TWVzc2FnZXMyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsZi53YXJuaW5ncyA9IHJlc3VsdC53YXJuaW5ncztcbiAgICAgICAgICAgICAgICBzZWxmLnJhd1Jlc3BvbnNlID0gcmVzdWx0LnJhd1Jlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGFkZFN0ZXBTdHJlYW0oe1xuICAgICAgICAgICAgICAgICAgc3RyZWFtOiByZXN1bHQuc3RyZWFtLFxuICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXA6IHN0YXJ0VGltZXN0YW1wMixcbiAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBjdXJyZW50U3RlcCArIDEsXG4gICAgICAgICAgICAgICAgICBwcm9tcHRNZXNzYWdlczogcHJvbXB0TWVzc2FnZXMyLFxuICAgICAgICAgICAgICAgICAgdXNhZ2U6IGNvbWJpbmVkVXNhZ2UsXG4gICAgICAgICAgICAgICAgICBzdGVwVHlwZTogbmV4dFN0ZXBUeXBlLFxuICAgICAgICAgICAgICAgICAgcHJldmlvdXNTdGVwVGV4dDogZnVsbFN0ZXBUZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICB1c2FnZTogY29tYmluZWRVc2FnZSxcbiAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBzdGVwUHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgIGxvZ3Byb2JzOiBzdGVwTG9nUHJvYnMsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZTogc3RlcFJlc3BvbnNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2xvc2VTdGl0Y2hhYmxlU3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgcm9vdFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7IG91dHB1dDogKCkgPT4gZnVsbFN0ZXBUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBzdGVwVG9vbENhbGxzSnNvblxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogY29tYmluZWRVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGNvbWJpbmVkVXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC50ZXh0XCI6IHsgb3V0cHV0OiAoKSA9PiBmdWxsU3RlcFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBzdGVwVG9vbENhbGxzSnNvblxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZXMgPSBzdGVwUmVzdWx0cy5yZWR1Y2UoKHJlc3BvbnNlTWVzc2FnZXMyLCBzdGVwKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoc3RlcC5zdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RSZXNwb25zZU1lc3NhZ2UgPSByZXNwb25zZU1lc3NhZ2VzMi5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0UmVzcG9uc2VNZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVzcG9uc2VNZXNzYWdlLmNvbnRlbnQgKz0gc3RlcC50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGxhc3RSZXNwb25zZU1lc3NhZ2UuY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHN0ZXAudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5yZXNwb25zZU1lc3NhZ2VzMiwgbGFzdFJlc3BvbnNlTWVzc2FnZV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAuLi5yZXNwb25zZU1lc3NhZ2VzMixcbiAgICAgICAgICAgICAgICAgICAgLi4udG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzdGVwLnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxzOiBzdGVwLnRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0czogc3RlcC50b29sUmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVVzYWdlKGNvbWJpbmVkVXNhZ2UpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVGaW5pc2hSZWFzb24oc3RlcEZpbmlzaFJlYXNvbik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVRleHQoZnVsbFN0ZXBUZXh0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlVG9vbENhbGxzKHN0ZXBUb29sQ2FsbHMpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVQcm92aWRlck1ldGFkYXRhKHN0ZXBQcm92aWRlck1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlVG9vbFJlc3VsdHMoc3RlcFRvb2xSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgICAgLi4uc3RlcFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmF3UmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJhd1Jlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlU3RlcHMoc3RlcFJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVSZXNwb25zZU1lc3NhZ2VzKHJlc3BvbnNlTWVzc2FnZXMpO1xuICAgICAgICAgICAgICAgIGF3YWl0IChvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goe1xuICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgbG9ncHJvYnM6IHN0ZXBMb2dQcm9icyxcbiAgICAgICAgICAgICAgICAgIHVzYWdlOiBjb21iaW5lZFVzYWdlLFxuICAgICAgICAgICAgICAgICAgdGV4dDogZnVsbFN0ZXBUZXh0LFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxzOiBzdGVwVG9vbENhbGxzLFxuICAgICAgICAgICAgICAgICAgLy8gVGhlIHRvb2wgcmVzdWx0cyBhcmUgaW5mZXJyZWQgYXMgYSBuZXZlcltdIHR5cGUsIGJlY2F1c2UgdGhleSBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsIGFuZCB0aGUgZXhlY3V0ZSBtZXRob2Qgd2l0aCBhbiBpbmZlcnJlZCByZXN1bHQgdHlwZSBpc1xuICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uYWwgYXMgd2VsbC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gY2FzdCB0aGUgdG9vbFJlc3VsdHMgdG8gYW55LlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIHR5cGUgZXhwb3NlZCB0byB0aGUgdXNlcnMgd2lsbCBiZSBjb3JyZWN0bHkgaW5mZXJyZWQuXG4gICAgICAgICAgICAgICAgICB0b29sUmVzdWx0czogc3RlcFRvb2xSZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgcmF3UmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICAuLi5zdGVwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgd2FybmluZ3MsXG4gICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICBzdGVwczogc3RlcFJlc3VsdHMsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgYWRkU3RlcFN0cmVhbSh7XG4gICAgICBzdHJlYW0sXG4gICAgICBzdGFydFRpbWVzdGFtcDogc3RhcnRUaW1lc3RhbXBNcyxcbiAgICAgIGRvU3RyZWFtU3BhbixcbiAgICAgIGN1cnJlbnRTdGVwOiAwLFxuICAgICAgcHJvbXB0TWVzc2FnZXMsXG4gICAgICB1c2FnZTogdm9pZCAwLFxuICAgICAgc3RlcFR5cGU6IFwiaW5pdGlhbFwiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gIFNwbGl0IG91dCBhIG5ldyBzdHJlYW0gZnJvbSB0aGUgb3JpZ2luYWwgc3RyZWFtLlxuICBUaGUgb3JpZ2luYWwgc3RyZWFtIGlzIHJlcGxhY2VkIHRvIGFsbG93IGZvciBmdXJ0aGVyIHNwbGl0dGluZyxcbiAgc2luY2Ugd2UgZG8gbm90IGtub3cgaG93IG1hbnkgdGltZXMgdGhlIHN0cmVhbSB3aWxsIGJlIHNwbGl0LlxuICBcbiAgTm90ZTogdGhpcyBsZWFkcyB0byBidWZmZXJpbmcgdGhlIHN0cmVhbSBjb250ZW50IG9uIHRoZSBzZXJ2ZXIuXG4gIEhvd2V2ZXIsIHRoZSBMTE0gcmVzdWx0cyBhcmUgZXhwZWN0ZWQgdG8gYmUgc21hbGwgZW5vdWdoIHRvIG5vdCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gIHRlZVN0cmVhbSgpIHtcbiAgICBjb25zdCBbc3RyZWFtMSwgc3RyZWFtMl0gPSB0aGlzLm9yaWdpbmFsU3RyZWFtLnRlZSgpO1xuICAgIHRoaXMub3JpZ2luYWxTdHJlYW0gPSBzdHJlYW0yO1xuICAgIHJldHVybiBzdHJlYW0xO1xuICB9XG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMudGVlU3RyZWFtKCksIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaHVuay50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGNodW5rLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBmdWxsU3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMudGVlU3RyZWFtKCksIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRvQUlTdHJlYW0oY2FsbGJhY2tzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy50b0RhdGFTdHJlYW1JbnRlcm5hbCh7IGNhbGxiYWNrcyB9KTtcbiAgfVxuICB0b0RhdGFTdHJlYW1JbnRlcm5hbCh7XG4gICAgY2FsbGJhY2tzID0ge30sXG4gICAgZ2V0RXJyb3JNZXNzYWdlOiBnZXRFcnJvck1lc3NhZ2U0ID0gKCkgPT4gXCJcIixcbiAgICAvLyBtYXNrIGVycm9yIG1lc3NhZ2VzIGZvciBzYWZldHkgYnkgZGVmYXVsdFxuICAgIHNlbmRVc2FnZSA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gICAgY29uc3QgY2FsbGJhY2tUcmFuc2Zvcm1lciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25TdGFydClcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25TdGFydCgpO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0RGVsdGEgPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IHRleHREZWx0YTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLm9uVG9rZW4pXG4gICAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Ub2tlbih0ZXh0RGVsdGEpO1xuICAgICAgICAgIGlmIChjYWxsYmFja3Mub25UZXh0KVxuICAgICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVGV4dCh0ZXh0RGVsdGEpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25Db21wbGV0aW9uKVxuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkNvbXBsZXRpb24oYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsKVxuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3RyZWFtUGFydHNUcmFuc2Zvcm1lciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsudHlwZTtcbiAgICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZm9ybWF0U3RyZWFtUGFydChcInRleHRcIiwgY2h1bmsudGV4dERlbHRhKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwidG9vbF9jYWxsX3N0cmVhbWluZ19zdGFydFwiLCB7XG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJ0b29sX2NhbGxfZGVsdGFcIiwge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgYXJnc1RleHREZWx0YTogY2h1bmsuYXJnc1RleHREZWx0YVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcInRvb2xfY2FsbFwiLCB7XG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXJnczogY2h1bmsuYXJnc1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwidG9vbF9yZXN1bHRcIiwge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBjaHVuay5yZXN1bHRcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcImVycm9yXCIsIGdldEVycm9yTWVzc2FnZTQoY2h1bmsuZXJyb3IpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwic3RlcC1maW5pc2hcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwiZmluaXNoX3N0ZXBcIiwge1xuICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgIHVzYWdlOiBzZW5kVXNhZ2UgPyB7XG4gICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IGNodW5rLnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IGNodW5rLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGlzQ29udGludWVkOiBjaHVuay5pc0NvbnRpbnVlZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcImZpbmlzaF9tZXNzYWdlXCIsIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICB1c2FnZTogc2VuZFVzYWdlID8ge1xuICAgICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBjaHVuay51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBjaHVuay51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgfSA6IHZvaWQgMFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBjaHVua1R5cGU7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY2h1bmsgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFN0cmVhbS5waXBlVGhyb3VnaChjYWxsYmFja1RyYW5zZm9ybWVyKS5waXBlVGhyb3VnaChzdHJlYW1QYXJ0c1RyYW5zZm9ybWVyKS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSk7XG4gIH1cbiAgcGlwZUFJU3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHJldHVybiB0aGlzLnBpcGVEYXRhU3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCk7XG4gIH1cbiAgcGlwZURhdGFTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaW5pdCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IFwiaW5pdFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmluaXQgOiB7XG4gICAgICBoZWFkZXJzOiBcImhlYWRlcnNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5oZWFkZXJzIDogdm9pZCAwLFxuICAgICAgc3RhdHVzOiBcInN0YXR1c1wiIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1cyA6IHZvaWQgMCxcbiAgICAgIHN0YXR1c1RleHQ6IFwic3RhdHVzVGV4dFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiB2b2lkIDBcbiAgICB9O1xuICAgIGNvbnN0IGRhdGEgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcImRhdGFcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5kYXRhIDogdm9pZCAwO1xuICAgIGNvbnN0IGdldEVycm9yTWVzc2FnZTQgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcImdldEVycm9yTWVzc2FnZVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmdldEVycm9yTWVzc2FnZSA6IHZvaWQgMDtcbiAgICBjb25zdCBzZW5kVXNhZ2UgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcInNlbmRVc2FnZVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlbmRVc2FnZSA6IHZvaWQgMDtcbiAgICB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICBzdGF0dXM6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogcHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIGRhdGFTdHJlYW1WZXJzaW9uOiBcInYxXCJcbiAgICAgIH0pLFxuICAgICAgc3RyZWFtOiB0aGlzLnRvRGF0YVN0cmVhbSh7IGRhdGEsIGdldEVycm9yTWVzc2FnZTogZ2V0RXJyb3JNZXNzYWdlNCwgc2VuZFVzYWdlIH0pXG4gICAgfSk7XG4gIH1cbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgc3RhdHVzOiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVPdXRnb2luZ0h0dHBIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KSxcbiAgICAgIHN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKVxuICAgIH0pO1xuICB9XG4gIHRvQUlTdHJlYW1SZXNwb25zZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudG9EYXRhU3RyZWFtUmVzcG9uc2Uob3B0aW9ucyk7XG4gIH1cbiAgdG9EYXRhU3RyZWFtKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnRvRGF0YVN0cmVhbUludGVybmFsKHtcbiAgICAgIGdldEVycm9yTWVzc2FnZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nZXRFcnJvck1lc3NhZ2UsXG4gICAgICBzZW5kVXNhZ2U6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2VuZFVzYWdlXG4gICAgfSk7XG4gICAgcmV0dXJuIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpID8gbWVyZ2VTdHJlYW1zKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YS5zdHJlYW0sIHN0cmVhbSkgOiBzdHJlYW07XG4gIH1cbiAgdG9EYXRhU3RyZWFtUmVzcG9uc2Uob3B0aW9ucykge1xuICAgIHZhciBfYTExO1xuICAgIGNvbnN0IGluaXQgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcImluaXRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5pbml0IDoge1xuICAgICAgaGVhZGVyczogXCJoZWFkZXJzXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuaGVhZGVycyA6IHZvaWQgMCxcbiAgICAgIHN0YXR1czogXCJzdGF0dXNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXMgOiB2b2lkIDAsXG4gICAgICBzdGF0dXNUZXh0OiBcInN0YXR1c1RleHRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogdm9pZCAwXG4gICAgfTtcbiAgICBjb25zdCBkYXRhID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJkYXRhXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZGF0YSA6IHZvaWQgMDtcbiAgICBjb25zdCBnZXRFcnJvck1lc3NhZ2U0ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJnZXRFcnJvck1lc3NhZ2VcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5nZXRFcnJvck1lc3NhZ2UgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2VuZFVzYWdlID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJzZW5kVXNhZ2VcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zZW5kVXNhZ2UgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICAgIHRoaXMudG9EYXRhU3RyZWFtKHsgZGF0YSwgZ2V0RXJyb3JNZXNzYWdlOiBnZXRFcnJvck1lc3NhZ2U0LCBzZW5kVXNhZ2UgfSksXG4gICAgICB7XG4gICAgICAgIHN0YXR1czogKF9hMTEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTEgOiAyMDAsXG4gICAgICAgIHN0YXR1c1RleHQ6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICAgIGRhdGFTdHJlYW1WZXJzaW9uOiBcInYxXCJcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHRvVGV4dFN0cmVhbVJlc3BvbnNlKGluaXQpIHtcbiAgICB2YXIgX2ExMTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksIHtcbiAgICAgIHN0YXR1czogKF9hMTEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTEgOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xudmFyIGV4cGVyaW1lbnRhbF9zdHJlYW1UZXh0ID0gc3RyZWFtVGV4dDtcblxuLy8gY29yZS9taWRkbGV3YXJlL3dyYXAtbGFuZ3VhZ2UtbW9kZWwudHNcbnZhciBleHBlcmltZW50YWxfd3JhcExhbmd1YWdlTW9kZWwgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZTogeyB0cmFuc2Zvcm1QYXJhbXMsIHdyYXBHZW5lcmF0ZSwgd3JhcFN0cmVhbSB9LFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIGRvVHJhbnNmb3JtKHtcbiAgICBwYXJhbXMsXG4gICAgdHlwZVxuICB9KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtcyA/IGF3YWl0IHRyYW5zZm9ybVBhcmFtcyh7IHBhcmFtcywgdHlwZSB9KSA6IHBhcmFtcztcbiAgfVxuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYxXCIsXG4gICAgcHJvdmlkZXI6IHByb3ZpZGVySWQgIT0gbnVsbCA/IHByb3ZpZGVySWQgOiBtb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbElkOiBtb2RlbElkICE9IG51bGwgPyBtb2RlbElkIDogbW9kZWwubW9kZWxJZCxcbiAgICBkZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGU6IG1vZGVsLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZSxcbiAgICBzdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0czogbW9kZWwuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyxcbiAgICBhc3luYyBkb0dlbmVyYXRlKHBhcmFtcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCBkb1RyYW5zZm9ybSh7IHBhcmFtcywgdHlwZTogXCJnZW5lcmF0ZVwiIH0pO1xuICAgICAgY29uc3QgZG9HZW5lcmF0ZSA9IGFzeW5jICgpID0+IG1vZGVsLmRvR2VuZXJhdGUodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBHZW5lcmF0ZSA/IHdyYXBHZW5lcmF0ZSh7IGRvR2VuZXJhdGUsIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsIG1vZGVsIH0pIDogZG9HZW5lcmF0ZSgpO1xuICAgIH0sXG4gICAgYXN5bmMgZG9TdHJlYW0ocGFyYW1zKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IGRvVHJhbnNmb3JtKHsgcGFyYW1zLCB0eXBlOiBcInN0cmVhbVwiIH0pO1xuICAgICAgY29uc3QgZG9TdHJlYW0gPSBhc3luYyAoKSA9PiBtb2RlbC5kb1N0cmVhbSh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICByZXR1cm4gd3JhcFN0cmVhbSA/IHdyYXBTdHJlYW0oeyBkb1N0cmVhbSwgcGFyYW1zOiB0cmFuc2Zvcm1lZFBhcmFtcywgbW9kZWwgfSkgOiBkb1N0cmVhbSgpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIGNvcmUvcHJvbXB0L2F0dGFjaG1lbnRzLXRvLXBhcnRzLnRzXG5mdW5jdGlvbiBhdHRhY2htZW50c1RvUGFydHMoYXR0YWNobWVudHMpIHtcbiAgdmFyIF9hMTEsIF9iLCBfYztcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgZm9yIChjb25zdCBhdHRhY2htZW50IG9mIGF0dGFjaG1lbnRzKSB7XG4gICAgbGV0IHVybDtcbiAgICB0cnkge1xuICAgICAgdXJsID0gbmV3IFVSTChhdHRhY2htZW50LnVybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVUkw6ICR7YXR0YWNobWVudC51cmx9YCk7XG4gICAgfVxuICAgIHN3aXRjaCAodXJsLnByb3RvY29sKSB7XG4gICAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICAgIGNhc2UgXCJodHRwczpcIjoge1xuICAgICAgICBpZiAoKF9hMTEgPSBhdHRhY2htZW50LmNvbnRlbnRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6IFwiaW1hZ2VcIiwgaW1hZ2U6IHVybCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWF0dGFjaG1lbnQuY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJZiB0aGUgYXR0YWNobWVudCBpcyBub3QgYW4gaW1hZ2UsIGl0IG11c3Qgc3BlY2lmeSBhIGNvbnRlbnQgdHlwZVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgZGF0YTogdXJsLFxuICAgICAgICAgICAgbWltZVR5cGU6IGF0dGFjaG1lbnQuY29udGVudFR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkYXRhOlwiOiB7XG4gICAgICAgIGxldCBoZWFkZXI7XG4gICAgICAgIGxldCBiYXNlNjRDb250ZW50O1xuICAgICAgICBsZXQgbWltZVR5cGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBhdHRhY2htZW50LnVybC5zcGxpdChcIixcIik7XG4gICAgICAgICAgbWltZVR5cGUgPSBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgZGF0YSBVUkw6ICR7YXR0YWNobWVudC51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdDogJHthdHRhY2htZW50LnVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9iID0gYXR0YWNobWVudC5jb250ZW50VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgIGltYWdlOiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoX2MgPSBhdHRhY2htZW50LmNvbnRlbnRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc3RhcnRzV2l0aChcInRleHQvXCIpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHRleHQ6IGNvbnZlcnRVaW50OEFycmF5VG9UZXh0KFxuICAgICAgICAgICAgICBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWF0dGFjaG1lbnQuY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJZiB0aGUgYXR0YWNobWVudCBpcyBub3QgYW4gaW1hZ2Ugb3IgdGV4dCwgaXQgbXVzdCBzcGVjaWZ5IGEgY29udGVudCB0eXBlXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICBkYXRhOiBiYXNlNjRDb250ZW50LFxuICAgICAgICAgICAgbWltZVR5cGU6IGF0dGFjaG1lbnQuY29udGVudFR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBVUkwgcHJvdG9jb2w6ICR7dXJsLnByb3RvY29sfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnZlcnQtdG8tY29yZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gY29udmVydFRvQ29yZU1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gIGNvbnN0IGNvcmVNZXNzYWdlcyA9IFtdO1xuICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICBjb25zdCB7IHJvbGUsIGNvbnRlbnQsIHRvb2xJbnZvY2F0aW9ucywgZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzIH0gPSBtZXNzYWdlO1xuICAgIHN3aXRjaCAocm9sZSkge1xuICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY29udGVudDogZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzID8gW1xuICAgICAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudCB9LFxuICAgICAgICAgICAgLi4uYXR0YWNobWVudHNUb1BhcnRzKGV4cGVyaW1lbnRhbF9hdHRhY2htZW50cylcbiAgICAgICAgICBdIDogY29udGVudFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgaWYgKHRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goeyByb2xlOiBcImFzc2lzdGFudFwiLCBjb250ZW50IH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGNvbnRlbnQgfSxcbiAgICAgICAgICAgIC4uLnRvb2xJbnZvY2F0aW9ucy5tYXAoKHsgdG9vbENhbGxJZCwgdG9vbE5hbWUsIGFyZ3MgfSkgPT4gKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICBjb250ZW50OiB0b29sSW52b2NhdGlvbnMubWFwKChUb29sSW52b2NhdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKCEoXCJyZXN1bHRcIiBpbiBUb29sSW52b2NhdGlvbikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE1lc3NhZ2VDb252ZXJzaW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsTWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlRvb2xJbnZvY2F0aW9uIG11c3QgaGF2ZSBhIHJlc3VsdDogXCIgKyBKU09OLnN0cmluZ2lmeShUb29sSW52b2NhdGlvbilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRvb2xDYWxsSWQsIHRvb2xOYW1lLCBhcmdzLCByZXN1bHQgfSA9IFRvb2xJbnZvY2F0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByb2xlO1xuICAgICAgICB0aHJvdyBuZXcgTWVzc2FnZUNvbnZlcnNpb25FcnJvcih7XG4gICAgICAgICAgb3JpZ2luYWxNZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgIG1lc3NhZ2U6IGBVbnN1cHBvcnRlZCByb2xlOiAke19leGhhdXN0aXZlQ2hlY2t9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvcmVNZXNzYWdlcztcbn1cblxuLy8gY29yZS9yZWdpc3RyeS9jdXN0b20tcHJvdmlkZXIudHNcbmltcG9ydCB7IE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyKHtcbiAgbGFuZ3VhZ2VNb2RlbHMsXG4gIHRleHRFbWJlZGRpbmdNb2RlbHMsXG4gIGZhbGxiYWNrUHJvdmlkZXJcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBsYW5ndWFnZU1vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmIChsYW5ndWFnZU1vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gbGFuZ3VhZ2VNb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUHJvdmlkZXIubGFuZ3VhZ2VNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJsYW5ndWFnZU1vZGVsXCIgfSk7XG4gICAgfSxcbiAgICB0ZXh0RW1iZWRkaW5nTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKHRleHRFbWJlZGRpbmdNb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIHRleHRFbWJlZGRpbmdNb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIHRleHRFbWJlZGRpbmdNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci50ZXh0RW1iZWRkaW5nTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwidGV4dEVtYmVkZGluZ01vZGVsXCIgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBjb3JlL3JlZ2lzdHJ5L25vLXN1Y2gtcHJvdmlkZXItZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjExLCBOb1N1Y2hNb2RlbEVycm9yIGFzIE5vU3VjaE1vZGVsRXJyb3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTAgPSBcIkFJX05vU3VjaFByb3ZpZGVyRXJyb3JcIjtcbnZhciBtYXJrZXIxMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTB9YDtcbnZhciBzeW1ib2wxMCA9IFN5bWJvbC5mb3IobWFya2VyMTApO1xudmFyIF9hMTA7XG52YXIgTm9TdWNoUHJvdmlkZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgTm9TdWNoTW9kZWxFcnJvcjMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbW9kZWxJZCxcbiAgICBtb2RlbFR5cGUsXG4gICAgcHJvdmlkZXJJZCxcbiAgICBhdmFpbGFibGVQcm92aWRlcnMsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoIHByb3ZpZGVyOiAke3Byb3ZpZGVySWR9IChhdmFpbGFibGUgcHJvdmlkZXJzOiAke2F2YWlsYWJsZVByb3ZpZGVycy5qb2luKCl9KWBcbiAgfSkge1xuICAgIHN1cGVyKHsgZXJyb3JOYW1lOiBuYW1lMTAsIG1vZGVsSWQsIG1vZGVsVHlwZSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTBdID0gdHJ1ZTtcbiAgICB0aGlzLnByb3ZpZGVySWQgPSBwcm92aWRlcklkO1xuICAgIHRoaXMuYXZhaWxhYmxlUHJvdmlkZXJzID0gYXZhaWxhYmxlUHJvdmlkZXJzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEwKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNOb1N1Y2hQcm92aWRlckVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTEwICYmIHR5cGVvZiBlcnJvci5wcm92aWRlcklkID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkoZXJyb3IuYXZhaWxhYmxlUHJvdmlkZXJzKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkLFxuICAgICAgbW9kZWxUeXBlOiB0aGlzLm1vZGVsVHlwZSxcbiAgICAgIHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZCxcbiAgICAgIGF2YWlsYWJsZVByb3ZpZGVyczogdGhpcy5hdmFpbGFibGVQcm92aWRlcnNcbiAgICB9O1xuICB9XG59O1xuX2ExMCA9IHN5bWJvbDEwO1xuXG4vLyBjb3JlL3JlZ2lzdHJ5L3Byb3ZpZGVyLXJlZ2lzdHJ5LnRzXG5pbXBvcnQgeyBOb1N1Y2hNb2RlbEVycm9yIGFzIE5vU3VjaE1vZGVsRXJyb3I0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGV4cGVyaW1lbnRhbF9jcmVhdGVQcm92aWRlclJlZ2lzdHJ5KHByb3ZpZGVycykge1xuICBjb25zdCByZWdpc3RyeSA9IG5ldyBEZWZhdWx0UHJvdmlkZXJSZWdpc3RyeSgpO1xuICBmb3IgKGNvbnN0IFtpZCwgcHJvdmlkZXJdIG9mIE9iamVjdC5lbnRyaWVzKHByb3ZpZGVycykpIHtcbiAgICByZWdpc3RyeS5yZWdpc3RlclByb3ZpZGVyKHsgaWQsIHByb3ZpZGVyIH0pO1xuICB9XG4gIHJldHVybiByZWdpc3RyeTtcbn1cbnZhciBleHBlcmltZW50YWxfY3JlYXRlTW9kZWxSZWdpc3RyeSA9IGV4cGVyaW1lbnRhbF9jcmVhdGVQcm92aWRlclJlZ2lzdHJ5O1xudmFyIERlZmF1bHRQcm92aWRlclJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByb3ZpZGVycyA9IHt9O1xuICB9XG4gIHJlZ2lzdGVyUHJvdmlkZXIoe1xuICAgIGlkLFxuICAgIHByb3ZpZGVyXG4gIH0pIHtcbiAgICB0aGlzLnByb3ZpZGVyc1tpZF0gPSBwcm92aWRlcjtcbiAgfVxuICBnZXRQcm92aWRlcihpZCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5wcm92aWRlcnNbaWRdO1xuICAgIGlmIChwcm92aWRlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoUHJvdmlkZXJFcnJvcih7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGU6IFwibGFuZ3VhZ2VNb2RlbFwiLFxuICAgICAgICBwcm92aWRlcklkOiBpZCxcbiAgICAgICAgYXZhaWxhYmxlUHJvdmlkZXJzOiBPYmplY3Qua2V5cyh0aGlzLnByb3ZpZGVycylcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdmlkZXI7XG4gIH1cbiAgc3BsaXRJZChpZCwgbW9kZWxUeXBlKSB7XG4gICAgY29uc3QgaW5kZXggPSBpZC5pbmRleE9mKFwiOlwiKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCAke21vZGVsVHlwZX0gaWQgZm9yIHJlZ2lzdHJ5OiAke2lkfSAobXVzdCBiZSBpbiB0aGUgZm9ybWF0IFwicHJvdmlkZXJJZDptb2RlbElkXCIpYFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbaWQuc2xpY2UoMCwgaW5kZXgpLCBpZC5zbGljZShpbmRleCArIDEpXTtcbiAgfVxuICBsYW5ndWFnZU1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTEsIF9iO1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJsYW5ndWFnZU1vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9iID0gKF9hMTEgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQpKS5sYW5ndWFnZU1vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTExLCBtb2RlbElkKTtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHsgbW9kZWxJZDogaWQsIG1vZGVsVHlwZTogXCJsYW5ndWFnZU1vZGVsXCIgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICB0ZXh0RW1iZWRkaW5nTW9kZWwoaWQpIHtcbiAgICB2YXIgX2ExMSwgX2IsIF9jO1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJ0ZXh0RW1iZWRkaW5nTW9kZWxcIik7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9jID0gKF9hMTEgPSBwcm92aWRlci50ZXh0RW1iZWRkaW5nTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmNhbGwocHJvdmlkZXIsIG1vZGVsSWQpKSAhPSBudWxsID8gX2MgOiBcInRleHRFbWJlZGRpbmdcIiBpbiBwcm92aWRlciA/IChfYiA9IHByb3ZpZGVyLnRleHRFbWJlZGRpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKHByb3ZpZGVyLCBtb2RlbElkKSA6IHZvaWQgMDtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHtcbiAgICAgICAgbW9kZWxJZDogaWQsXG4gICAgICAgIG1vZGVsVHlwZTogXCJ0ZXh0RW1iZWRkaW5nTW9kZWxcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGB0ZXh0RW1iZWRkaW5nTW9kZWxgIGluc3RlYWQuXG4gICAqL1xuICB0ZXh0RW1iZWRkaW5nKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dEVtYmVkZGluZ01vZGVsKGlkKTtcbiAgfVxufTtcblxuLy8gY29yZS90b29sL3Rvb2wudHNcbmZ1bmN0aW9uIHRvb2wodG9vbDIpIHtcbiAgcmV0dXJuIHRvb2wyO1xufVxuXG4vLyBjb3JlL3V0aWwvY29zaW5lLXNpbWlsYXJpdHkudHNcbmZ1bmN0aW9uIGNvc2luZVNpbWlsYXJpdHkodmVjdG9yMSwgdmVjdG9yMikge1xuICBpZiAodmVjdG9yMS5sZW5ndGggIT09IHZlY3RvcjIubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFZlY3RvcnMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCAodmVjdG9yMTogJHt2ZWN0b3IxLmxlbmd0aH0gZWxlbWVudHMsIHZlY3RvcjI6ICR7dmVjdG9yMi5sZW5ndGh9IGVsZW1lbnRzKWBcbiAgICApO1xuICB9XG4gIHJldHVybiBkb3RQcm9kdWN0KHZlY3RvcjEsIHZlY3RvcjIpIC8gKG1hZ25pdHVkZSh2ZWN0b3IxKSAqIG1hZ25pdHVkZSh2ZWN0b3IyKSk7XG59XG5mdW5jdGlvbiBkb3RQcm9kdWN0KHZlY3RvcjEsIHZlY3RvcjIpIHtcbiAgcmV0dXJuIHZlY3RvcjEucmVkdWNlKFxuICAgIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4KSA9PiBhY2N1bXVsYXRvciArIHZhbHVlICogdmVjdG9yMltpbmRleF0sXG4gICAgMFxuICApO1xufVxuZnVuY3Rpb24gbWFnbml0dWRlKHZlY3Rvcikge1xuICByZXR1cm4gTWF0aC5zcXJ0KGRvdFByb2R1Y3QodmVjdG9yLCB2ZWN0b3IpKTtcbn1cblxuLy8gc3RyZWFtcy9haS1zdHJlYW0udHNcbmltcG9ydCB7XG4gIGNyZWF0ZVBhcnNlclxufSBmcm9tIFwiZXZlbnRzb3VyY2UtcGFyc2VyXCI7XG5mdW5jdGlvbiBjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKGN1c3RvbVBhcnNlcikge1xuICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBsZXQgZXZlbnRTb3VyY2VQYXJzZXI7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlciA9IGNyZWF0ZVBhcnNlcihcbiAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKFwiZGF0YVwiIGluIGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFwiZXZlbnRcIiAmJiBldmVudC5kYXRhID09PSBcIltET05FXVwiIHx8IC8vIFJlcGxpY2F0ZSBkb2Vzbid0IHNlbmQgW0RPTkVdIGJ1dCBkb2VzIHNlbmQgYSAnZG9uZScgZXZlbnRcbiAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vcmVwbGljYXRlLmNvbS9kb2NzL3N0cmVhbWluZ1xuICAgICAgICAgIGV2ZW50LmV2ZW50ID09PSBcImRvbmVcIikge1xuICAgICAgICAgICAgY29udHJvbGxlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZGF0YVwiIGluIGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRNZXNzYWdlID0gY3VzdG9tUGFyc2VyID8gY3VzdG9tUGFyc2VyKGV2ZW50LmRhdGEsIHtcbiAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LmV2ZW50XG4gICAgICAgICAgICB9KSA6IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZSlcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnNlZE1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybShjaHVuaykge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIuZmVlZCh0ZXh0RGVjb2Rlci5kZWNvZGUoY2h1bmspKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2IpIHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IGNiIHx8IHt9O1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgfSxcbiAgICBhc3luYyB0cmFuc2Zvcm0obWVzc2FnZSwgY29udHJvbGxlcikge1xuICAgICAgY29uc3QgY29udGVudCA9IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2UuY29udGVudDtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCkpO1xuICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IGNvbnRlbnQ7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVG9rZW4pXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRva2VuKGNvbnRlbnQpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblRleHQgJiYgdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVGV4dChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIGZsdXNoKCkge1xuICAgICAgY29uc3QgaXNPcGVuQUlDYWxsYmFja3MgPSBpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyhjYWxsYmFja3MpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5vbkNvbXBsZXRpb24pIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uQ29tcGxldGlvbihhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmICFpc09wZW5BSUNhbGxiYWNrcykge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyhjYWxsYmFja3MpIHtcbiAgcmV0dXJuIFwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsXCIgaW4gY2FsbGJhY2tzO1xufVxuZnVuY3Rpb24gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKSB7XG4gIGxldCBpc1N0cmVhbVN0YXJ0ID0gdHJ1ZTtcbiAgcmV0dXJuICh0ZXh0KSA9PiB7XG4gICAgaWYgKGlzU3RyZWFtU3RhcnQpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRyaW1TdGFydCgpO1xuICAgICAgaWYgKHRleHQpXG4gICAgICAgIGlzU3RyZWFtU3RhcnQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59XG5mdW5jdGlvbiBBSVN0cmVhbShyZXNwb25zZSwgY3VzdG9tUGFyc2VyLCBjYWxsYmFja3MpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGlmIChyZXNwb25zZS5ib2R5KSB7XG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKGBSZXNwb25zZSBlcnJvcjogJHtlcnJvclRleHR9YCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoXCJSZXNwb25zZSBlcnJvcjogTm8gcmVzcG9uc2UgYm9keVwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXNwb25zZUJvZHlTdHJlYW0gPSByZXNwb25zZS5ib2R5IHx8IGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKTtcbiAgcmV0dXJuIHJlc3BvbnNlQm9keVN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKGN1c3RvbVBhcnNlcikpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpIHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKGl0ZXJhYmxlKSB7XG4gIGxldCBpdCA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICAgIGlmIChkb25lKVxuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICBlbHNlXG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICB2YXIgX2ExMTtcbiAgICAgIGF3YWl0ICgoX2ExMSA9IGl0LnJldHVybikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY2FsbChpdCwgcmVhc29uKSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9zdHJlYW0tZGF0YS50c1xuaW1wb3J0IHsgZm9ybWF0U3RyZWFtUGFydCBhcyBmb3JtYXRTdHJlYW1QYXJ0MiB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIHV0aWwvY29uc3RhbnRzLnRzXG52YXIgSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TID0gMTUgKiAxZTM7XG5cbi8vIHN0cmVhbXMvc3RyZWFtLWRhdGEudHNcbnZhciBTdHJlYW1EYXRhMiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbnVsbDtcbiAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy53YXJuaW5nVGltZW91dCA9IG51bGw7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGFzeW5jIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIHNlbGYuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgc2VsZi53YXJuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcIlRoZSBkYXRhIHN0cmVhbSBpcyBoYW5naW5nLiBEaWQgeW91IGZvcmdldCB0byBjbG9zZSBpdCB3aXRoIGBkYXRhLmNsb3NlKClgP1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sIEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwdWxsOiAoY29udHJvbGxlcikgPT4ge1xuICAgICAgfSxcbiAgICAgIGNhbmNlbDogKHJlYXNvbikgPT4ge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMud2FybmluZ1RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhcm5pbmdUaW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgYXBwZW5kKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC5cIik7XG4gICAgfVxuICAgIHRoaXMuY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgdGhpcy5lbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MihcImRhdGFcIiwgW3ZhbHVlXSkpXG4gICAgKTtcbiAgfVxuICBhcHBlbmRNZXNzYWdlQW5ub3RhdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDIoXCJtZXNzYWdlX2Fubm90YXRpb25zXCIsIFt2YWx1ZV0pKVxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDIoXCJ0ZXh0XCIsIG1lc3NhZ2UpKSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBleHBlcmltZW50YWxfU3RyZWFtRGF0YSA9IGNsYXNzIGV4dGVuZHMgU3RyZWFtRGF0YTIge1xufTtcblxuLy8gc3RyZWFtcy9hbnRocm9waWMtc3RyZWFtLnRzXG5mdW5jdGlvbiBwYXJzZUFudGhyb3BpY1N0cmVhbSgpIHtcbiAgbGV0IHByZXZpb3VzID0gXCJcIjtcbiAgcmV0dXJuIChkYXRhKSA9PiB7XG4gICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgaWYgKFwiZXJyb3JcIiBpbiBqc29uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7anNvbi5lcnJvci50eXBlfTogJHtqc29uLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIGlmICghKFwiY29tcGxldGlvblwiIGluIGpzb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSBqc29uLmNvbXBsZXRpb247XG4gICAgaWYgKCFwcmV2aW91cyB8fCB0ZXh0Lmxlbmd0aCA+IHByZXZpb3VzLmxlbmd0aCAmJiB0ZXh0LnN0YXJ0c1dpdGgocHJldmlvdXMpKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IHRleHQuc2xpY2UocHJldmlvdXMubGVuZ3RoKTtcbiAgICAgIHByZXZpb3VzID0gdGV4dDtcbiAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZShzdHJlYW0pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBpZiAoXCJjb21wbGV0aW9uXCIgaW4gY2h1bmspIHtcbiAgICAgIGNvbnN0IHRleHQgPSBjaHVuay5jb21wbGV0aW9uO1xuICAgICAgaWYgKHRleHQpXG4gICAgICAgIHlpZWxkIHRleHQ7XG4gICAgfSBlbHNlIGlmIChcImRlbHRhXCIgaW4gY2h1bmspIHtcbiAgICAgIGNvbnN0IHsgZGVsdGEgfSA9IGNodW5rO1xuICAgICAgaWYgKFwidGV4dFwiIGluIGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBkZWx0YS50ZXh0O1xuICAgICAgICBpZiAodGV4dClcbiAgICAgICAgICB5aWVsZCB0ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gQW50aHJvcGljU3RyZWFtKHJlcywgY2IpIHtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlcykge1xuICAgIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUocmVzKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2IpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFJU3RyZWFtKHJlcywgcGFyc2VBbnRocm9waWNTdHJlYW0oKSwgY2IpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKClcbiAgICApO1xuICB9XG59XG5cbi8vIHN0cmVhbXMvYXNzaXN0YW50LXJlc3BvbnNlLnRzXG5pbXBvcnQge1xuICBmb3JtYXRTdHJlYW1QYXJ0IGFzIGZvcm1hdFN0cmVhbVBhcnQzXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBBc3Npc3RhbnRSZXNwb25zZSh7IHRocmVhZElkLCBtZXNzYWdlSWQgfSwgcHJvY2VzczIpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2ExMTtcbiAgICAgIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICBjb25zdCBzZW5kTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDMoXCJhc3Npc3RhbnRfbWVzc2FnZVwiLCBtZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZW5kRGF0YU1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQzKFwiZGF0YV9tZXNzYWdlXCIsIG1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbmRFcnJvciA9IChlcnJvck1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MyhcImVycm9yXCIsIGVycm9yTWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZm9yd2FyZFN0cmVhbSA9IGFzeW5jIChzdHJlYW0yKSA9PiB7XG4gICAgICAgIHZhciBfYTEyLCBfYjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBzdHJlYW0yKSB7XG4gICAgICAgICAgc3dpdGNoICh2YWx1ZS5ldmVudCkge1xuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5tZXNzYWdlLmNyZWF0ZWRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydDMoXCJhc3Npc3RhbnRfbWVzc2FnZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5kYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogeyB2YWx1ZTogXCJcIiB9IH1dXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLm1lc3NhZ2UuZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gKF9hMTIgPSB2YWx1ZS5kYXRhLmRlbHRhLmNvbnRlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTEyWzBdO1xuICAgICAgICAgICAgICBpZiAoKGNvbnRlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRlbnQudHlwZSkgPT09IFwidGV4dFwiICYmICgoX2IgPSBjb250ZW50LnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfYi52YWx1ZSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydDMoXCJ0ZXh0XCIsIGNvbnRlbnQudGV4dC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5ydW4uY29tcGxldGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLnJ1bi5yZXF1aXJlc19hY3Rpb25cIjoge1xuICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5kYXRhO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0MyhcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiwge1xuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBtZXNzYWdlSWRcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvY2VzczIoe1xuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICBzZW5kTWVzc2FnZSxcbiAgICAgICAgICBzZW5kRGF0YU1lc3NhZ2UsXG4gICAgICAgICAgZm9yd2FyZFN0cmVhbVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHNlbmRFcnJvcigoX2ExMSA9IGVycm9yLm1lc3NhZ2UpICE9IG51bGwgPyBfYTExIDogYCR7ZXJyb3J9YCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICB9LFxuICAgIGNhbmNlbCgpIHtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHN0cmVhbSwge1xuICAgIHN0YXR1czogMjAwLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9KTtcbn1cbnZhciBleHBlcmltZW50YWxfQXNzaXN0YW50UmVzcG9uc2UgPSBBc3Npc3RhbnRSZXNwb25zZTtcblxuLy8gc3RyZWFtcy9hd3MtYmVkcm9jay1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uKiBhc0RlbHRhSXRlcmFibGUocmVzcG9uc2UsIGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmspIHtcbiAgdmFyIF9hMTEsIF9iO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgKF9hMTEgPSByZXNwb25zZS5ib2R5KSAhPSBudWxsID8gX2ExMSA6IFtdKSB7XG4gICAgY29uc3QgYnl0ZXMgPSAoX2IgPSBjaHVuay5jaHVuaykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmJ5dGVzO1xuICAgIGlmIChieXRlcyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBjaHVua1RleHQgPSBkZWNvZGVyLmRlY29kZShieXRlcyk7XG4gICAgICBjb25zdCBjaHVua0pTT04gPSBKU09OLnBhcnNlKGNodW5rVGV4dCk7XG4gICAgICBjb25zdCBkZWx0YSA9IGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmsoY2h1bmtKU09OKTtcbiAgICAgIGlmIChkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgIHlpZWxkIGRlbHRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0FudGhyb3BpY01lc3NhZ2VzU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiB7XG4gICAgdmFyIF9hMTE7XG4gICAgcmV0dXJuIChfYTExID0gY2h1bmsuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLnRleHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0FudGhyb3BpY1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIChjaHVuaykgPT4gY2h1bmsuY29tcGxldGlvbik7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrQ29oZXJlU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiBjaHVuayA9PSBudWxsID8gdm9pZCAwIDogY2h1bmsudGV4dCk7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrTGxhbWEyU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiBjaHVuay5nZW5lcmF0aW9uKTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgZXh0cmFjdFRleHREZWx0YUZyb21DaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShcbiAgICBhc0RlbHRhSXRlcmFibGUocmVzcG9uc2UsIGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmspXG4gICkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL2NvaGVyZS1zdHJlYW0udHNcbnZhciB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0xpbmVzKGxpbmVzLCBjb250cm9sbGVyKSB7XG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGNvbnN0IHsgdGV4dCwgaXNfZmluaXNoZWQgfSA9IEpTT04ucGFyc2UobGluZSk7XG4gICAgaWYgKCFpc19maW5pc2hlZCkge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHQpO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVhZEFuZFByb2Nlc3NMaW5lcyhyZWFkZXIsIGNvbnRyb2xsZXIpIHtcbiAgbGV0IHNlZ21lbnQgPSBcIlwiO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgdmFsdWU6IGNodW5rLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2VnbWVudCArPSB1dGY4RGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIGNvbnN0IGxpbmVzQXJyYXkgPSBzZWdtZW50LnNwbGl0KC9cXHJcXG58XFxufFxcci9nKTtcbiAgICBzZWdtZW50ID0gbGluZXNBcnJheS5wb3AoKSB8fCBcIlwiO1xuICAgIGF3YWl0IHByb2Nlc3NMaW5lcyhsaW5lc0FycmF5LCBjb250cm9sbGVyKTtcbiAgfVxuICBpZiAoc2VnbWVudCkge1xuICAgIGNvbnN0IGxpbmVzQXJyYXkgPSBbc2VnbWVudF07XG4gICAgYXdhaXQgcHJvY2Vzc0xpbmVzKGxpbmVzQXJyYXksIGNvbnRyb2xsZXIpO1xuICB9XG4gIGNvbnRyb2xsZXIuY2xvc2UoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlcjIocmVzKSB7XG4gIHZhciBfYTExO1xuICBjb25zdCByZWFkZXIgPSAoX2ExMSA9IHJlcy5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5nZXRSZWFkZXIoKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCByZWFkQW5kUHJvY2Vzc0xpbmVzKHJlYWRlciwgY29udHJvbGxlcik7XG4gICAgfVxuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlMihzdHJlYW0pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBpZiAoY2h1bmsuZXZlbnRUeXBlID09PSBcInRleHQtZ2VuZXJhdGlvblwiKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2h1bmsudGV4dDtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICB5aWVsZCB0ZXh0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gQ29oZXJlU3RyZWFtKHJlYWRlciwgY2FsbGJhY2tzKSB7XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZWFkZXIpIHtcbiAgICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlMihyZWFkZXIpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhcnNlcjIocmVhZGVyKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH1cbn1cblxuLy8gc3RyZWFtcy9nb29nbGUtZ2VuZXJhdGl2ZS1haS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlMyhyZXNwb25zZSkge1xuICB2YXIgX2ExMSwgX2IsIF9jO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlc3BvbnNlLnN0cmVhbSkge1xuICAgIGNvbnN0IHBhcnRzID0gKF9jID0gKF9iID0gKF9hMTEgPSBjaHVuay5jYW5kaWRhdGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5wYXJ0cztcbiAgICBpZiAocGFydHMgPT09IHZvaWQgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UGFydCA9IHBhcnRzWzBdO1xuICAgIGlmICh0eXBlb2YgZmlyc3RQYXJ0LnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHlpZWxkIGZpcnN0UGFydC50ZXh0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gR29vZ2xlR2VuZXJhdGl2ZUFJU3RyZWFtKHJlc3BvbnNlLCBjYikge1xuICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlMyhyZXNwb25zZSkpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNiKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL2h1Z2dpbmdmYWNlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlUGFyc2VyMyhyZXMpIHtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfYTExLCBfYjtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHJlcy5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHQgPSB0cmltU3RhcnRPZlN0cmVhbSgoX2IgPSAoX2ExMSA9IHZhbHVlLnRva2VuKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS50ZXh0KSAhPSBudWxsID8gX2IgOiBcIlwiKTtcbiAgICAgIGlmICghdGV4dClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHZhbHVlLmdlbmVyYXRlZF90ZXh0ICE9IG51bGwgJiYgdmFsdWUuZ2VuZXJhdGVkX3RleHQubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGV4dCA9PT0gXCI8L3M+XCIgfHwgdGV4dCA9PT0gXCI8fGVuZG9mdGV4dHw+XCIgfHwgdGV4dCA9PT0gXCI8fGVuZHw+XCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBIdWdnaW5nRmFjZVN0cmVhbShyZXMsIGNhbGxiYWNrcykge1xuICByZXR1cm4gY3JlYXRlUGFyc2VyMyhyZXMpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cblxuLy8gc3RyZWFtcy9pbmtlZXAtc3RyZWFtLnRzXG5mdW5jdGlvbiBJbmtlZXBTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgaWYgKCFyZXMuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIGJvZHkgaXMgbnVsbFwiKTtcbiAgfVxuICBsZXQgY2hhdF9zZXNzaW9uX2lkID0gXCJcIjtcbiAgbGV0IHJlY29yZHNfY2l0ZWQ7XG4gIGNvbnN0IGlua2VlcEV2ZW50UGFyc2VyID0gKGRhdGEsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgX2ExMSwgX2I7XG4gICAgY29uc3QgeyBldmVudCB9ID0gb3B0aW9ucztcbiAgICBpZiAoZXZlbnQgPT09IFwicmVjb3Jkc19jaXRlZFwiKSB7XG4gICAgICByZWNvcmRzX2NpdGVkID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIChfYTExID0gY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25SZWNvcmRzQ2l0ZWQpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmNhbGwoY2FsbGJhY2tzLCByZWNvcmRzX2NpdGVkKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50ID09PSBcIm1lc3NhZ2VfY2h1bmtcIikge1xuICAgICAgY29uc3QgaW5rZWVwTWVzc2FnZUNodW5rID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIGNoYXRfc2Vzc2lvbl9pZCA9IChfYiA9IGlua2VlcE1lc3NhZ2VDaHVuay5jaGF0X3Nlc3Npb25faWQpICE9IG51bGwgPyBfYiA6IGNoYXRfc2Vzc2lvbl9pZDtcbiAgICAgIHJldHVybiBpbmtlZXBNZXNzYWdlQ2h1bmsuY29udGVudF9jaHVuaztcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9O1xuICBsZXQgeyBvblJlY29yZHNDaXRlZCwgLi4ucGFzc1Rocm91Z2hDYWxsYmFja3MgfSA9IGNhbGxiYWNrcyB8fCB7fTtcbiAgcGFzc1Rocm91Z2hDYWxsYmFja3MgPSB7XG4gICAgLi4ucGFzc1Rocm91Z2hDYWxsYmFja3MsXG4gICAgb25GaW5hbDogKGNvbXBsZXRpb24pID0+IHtcbiAgICAgIHZhciBfYTExO1xuICAgICAgY29uc3QgaW5rZWVwT25GaW5hbE1ldGFkYXRhID0ge1xuICAgICAgICBjaGF0X3Nlc3Npb25faWQsXG4gICAgICAgIHJlY29yZHNfY2l0ZWRcbiAgICAgIH07XG4gICAgICAoX2ExMSA9IGNhbGxiYWNrcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uRmluYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmNhbGwoY2FsbGJhY2tzLCBjb21wbGV0aW9uLCBpbmtlZXBPbkZpbmFsTWV0YWRhdGEpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEFJU3RyZWFtKHJlcywgaW5rZWVwRXZlbnRQYXJzZXIsIHBhc3NUaHJvdWdoQ2FsbGJhY2tzKS5waXBlVGhyb3VnaChcbiAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKVxuICApO1xufVxuXG4vLyBzdHJlYW1zL2xhbmdjaGFpbi1hZGFwdGVyLnRzXG52YXIgbGFuZ2NoYWluX2FkYXB0ZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobGFuZ2NoYWluX2FkYXB0ZXJfZXhwb3J0cywge1xuICB0b0FJU3RyZWFtOiAoKSA9PiB0b0FJU3RyZWFtLFxuICB0b0RhdGFTdHJlYW06ICgpID0+IHRvRGF0YVN0cmVhbSxcbiAgdG9EYXRhU3RyZWFtUmVzcG9uc2U6ICgpID0+IHRvRGF0YVN0cmVhbVJlc3BvbnNlXG59KTtcbmZ1bmN0aW9uIHRvQUlTdHJlYW0oc3RyZWFtLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIHRvRGF0YVN0cmVhbShzdHJlYW0sIGNhbGxiYWNrcyk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW0oc3RyZWFtLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKHZhbHVlLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIHZhciBfYTExO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiZXZlbnRcIiBpbiB2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5ldmVudCA9PT0gXCJvbl9jaGF0X21vZGVsX3N0cmVhbVwiKSB7XG4gICAgICAgICAgICBmb3J3YXJkQUlNZXNzYWdlQ2h1bmsoXG4gICAgICAgICAgICAgIChfYTExID0gdmFsdWUuZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY2h1bmssXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkQUlNZXNzYWdlQ2h1bmsodmFsdWUsIGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0pXG4gICkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuZnVuY3Rpb24gdG9EYXRhU3RyZWFtUmVzcG9uc2Uoc3RyZWFtLCBvcHRpb25zKSB7XG4gIHZhciBfYTExO1xuICBjb25zdCBkYXRhU3RyZWFtID0gdG9EYXRhU3RyZWFtKHN0cmVhbSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jYWxsYmFja3MpO1xuICBjb25zdCBkYXRhID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhO1xuICBjb25zdCBpbml0ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5pbml0O1xuICBjb25zdCByZXNwb25zZVN0cmVhbSA9IGRhdGEgPyBtZXJnZVN0cmVhbXMoZGF0YS5zdHJlYW0sIGRhdGFTdHJlYW0pIDogZGF0YVN0cmVhbTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXNwb25zZVN0cmVhbSwge1xuICAgIHN0YXR1czogKF9hMTEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTEgOiAyMDAsXG4gICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgZGF0YVN0cmVhbVZlcnNpb246IFwidjFcIlxuICAgIH0pXG4gIH0pO1xufVxuZnVuY3Rpb24gZm9yd2FyZEFJTWVzc2FnZUNodW5rKGNodW5rLCBjb250cm9sbGVyKSB7XG4gIGlmICh0eXBlb2YgY2h1bmsuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5jb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250ZW50ID0gY2h1bmsuY29udGVudDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29udGVudCkge1xuICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGl0ZW0udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHN0cmVhbXMvbGxhbWFpbmRleC1hZGFwdGVyLnRzXG52YXIgbGxhbWFpbmRleF9hZGFwdGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGxsYW1haW5kZXhfYWRhcHRlcl9leHBvcnRzLCB7XG4gIHRvRGF0YVN0cmVhbTogKCkgPT4gdG9EYXRhU3RyZWFtMixcbiAgdG9EYXRhU3RyZWFtUmVzcG9uc2U6ICgpID0+IHRvRGF0YVN0cmVhbVJlc3BvbnNlMlxufSk7XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW0yKHN0cmVhbSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiB0b1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuZnVuY3Rpb24gdG9EYXRhU3RyZWFtUmVzcG9uc2UyKHN0cmVhbSwgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYTExO1xuICBjb25zdCB7IGluaXQsIGRhdGEsIGNhbGxiYWNrcyB9ID0gb3B0aW9ucztcbiAgY29uc3QgZGF0YVN0cmVhbSA9IHRvRGF0YVN0cmVhbTIoc3RyZWFtLCBjYWxsYmFja3MpO1xuICBjb25zdCByZXNwb25zZVN0cmVhbSA9IGRhdGEgPyBtZXJnZVN0cmVhbXMoZGF0YS5zdHJlYW0sIGRhdGFTdHJlYW0pIDogZGF0YVN0cmVhbTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXNwb25zZVN0cmVhbSwge1xuICAgIHN0YXR1czogKF9hMTEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTEgOiAyMDAsXG4gICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgZGF0YVN0cmVhbVZlcnNpb246IFwidjFcIlxuICAgIH0pXG4gIH0pO1xufVxuZnVuY3Rpb24gdG9SZWFkYWJsZVN0cmVhbShyZXMpIHtcbiAgY29uc3QgaXQgPSByZXNbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIGNvbnN0IHRyaW1TdGFydE9mU3RyZWFtID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2ExMTtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKChfYTExID0gdmFsdWUuZGVsdGEpICE9IG51bGwgPyBfYTExIDogXCJcIik7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9sYW5nY2hhaW4tc3RyZWFtLnRzXG5mdW5jdGlvbiBMYW5nQ2hhaW5TdHJlYW0oY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKTtcbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICBjb25zdCBydW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgaGFuZGxlRXJyb3IgPSBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICBydW5zLmRlbGV0ZShydW5JZCk7XG4gICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgIGF3YWl0IHdyaXRlci5hYm9ydChlKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlU3RhcnQgPSBhc3luYyAocnVuSWQpID0+IHtcbiAgICBydW5zLmFkZChydW5JZCk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZUVuZCA9IGFzeW5jIChydW5JZCkgPT4ge1xuICAgIHJ1bnMuZGVsZXRlKHJ1bklkKTtcbiAgICBpZiAocnVucy5zaXplID09PSAwKSB7XG4gICAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgICBhd2FpdCB3cml0ZXIuY2xvc2UoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiBzdHJlYW0ucmVhZGFibGUucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpLFxuICAgIHdyaXRlcixcbiAgICBoYW5kbGVyczoge1xuICAgICAgaGFuZGxlTExNTmV3VG9rZW46IGFzeW5jICh0b2tlbikgPT4ge1xuICAgICAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgICAgIGF3YWl0IHdyaXRlci53cml0ZSh0b2tlbik7XG4gICAgICB9LFxuICAgICAgaGFuZGxlTExNU3RhcnQ6IGFzeW5jIChfbGxtLCBfcHJvbXB0cywgcnVuSWQpID0+IHtcbiAgICAgICAgaGFuZGxlU3RhcnQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTUVuZDogYXN5bmMgKF9vdXRwdXQsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVuZChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlTExNRXJyb3I6IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlLCBydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2hhaW5TdGFydDogYXN5bmMgKF9jaGFpbiwgX2lucHV0cywgcnVuSWQpID0+IHtcbiAgICAgICAgaGFuZGxlU3RhcnQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluRW5kOiBhc3luYyAoX291dHB1dHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVuZChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2hhaW5FcnJvcjogYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUsIHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVUb29sU3RhcnQ6IGFzeW5jIChfdG9vbCwgX2lucHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBoYW5kbGVTdGFydChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbEVuZDogYXN5bmMgKF9vdXRwdXQsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVuZChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbEVycm9yOiBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSwgcnVuSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3RyZWFtcy9taXN0cmFsLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGU0KHN0cmVhbSkge1xuICB2YXIgX2ExMSwgX2I7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgY29uc3QgY29udGVudCA9IChfYiA9IChfYTExID0gY2h1bmsuY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb250ZW50O1xuICAgIGlmIChjb250ZW50ID09PSB2b2lkIDAgfHwgY29udGVudCA9PT0gXCJcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHlpZWxkIGNvbnRlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIE1pc3RyYWxTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICBjb25zdCBzdHJlYW0gPSByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGU0KHJlc3BvbnNlKSk7XG4gIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL29wZW5haS1zdHJlYW0udHNcbmltcG9ydCB7XG4gIGNyZWF0ZUNodW5rRGVjb2RlcixcbiAgZm9ybWF0U3RyZWFtUGFydCBhcyBmb3JtYXRTdHJlYW1QYXJ0NFxufSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuZnVuY3Rpb24gcGFyc2VPcGVuQUlTdHJlYW0oKSB7XG4gIGNvbnN0IGV4dHJhY3QgPSBjaHVua1RvVGV4dCgpO1xuICByZXR1cm4gKGRhdGEpID0+IGV4dHJhY3QoSlNPTi5wYXJzZShkYXRhKSk7XG59XG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZTUoc3RyZWFtKSB7XG4gIGNvbnN0IGV4dHJhY3QgPSBjaHVua1RvVGV4dCgpO1xuICBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBpZiAoXCJwcm9tcHRGaWx0ZXJSZXN1bHRzXCIgaW4gY2h1bmspIHtcbiAgICAgIGNodW5rID0ge1xuICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgIGNyZWF0ZWQ6IGNodW5rLmNyZWF0ZWQuZ2V0RGF0ZSgpLFxuICAgICAgICBvYmplY3Q6IGNodW5rLm9iamVjdCxcbiAgICAgICAgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIG1vZGVsOiBjaHVuay5tb2RlbCxcbiAgICAgICAgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIGNob2ljZXM6IGNodW5rLmNob2ljZXMubWFwKChjaG9pY2UpID0+IHtcbiAgICAgICAgICB2YXIgX2ExMSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsdGE6IHtcbiAgICAgICAgICAgICAgY29udGVudDogKF9hMTEgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmNvbnRlbnQsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IChfYiA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICAgICAgcm9sZTogKF9jID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2Mucm9sZSxcbiAgICAgICAgICAgICAgdG9vbF9jYWxsczogKChfZSA9IChfZCA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmxlbmd0aCkgPyAoX2cgPSAoX2YgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfZi50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZy5tYXAoKHRvb2xDYWxsLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb246IHRvb2xDYWxsLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGU6IHRvb2xDYWxsLnR5cGVcbiAgICAgICAgICAgICAgfSkpIDogdm9pZCAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluaXNoX3JlYXNvbjogY2hvaWNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIGluZGV4OiBjaG9pY2UuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IGV4dHJhY3QoY2h1bmspO1xuICAgIGlmICh0ZXh0KVxuICAgICAgeWllbGQgdGV4dDtcbiAgfVxufVxuZnVuY3Rpb24gY2h1bmtUb1RleHQoKSB7XG4gIGNvbnN0IHRyaW1TdGFydE9mU3RyZWFtID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbjtcbiAgcmV0dXJuIChqc29uKSA9PiB7XG4gICAgdmFyIF9hMTEsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rLCBfbCwgX20sIF9uLCBfbywgX3AsIF9xLCBfcjtcbiAgICBpZiAoaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IChfYTExID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5kZWx0YTtcbiAgICAgIGlmICgoX2IgPSBkZWx0YS5mdW5jdGlvbl9jYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2IubmFtZSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogYHtcImZ1bmN0aW9uX2NhbGxcIjoge1wibmFtZVwiOiBcIiR7ZGVsdGEuZnVuY3Rpb25fY2FsbC5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKF9lID0gKF9kID0gKF9jID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2QuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZS5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gZGVsdGEudG9vbF9jYWxsc1swXTtcbiAgICAgICAgaWYgKHRvb2xDYWxsLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBge1widG9vbF9jYWxsc1wiOlsge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIkeyhfZiA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2YubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGBcIn19LCB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7KF9nID0gdG9vbENhbGwuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZy5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChfaCA9IGRlbHRhLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfaC5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoKF9pID0gZGVsdGEuZnVuY3Rpb25fY2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pLmFyZ3VtZW50cylcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKF9sID0gKF9rID0gKF9qID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9qWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2suZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfbC5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoKF9vID0gKF9uID0gKF9tID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9tWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX24uZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfby5hcmd1bWVudHMpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoKChfcCA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wLmZpbmlzaF9yZWFzb24pID09PSBcImZ1bmN0aW9uX2NhbGxcIiB8fCAoKF9xID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3EuZmluaXNoX3JlYXNvbikgPT09IFwic3RvcFwiKSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19J1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiYgKChfciA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yLmZpbmlzaF9yZWFzb24pID09PSBcInRvb2xfY2FsbHNcIikge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19XX0nXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSB0cmltU3RhcnRPZlN0cmVhbShcbiAgICAgIGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSAmJiBqc29uLmNob2ljZXNbMF0uZGVsdGEuY29udGVudCA/IGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50IDogaXNDb21wbGV0aW9uKGpzb24pID8ganNvbi5jaG9pY2VzWzBdLnRleHQgOiBcIlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbiAgZnVuY3Rpb24gY2xlYW51cEFyZ3VtZW50cyhhcmd1bWVudENodW5rKSB7XG4gICAgbGV0IGVzY2FwZWRQYXJ0aWFsSnNvbiA9IGFyZ3VtZW50Q2h1bmsucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2UoL1xcLy9nLCBcIlxcXFwvXCIpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKS5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKS5yZXBsYWNlKC9cXGYvZywgXCJcXFxcZlwiKTtcbiAgICByZXR1cm4gYCR7ZXNjYXBlZFBhcnRpYWxKc29ufWA7XG4gIH1cbn1cbnZhciBfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sID0gU3ltYm9sKFxuICBcImludGVybmFsX29wZW5haV9mbl9tZXNzYWdlc1wiXG4pO1xuZnVuY3Rpb24gaXNDaGF0Q29tcGxldGlvbkNodW5rKGRhdGEpIHtcbiAgcmV0dXJuIFwiY2hvaWNlc1wiIGluIGRhdGEgJiYgZGF0YS5jaG9pY2VzICYmIGRhdGEuY2hvaWNlc1swXSAmJiBcImRlbHRhXCIgaW4gZGF0YS5jaG9pY2VzWzBdO1xufVxuZnVuY3Rpb24gaXNDb21wbGV0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIFwiY2hvaWNlc1wiIGluIGRhdGEgJiYgZGF0YS5jaG9pY2VzICYmIGRhdGEuY2hvaWNlc1swXSAmJiBcInRleHRcIiBpbiBkYXRhLmNob2ljZXNbMF07XG59XG5mdW5jdGlvbiBPcGVuQUlTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgY29uc3QgY2IgPSBjYWxsYmFja3M7XG4gIGxldCBzdHJlYW07XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICBzdHJlYW0gPSByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGU1KHJlcykpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoXG4gICAgICAgIChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB8fCAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSA/IHtcbiAgICAgICAgICAuLi5jYixcbiAgICAgICAgICBvbkZpbmFsOiB2b2lkIDBcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAuLi5jYlxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0gPSBBSVN0cmVhbShcbiAgICAgIHJlcyxcbiAgICAgIHBhcnNlT3BlbkFJU3RyZWFtKCksXG4gICAgICAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkgfHwgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkgPyB7XG4gICAgICAgIC4uLmNiLFxuICAgICAgICBvbkZpbmFsOiB2b2lkIDBcbiAgICAgIH0gOiB7XG4gICAgICAgIC4uLmNiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBpZiAoY2IgJiYgKGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkpIHtcbiAgICBjb25zdCBmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciA9IGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKGNiKTtcbiAgICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gXCJcIjtcbiAgbGV0IGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9IFwiXCI7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gY2FsbGJhY2tzW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdIHx8IFtdO1xuICBjb25zdCBkZWNvZGUgPSBjcmVhdGVDaHVua0RlY29kZXIoKTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZShjaHVuayk7XG4gICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIGNvbnN0IHNob3VsZEhhbmRsZUFzRnVuY3Rpb24gPSBpc0ZpcnN0Q2h1bmsgJiYgKG1lc3NhZ2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpIHx8IG1lc3NhZ2Uuc3RhcnRzV2l0aCgne1widG9vbF9jYWxsc1wiOicpKTtcbiAgICAgIGlmIChzaG91bGRIYW5kbGVBc0Z1bmN0aW9uKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0Z1bmN0aW9uU3RyZWFtaW5nSW4pIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0NChcInRleHRcIiwgbWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFpc0ZpcnN0Q2h1bmsgJiYgaXNGdW5jdGlvblN0cmVhbWluZ0luICYmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkpIHtcbiAgICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgICAgIGxldCBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzXG4gICAgICAgICAgXTtcbiAgICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZSA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuZnVuY3Rpb25fY2FsbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29sc1wiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudHNQYXlsb2FkID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmd1bWVudHNQYXlsb2FkXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlc3VsdClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzID0ge1xuICAgICAgICAgICAgICB0b29sczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wyIG9mIHBheWxvYWQudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICB0b29sQ2FsbHMudG9vbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IHRvb2wyLmlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBmdW5jOiB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiB0b29sMi5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnBhcnNlKHRvb2wyLmZ1bmN0aW9uLmFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlSW5kZXggPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbChcbiAgICAgICAgICAgICAgICB0b29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRvb2xfY2FsbF9pZCwgZnVuY3Rpb25fbmFtZSwgdG9vbF9jYWxsX3Jlc3VsdCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5uZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGVuZCB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgaWYgaXQncyB0aGUgZmlyc3QgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAuLi5yZXNwb25zZUluZGV4ID09PSAwID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiBwYXlsb2FkLnRvb2xfY2FsbHMubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0Yy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRjLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHNlbmQgdGhlIGFyZ3VtZW50cyBhbiBvYmplY3QgdG8gdGhlIHVzZXIsIGJ1dCBhcyB0aGUgQVBJIGV4cGVjdHMgYSBzdHJpbmcsIHdlIG5lZWQgdG8gc3RyaW5naWZ5IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGMuZnVuY3Rpb24uYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXSA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCByZXN1bHQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHRvb2xfY2FsbF9yZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FsbGluZyBleHBlcmltZW50YWxfb25Ub29sQ2FsbDpcIiwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZnVuY3Rpb25SZXNwb25zZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydDQoXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgPyBcImZ1bmN0aW9uX2NhbGxcIiA6IFwidG9vbF9jYWxsc1wiLFxuICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgdG8gcHJldmVudCBkb3VibGUtZW5jb2Rpbmc6XG4gICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKGFnZ3JlZ2F0ZWRSZXNwb25zZSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZnVuY3Rpb25SZXNwb25zZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDQoXCJ0ZXh0XCIsIGZ1bmN0aW9uUmVzcG9uc2UpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9IGZ1bmN0aW9uUmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgLi4uY2FsbGJhY2tzLFxuICAgICAgICAgICAgb25TdGFydDogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYWxsYmFja3Mub25GaW5hbCA9IHZvaWQgMDtcbiAgICAgICAgICBjb25zdCBvcGVuQUlTdHJlYW0gPSBPcGVuQUlTdHJlYW0oZnVuY3Rpb25SZXNwb25zZSwge1xuICAgICAgICAgICAgLi4uZmlsdGVyZWRDYWxsYmFja3MsXG4gICAgICAgICAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF06IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gb3BlbkFJU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSkge1xuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL3JlcGxpY2F0ZS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIFJlcGxpY2F0ZVN0cmVhbShyZXMsIGNiLCBvcHRpb25zKSB7XG4gIHZhciBfYTExO1xuICBjb25zdCB1cmwgPSAoX2ExMSA9IHJlcy51cmxzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5zdHJlYW07XG4gIGlmICghdXJsKSB7XG4gICAgaWYgKHJlcy5lcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXMuZXJyb3IpO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc3RyZWFtIFVSTCBpbiBSZXBsaWNhdGUgcmVzcG9uc2VcIik7XG4gIH1cbiAgY29uc3QgZXZlbnRTdHJlYW0gPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgQWNjZXB0OiBcInRleHQvZXZlbnQtc3RyZWFtXCIsXG4gICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gQUlTdHJlYW0oZXZlbnRTdHJlYW0sIHZvaWQgMCwgY2IpLnBpcGVUaHJvdWdoKFxuICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpXG4gICk7XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtLXRvLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBzdHJlYW1Ub1Jlc3BvbnNlKHJlcywgcmVzcG9uc2UsIGluaXQsIGRhdGEpIHtcbiAgdmFyIF9hMTE7XG4gIHJlc3BvbnNlLndyaXRlSGVhZCgoX2ExMSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2ExMSA6IDIwMCwge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICB9KTtcbiAgbGV0IHByb2Nlc3NlZFN0cmVhbSA9IHJlcztcbiAgaWYgKGRhdGEpIHtcbiAgICBwcm9jZXNzZWRTdHJlYW0gPSBtZXJnZVN0cmVhbXMoZGF0YS5zdHJlYW0sIHJlcyk7XG4gIH1cbiAgY29uc3QgcmVhZGVyID0gcHJvY2Vzc2VkU3RyZWFtLmdldFJlYWRlcigpO1xuICBmdW5jdGlvbiByZWFkKCkge1xuICAgIHJlYWRlci5yZWFkKCkudGhlbigoeyBkb25lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzcG9uc2Uud3JpdGUodmFsdWUpO1xuICAgICAgcmVhZCgpO1xuICAgIH0pO1xuICB9XG4gIHJlYWQoKTtcbn1cblxuLy8gc3RyZWFtcy9zdHJlYW1pbmctdGV4dC1yZXNwb25zZS50c1xudmFyIFN0cmVhbWluZ1RleHRSZXNwb25zZSA9IGNsYXNzIGV4dGVuZHMgUmVzcG9uc2Uge1xuICBjb25zdHJ1Y3RvcihyZXMsIGluaXQsIGRhdGEpIHtcbiAgICBsZXQgcHJvY2Vzc2VkU3RyZWFtID0gcmVzO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBwcm9jZXNzZWRTdHJlYW0gPSBtZXJnZVN0cmVhbXMoZGF0YS5zdHJlYW0sIHJlcyk7XG4gICAgfVxuICAgIHN1cGVyKHByb2Nlc3NlZFN0cmVhbSwge1xuICAgICAgLi4uaW5pdCxcbiAgICAgIHN0YXR1czogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3RyZWFtcy9pbmRleC50c1xudmFyIGdlbmVyYXRlSWQyID0gZ2VuZXJhdGVJZEltcGw7XG52YXIgbmFub2lkID0gZ2VuZXJhdGVJZEltcGw7XG5leHBvcnQge1xuICBBSVNES0Vycm9yMTAgYXMgQUlTREtFcnJvcixcbiAgQUlTdHJlYW0sXG4gIEFQSUNhbGxFcnJvcjIgYXMgQVBJQ2FsbEVycm9yLFxuICBBV1NCZWRyb2NrQW50aHJvcGljTWVzc2FnZXNTdHJlYW0sXG4gIEFXU0JlZHJvY2tBbnRocm9waWNTdHJlYW0sXG4gIEFXU0JlZHJvY2tDb2hlcmVTdHJlYW0sXG4gIEFXU0JlZHJvY2tMbGFtYTJTdHJlYW0sXG4gIEFXU0JlZHJvY2tTdHJlYW0sXG4gIEFudGhyb3BpY1N0cmVhbSxcbiAgQXNzaXN0YW50UmVzcG9uc2UsXG4gIENvaGVyZVN0cmVhbSxcbiAgRG93bmxvYWRFcnJvcixcbiAgRW1wdHlSZXNwb25zZUJvZHlFcnJvcixcbiAgR29vZ2xlR2VuZXJhdGl2ZUFJU3RyZWFtLFxuICBIdWdnaW5nRmFjZVN0cmVhbSxcbiAgSW5rZWVwU3RyZWFtLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZERhdGFDb250ZW50RXJyb3IsXG4gIEludmFsaWRNZXNzYWdlUm9sZUVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IyIGFzIEludmFsaWRQcm9tcHRFcnJvcixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yLFxuICBKU09OUGFyc2VFcnJvcixcbiAgbGFuZ2NoYWluX2FkYXB0ZXJfZXhwb3J0cyBhcyBMYW5nQ2hhaW5BZGFwdGVyLFxuICBMYW5nQ2hhaW5TdHJlYW0sXG4gIGxsYW1haW5kZXhfYWRhcHRlcl9leHBvcnRzIGFzIExsYW1hSW5kZXhBZGFwdGVyLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIE1lc3NhZ2VDb252ZXJzaW9uRXJyb3IsXG4gIE1pc3RyYWxTdHJlYW0sXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBOb09iamVjdEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBOb1N1Y2hQcm92aWRlckVycm9yLFxuICBOb1N1Y2hUb29sRXJyb3IsXG4gIE9wZW5BSVN0cmVhbSxcbiAgUmVwbGljYXRlU3RyZWFtLFxuICBSZXRyeUVycm9yLFxuICBTdHJlYW1EYXRhMiBhcyBTdHJlYW1EYXRhLFxuICBTdHJlYW1pbmdUZXh0UmVzcG9uc2UsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IyIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3IsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMiBhcyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcixcbiAgY29udmVydFRvQ29yZU1lc3NhZ2VzLFxuICBjb3NpbmVTaW1pbGFyaXR5LFxuICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcixcbiAgY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcixcbiAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyLFxuICBlbWJlZCxcbiAgZW1iZWRNYW55LFxuICBleHBlcmltZW50YWxfQXNzaXN0YW50UmVzcG9uc2UsXG4gIGV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhLFxuICBleHBlcmltZW50YWxfY3JlYXRlTW9kZWxSZWdpc3RyeSxcbiAgZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnksXG4gIGV4cGVyaW1lbnRhbF9jdXN0b21Qcm92aWRlcixcbiAgZXhwZXJpbWVudGFsX2dlbmVyYXRlT2JqZWN0LFxuICBleHBlcmltZW50YWxfZ2VuZXJhdGVUZXh0LFxuICBleHBlcmltZW50YWxfc3RyZWFtT2JqZWN0LFxuICBleHBlcmltZW50YWxfc3RyZWFtVGV4dCxcbiAgZXhwZXJpbWVudGFsX3dyYXBMYW5ndWFnZU1vZGVsLFxuICBmb3JtYXRTdHJlYW1QYXJ0LFxuICBnZW5lcmF0ZUlkMiBhcyBnZW5lcmF0ZUlkLFxuICBnZW5lcmF0ZU9iamVjdCxcbiAgZ2VuZXJhdGVUZXh0LFxuICBqc29uU2NoZW1hLFxuICBuYW5vaWQsXG4gIHBhcnNlU3RyZWFtUGFydCxcbiAgcHJvY2Vzc0RhdGFQcm90b2NvbFJlc3BvbnNlLFxuICByZWFkRGF0YVN0cmVhbSxcbiAgcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSxcbiAgc3RyZWFtT2JqZWN0LFxuICBzdHJlYW1UZXh0LFxuICBzdHJlYW1Ub1Jlc3BvbnNlLFxuICB0b29sLFxuICB0cmltU3RhcnRPZlN0cmVhbUhlbHBlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/node_modules/@ai-sdk/provider-utils/dist/index.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/ai/node_modules/@ai-sdk/provider-utils/dist/index.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asValidator: () => (/* binding */ asValidator),\n/* harmony export */   combineHeaders: () => (/* binding */ combineHeaders),\n/* harmony export */   convertAsyncGeneratorToReadableStream: () => (/* binding */ convertAsyncGeneratorToReadableStream),\n/* harmony export */   convertBase64ToUint8Array: () => (/* binding */ convertBase64ToUint8Array),\n/* harmony export */   convertUint8ArrayToBase64: () => (/* binding */ convertUint8ArrayToBase64),\n/* harmony export */   createEventSourceResponseHandler: () => (/* binding */ createEventSourceResponseHandler),\n/* harmony export */   createIdGenerator: () => (/* binding */ createIdGenerator),\n/* harmony export */   createJsonErrorResponseHandler: () => (/* binding */ createJsonErrorResponseHandler),\n/* harmony export */   createJsonResponseHandler: () => (/* binding */ createJsonResponseHandler),\n/* harmony export */   createJsonStreamResponseHandler: () => (/* binding */ createJsonStreamResponseHandler),\n/* harmony export */   extractResponseHeaders: () => (/* binding */ extractResponseHeaders),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isParsableJson: () => (/* binding */ isParsableJson),\n/* harmony export */   isParseableJson: () => (/* binding */ isParseableJson),\n/* harmony export */   isValidator: () => (/* binding */ isValidator),\n/* harmony export */   loadApiKey: () => (/* binding */ loadApiKey),\n/* harmony export */   loadOptionalSetting: () => (/* binding */ loadOptionalSetting),\n/* harmony export */   loadSetting: () => (/* binding */ loadSetting),\n/* harmony export */   parseJSON: () => (/* binding */ parseJSON),\n/* harmony export */   postJsonToApi: () => (/* binding */ postJsonToApi),\n/* harmony export */   postToApi: () => (/* binding */ postToApi),\n/* harmony export */   safeParseJSON: () => (/* binding */ safeParseJSON),\n/* harmony export */   safeValidateTypes: () => (/* binding */ safeValidateTypes),\n/* harmony export */   validateTypes: () => (/* binding */ validateTypes),\n/* harmony export */   validator: () => (/* binding */ validator),\n/* harmony export */   validatorSymbol: () => (/* binding */ validatorSymbol),\n/* harmony export */   withoutTrailingSlash: () => (/* binding */ withoutTrailingSlash),\n/* harmony export */   zodValidator: () => (/* binding */ zodValidator)\n/* harmony export */ });\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nanoid/non-secure */ \"(rsc)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/ai/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var secure_json_parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! secure-json-parse */ \"(rsc)/./node_modules/secure-json-parse/index.js\");\n/* harmony import */ var eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! eventsource-parser/stream */ \"(rsc)/./node_modules/eventsource-parser/dist/stream.js\");\n// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...currentHeaders != null ? currentHeaders : {}\n    }),\n    {}\n  );\n}\n\n// src/convert-async-generator-to-readable-stream.ts\nfunction convertAsyncGeneratorToReadableStream(stream) {\n  return new ReadableStream({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await stream.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {\n    }\n  });\n}\n\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n  const headers = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n\n// src/generate-id.ts\n\nvar createIdGenerator = ({\n  prefix = \"\",\n  size: defaultSize = 7,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n} = {}) => {\n  const generator = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__.customAlphabet)(alphabet, defaultSize);\n  return (size) => `${prefix}${generator(size)}`;\n};\nvar generateId = createIdGenerator();\n\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n  return error instanceof Error && (error.name === \"AbortError\" || error.name === \"TimeoutError\");\n}\n\n// src/load-api-key.ts\n\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\n\n// src/load-setting.ts\n\nfunction loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof settingValue !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return settingValue;\n}\n\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({\n  settingValue,\n  environmentVariableName\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null || typeof process === \"undefined\") {\n    return void 0;\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null || typeof settingValue !== \"string\") {\n    return void 0;\n  }\n  return settingValue;\n}\n\n// src/parse-json.ts\n\n\n\n// src/validate-types.ts\n\n\n// src/validator.ts\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : zodValidator(value);\n}\nfunction zodValidator(zodSchema) {\n  return validator((value) => {\n    const result = zodSchema.safeParse(value);\n    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n  });\n}\n\n// src/validate-types.ts\nfunction validateTypes({\n  value,\n  schema: inputSchema\n}) {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n  if (!result.success) {\n    throw _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: result.error });\n  }\n  return result.value;\n}\nfunction safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return { success: true, value };\n    }\n    const result = validator2.validate(value);\n    if (result.success) {\n      return result;\n    }\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: result.error })\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: error })\n    };\n  }\n}\n\n// src/parse-json.ts\nfunction parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isJSONParseError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.isTypeValidationError(error)) {\n      throw error;\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({ text, cause: error });\n  }\n}\nfunction safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n    if (schema == null) {\n      return {\n        success: true,\n        value\n      };\n    }\n    return safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isJSONParseError(error) ? error : new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({ text, cause: error })\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar isParseableJson = isParsableJson;\n\n// src/post-to-api.ts\n\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\n\n// src/post-to-api.ts\nvar getOriginalFetch = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error)) {\n          throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error)) {\n          throw error;\n        }\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true\n          // retry when network error\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/response-handler.ts\n\n\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_3__.EventSourceParserStream()).pipeThrough(\n      new TransformStream({\n        transform({ data }, controller) {\n          if (data === \"[DONE]\") {\n            return;\n          }\n          controller.enqueue(\n            safeParseJSON({\n              text: data,\n              schema: chunkSchema\n            })\n          );\n        }\n      })\n    )\n  };\n};\nvar createJsonStreamResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n  }\n  let buffer = \"\";\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n      new TransformStream({\n        transform(chunkText, controller) {\n          if (chunkText.endsWith(\"\\n\")) {\n            controller.enqueue(\n              safeParseJSON({\n                text: buffer + chunkText,\n                schema: chunkSchema\n              })\n            );\n            buffer = \"\";\n          } else {\n            buffer += chunkText;\n          }\n        }\n      })\n    )\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value\n  };\n};\n\n// src/uint8-utils.ts\nvar { btoa, atob } = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\n\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXItdXRpbHMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ21EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ04sb0JBQW9CLGlFQUFjO0FBQ2xDLHNCQUFzQixPQUFPLEVBQUUsZ0JBQWdCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkRBQWU7QUFDN0Isa0JBQWtCLGFBQWE7QUFDL0IsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZEQUFlO0FBQzdCLGtCQUFrQixhQUFhLHlDQUF5QyxvQkFBb0I7QUFDNUYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkRBQWU7QUFDN0Isa0JBQWtCLGFBQWEseUNBQXlDLG9CQUFvQixxQkFBcUIseUJBQXlCO0FBQzFJ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QUMxRTtBQUNBO0FBQ0EsY0FBYyxvRUFBc0IsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtDQUFrQztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYywwREFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBZ0NFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc3Npc3RhbnQtdWktc3RhcnRlci8uL25vZGVfbW9kdWxlcy9haS9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4Lm1qcz85NzZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb21iaW5lLWhlYWRlcnMudHNcbmZ1bmN0aW9uIGNvbWJpbmVIZWFkZXJzKC4uLmhlYWRlcnMpIHtcbiAgcmV0dXJuIGhlYWRlcnMucmVkdWNlKFxuICAgIChjb21iaW5lZEhlYWRlcnMsIGN1cnJlbnRIZWFkZXJzKSA9PiAoe1xuICAgICAgLi4uY29tYmluZWRIZWFkZXJzLFxuICAgICAgLi4uY3VycmVudEhlYWRlcnMgIT0gbnVsbCA/IGN1cnJlbnRIZWFkZXJzIDoge31cbiAgICB9KSxcbiAgICB7fVxuICApO1xufVxuXG4vLyBzcmMvY29udmVydC1hc3luYy1nZW5lcmF0b3ItdG8tcmVhZGFibGUtc3RyZWFtLnRzXG5mdW5jdGlvbiBjb252ZXJ0QXN5bmNHZW5lcmF0b3JUb1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29uc3VtZXIgd2FudHMgdG8gcHVsbCBtb3JlIGRhdGEgZnJvbSB0aGUgc3RyZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFQ+fSBjb250cm9sbGVyIC0gVGhlIGNvbnRyb2xsZXIgdG8gZW5xdWV1ZSBkYXRhIGludG8gdGhlIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbnN1bWVyIGNhbmNlbHMgdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBjYW5jZWwoKSB7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2V4dHJhY3QtcmVzcG9uc2UtaGVhZGVycy50c1xuZnVuY3Rpb24gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSkge1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS1pZC50c1xuaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tIFwibmFub2lkL25vbi1zZWN1cmVcIjtcbnZhciBjcmVhdGVJZEdlbmVyYXRvciA9ICh7XG4gIHByZWZpeCA9IFwiXCIsXG4gIHNpemU6IGRlZmF1bHRTaXplID0gNyxcbiAgYWxwaGFiZXQgPSBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCJcbn0gPSB7fSkgPT4ge1xuICBjb25zdCBnZW5lcmF0b3IgPSBjdXN0b21BbHBoYWJldChhbHBoYWJldCwgZGVmYXVsdFNpemUpO1xuICByZXR1cm4gKHNpemUpID0+IGAke3ByZWZpeH0ke2dlbmVyYXRvcihzaXplKX1gO1xufTtcbnZhciBnZW5lcmF0ZUlkID0gY3JlYXRlSWRHZW5lcmF0b3IoKTtcblxuLy8gc3JjL2dldC1lcnJvci1tZXNzYWdlLnRzXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgaWYgKGVycm9yID09IG51bGwpIHtcbiAgICByZXR1cm4gXCJ1bmtub3duIGVycm9yXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShlcnJvcik7XG59XG5cbi8vIHNyYy9pcy1hYm9ydC1lcnJvci50c1xuZnVuY3Rpb24gaXNBYm9ydEVycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIChlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIiB8fCBlcnJvci5uYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKTtcbn1cblxuLy8gc3JjL2xvYWQtYXBpLWtleS50c1xuaW1wb3J0IHsgTG9hZEFQSUtleUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGxvYWRBcGlLZXkoe1xuICBhcGlLZXksXG4gIGVudmlyb25tZW50VmFyaWFibGVOYW1lLFxuICBhcGlLZXlQYXJhbWV0ZXJOYW1lID0gXCJhcGlLZXlcIixcbiAgZGVzY3JpcHRpb25cbn0pIHtcbiAgaWYgKHR5cGVvZiBhcGlLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYXBpS2V5O1xuICB9XG4gIGlmIChhcGlLZXkgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgbXVzdCBiZSBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBpcyBtaXNzaW5nLiBQYXNzIGl0IHVzaW5nIHRoZSAnJHthcGlLZXlQYXJhbWV0ZXJOYW1lfScgcGFyYW1ldGVyLiBFbnZpcm9ubWVudCB2YXJpYWJsZXMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LmBcbiAgICB9KTtcbiAgfVxuICBhcGlLZXkgPSBwcm9jZXNzLmVudltlbnZpcm9ubWVudFZhcmlhYmxlTmFtZV07XG4gIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7YXBpS2V5UGFyYW1ldGVyTmFtZX0nIHBhcmFtZXRlciBvciB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgYXBpS2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBtdXN0IGJlIGEgc3RyaW5nLiBUaGUgdmFsdWUgb2YgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGFwaUtleTtcbn1cblxuLy8gc3JjL2xvYWQtc2V0dGluZy50c1xuaW1wb3J0IHsgTG9hZFNldHRpbmdFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBsb2FkU2V0dGluZyh7XG4gIHNldHRpbmdWYWx1ZSxcbiAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWUsXG4gIHNldHRpbmdOYW1lLFxuICBkZXNjcmlwdGlvblxufSkge1xuICBpZiAodHlwZW9mIHNldHRpbmdWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzZXR0aW5nVmFsdWU7XG4gIH1cbiAgaWYgKHNldHRpbmdWYWx1ZSAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgbXVzdCBiZSBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7c2V0dGluZ05hbWV9JyBwYXJhbWV0ZXIuIEVudmlyb25tZW50IHZhcmlhYmxlcyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuYFxuICAgIH0pO1xuICB9XG4gIHNldHRpbmdWYWx1ZSA9IHByb2Nlc3MuZW52W2Vudmlyb25tZW50VmFyaWFibGVOYW1lXTtcbiAgaWYgKHNldHRpbmdWYWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7c2V0dGluZ05hbWV9JyBwYXJhbWV0ZXIgb3IgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHNldHRpbmdWYWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIG11c3QgYmUgYSBzdHJpbmcuIFRoZSB2YWx1ZSBvZiB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IGEgc3RyaW5nLmBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xufVxuXG4vLyBzcmMvbG9hZC1vcHRpb25hbC1zZXR0aW5nLnRzXG5mdW5jdGlvbiBsb2FkT3B0aW9uYWxTZXR0aW5nKHtcbiAgc2V0dGluZ1ZhbHVlLFxuICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZVxufSkge1xuICBpZiAodHlwZW9mIHNldHRpbmdWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzZXR0aW5nVmFsdWU7XG4gIH1cbiAgaWYgKHNldHRpbmdWYWx1ZSAhPSBudWxsIHx8IHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBzZXR0aW5nVmFsdWUgPSBwcm9jZXNzLmVudltlbnZpcm9ubWVudFZhcmlhYmxlTmFtZV07XG4gIGlmIChzZXR0aW5nVmFsdWUgPT0gbnVsbCB8fCB0eXBlb2Ygc2V0dGluZ1ZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xufVxuXG4vLyBzcmMvcGFyc2UtanNvbi50c1xuaW1wb3J0IHtcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCBTZWN1cmVKU09OIGZyb20gXCJzZWN1cmUtanNvbi1wYXJzZVwiO1xuXG4vLyBzcmMvdmFsaWRhdGUtdHlwZXMudHNcbmltcG9ydCB7IFR5cGVWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBzcmMvdmFsaWRhdG9yLnRzXG52YXIgdmFsaWRhdG9yU3ltYm9sID0gU3ltYm9sLmZvcihcInZlcmNlbC5haS52YWxpZGF0b3JcIik7XG5mdW5jdGlvbiB2YWxpZGF0b3IodmFsaWRhdGUpIHtcbiAgcmV0dXJuIHsgW3ZhbGlkYXRvclN5bWJvbF06IHRydWUsIHZhbGlkYXRlIH07XG59XG5mdW5jdGlvbiBpc1ZhbGlkYXRvcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIHZhbGlkYXRvclN5bWJvbCBpbiB2YWx1ZSAmJiB2YWx1ZVt2YWxpZGF0b3JTeW1ib2xdID09PSB0cnVlICYmIFwidmFsaWRhdGVcIiBpbiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGFzVmFsaWRhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1ZhbGlkYXRvcih2YWx1ZSkgPyB2YWx1ZSA6IHpvZFZhbGlkYXRvcih2YWx1ZSk7XG59XG5mdW5jdGlvbiB6b2RWYWxpZGF0b3Ioem9kU2NoZW1hKSB7XG4gIHJldHVybiB2YWxpZGF0b3IoKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gem9kU2NoZW1hLnNhZmVQYXJzZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0LmRhdGEgfSA6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByZXN1bHQuZXJyb3IgfTtcbiAgfSk7XG59XG5cbi8vIHNyYy92YWxpZGF0ZS10eXBlcy50c1xuZnVuY3Rpb24gdmFsaWRhdGVUeXBlcyh7XG4gIHZhbHVlLFxuICBzY2hlbWE6IGlucHV0U2NoZW1hXG59KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYTogaW5wdXRTY2hlbWEgfSk7XG4gIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBUeXBlVmFsaWRhdGlvbkVycm9yLndyYXAoeyB2YWx1ZSwgY2F1c2U6IHJlc3VsdC5lcnJvciB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufVxuZnVuY3Rpb24gc2FmZVZhbGlkYXRlVHlwZXMoe1xuICB2YWx1ZSxcbiAgc2NoZW1hXG59KSB7XG4gIGNvbnN0IHZhbGlkYXRvcjIgPSBhc1ZhbGlkYXRvcihzY2hlbWEpO1xuICB0cnkge1xuICAgIGlmICh2YWxpZGF0b3IyLnZhbGlkYXRlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlIH07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvcjIudmFsaWRhdGUodmFsdWUpO1xuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IFR5cGVWYWxpZGF0aW9uRXJyb3Iud3JhcCh7IHZhbHVlLCBjYXVzZTogcmVzdWx0LmVycm9yIH0pXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogVHlwZVZhbGlkYXRpb25FcnJvci53cmFwKHsgdmFsdWUsIGNhdXNlOiBlcnJvciB9KVxuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3BhcnNlLWpzb24udHNcbmZ1bmN0aW9uIHBhcnNlSlNPTih7XG4gIHRleHQsXG4gIHNjaGVtYVxufSkge1xuICB0cnkge1xuICAgIGNvbnN0IHZhbHVlID0gU2VjdXJlSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChKU09OUGFyc2VFcnJvci5pc0pTT05QYXJzZUVycm9yKGVycm9yKSB8fCBUeXBlVmFsaWRhdGlvbkVycm9yMi5pc1R5cGVWYWxpZGF0aW9uRXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEpTT05QYXJzZUVycm9yKHsgdGV4dCwgY2F1c2U6IGVycm9yIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzYWZlUGFyc2VKU09OKHtcbiAgdGV4dCxcbiAgc2NoZW1hXG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdmFsdWUgPSBTZWN1cmVKU09OLnBhcnNlKHRleHQpO1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBzYWZlVmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IEpTT05QYXJzZUVycm9yLmlzSlNPTlBhcnNlRXJyb3IoZXJyb3IpID8gZXJyb3IgOiBuZXcgSlNPTlBhcnNlRXJyb3IoeyB0ZXh0LCBjYXVzZTogZXJyb3IgfSlcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBpc1BhcnNhYmxlSnNvbihpbnB1dCkge1xuICB0cnkge1xuICAgIFNlY3VyZUpTT04ucGFyc2UoaW5wdXQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG52YXIgaXNQYXJzZWFibGVKc29uID0gaXNQYXJzYWJsZUpzb247XG5cbi8vIHNyYy9wb3N0LXRvLWFwaS50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gc3JjL3JlbW92ZS11bmRlZmluZWQtZW50cmllcy50c1xuZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkRW50cmllcyhyZWNvcmQpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhyZWNvcmQpLmZpbHRlcigoW19rZXksIHZhbHVlXSkgPT4gdmFsdWUgIT0gbnVsbClcbiAgKTtcbn1cblxuLy8gc3JjL3Bvc3QtdG8tYXBpLnRzXG52YXIgZ2V0T3JpZ2luYWxGZXRjaCA9ICgpID0+IGdsb2JhbFRoaXMuZmV0Y2g7XG52YXIgcG9zdEpzb25Ub0FwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2hcbn0pID0+IHBvc3RUb0FwaSh7XG4gIHVybCxcbiAgaGVhZGVyczoge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIC4uLmhlYWRlcnNcbiAgfSxcbiAgYm9keToge1xuICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgIHZhbHVlczogYm9keVxuICB9LFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaFxufSk7XG52YXIgcG9zdFRvQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzID0ge30sXG4gIGJvZHksXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoID0gZ2V0T3JpZ2luYWxGZXRjaCgpXG59KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiByZW1vdmVVbmRlZmluZWRFbnRyaWVzKGhlYWRlcnMpLFxuICAgICAgYm9keTogYm9keS5jb250ZW50LFxuICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckluZm9ybWF0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JJbmZvcm1hdGlvbiA9IGF3YWl0IGZhaWxlZFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIGVycm9yIHJlc3BvbnNlXCIsXG4gICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9ySW5mb3JtYXRpb24udmFsdWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3Mgc3VjY2Vzc2Z1bCByZXNwb25zZVwiLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVycm9yLm1lc3NhZ2UgPT09IFwiZmV0Y2ggZmFpbGVkXCIpIHtcbiAgICAgIGNvbnN0IGNhdXNlID0gZXJyb3IuY2F1c2U7XG4gICAgICBpZiAoY2F1c2UgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBgQ2Fubm90IGNvbm5lY3QgdG8gQVBJOiAke2NhdXNlLm1lc3NhZ2V9YCxcbiAgICAgICAgICBjYXVzZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzLFxuICAgICAgICAgIGlzUmV0cnlhYmxlOiB0cnVlXG4gICAgICAgICAgLy8gcmV0cnkgd2hlbiBuZXR3b3JrIGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLy8gc3JjL3Jlc3BvbnNlLWhhbmRsZXIudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IyLCBFbXB0eVJlc3BvbnNlQm9keUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIEV2ZW50U291cmNlUGFyc2VyU3RyZWFtXG59IGZyb20gXCJldmVudHNvdXJjZS1wYXJzZXIvc3RyZWFtXCI7XG52YXIgY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyID0gKHtcbiAgZXJyb3JTY2hlbWEsXG4gIGVycm9yVG9NZXNzYWdlLFxuICBpc1JldHJ5YWJsZVxufSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2VCb2R5LnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkRXJyb3IgPSBwYXJzZUpTT04oe1xuICAgICAgdGV4dDogcmVzcG9uc2VCb2R5LFxuICAgICAgc2NoZW1hOiBlcnJvclNjaGVtYVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICBtZXNzYWdlOiBlcnJvclRvTWVzc2FnZShwYXJzZWRFcnJvciksXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXNwb25zZUJvZHksXG4gICAgICAgIGRhdGE6IHBhcnNlZEVycm9yLFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlLCBwYXJzZWRFcnJvcilcbiAgICAgIH0pXG4gICAgfTtcbiAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9O1xuICB9XG59O1xudmFyIGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyID0gKGNodW5rU2NoZW1hKSA9PiBhc3luYyAoeyByZXNwb25zZSB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVtcHR5UmVzcG9uc2VCb2R5RXJyb3Ioe30pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChuZXcgRXZlbnRTb3VyY2VQYXJzZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKHsgZGF0YSB9LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKGRhdGEgPT09IFwiW0RPTkVdXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgc2FmZVBhcnNlSlNPTih7XG4gICAgICAgICAgICAgIHRleHQ6IGRhdGEsXG4gICAgICAgICAgICAgIHNjaGVtYTogY2h1bmtTY2hlbWFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gIH07XG59O1xudmFyIGNyZWF0ZUpzb25TdHJlYW1SZXNwb25zZUhhbmRsZXIgPSAoY2h1bmtTY2hlbWEpID0+IGFzeW5jICh7IHJlc3BvbnNlIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmIChyZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRW1wdHlSZXNwb25zZUJvZHlFcnJvcih7fSk7XG4gIH1cbiAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oY2h1bmtUZXh0LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKGNodW5rVGV4dC5lbmRzV2l0aChcIlxcblwiKSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBzYWZlUGFyc2VKU09OKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBidWZmZXIgKyBjaHVua1RleHQsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBjaHVua1NjaGVtYVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjaHVua1RleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgfTtcbn07XG52YXIgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlciA9IChyZXNwb25zZVNjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGNvbnN0IHBhcnNlZFJlc3VsdCA9IHNhZmVQYXJzZUpTT04oe1xuICAgIHRleHQ6IHJlc3BvbnNlQm9keSxcbiAgICBzY2hlbWE6IHJlc3BvbnNlU2NoZW1hXG4gIH0pO1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKCFwYXJzZWRSZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3IyKHtcbiAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBKU09OIHJlc3BvbnNlXCIsXG4gICAgICBjYXVzZTogcGFyc2VkUmVzdWx0LmVycm9yLFxuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcGFyc2VkUmVzdWx0LnZhbHVlXG4gIH07XG59O1xuXG4vLyBzcmMvdWludDgtdXRpbHMudHNcbnZhciB7IGJ0b2EsIGF0b2IgfSA9IGdsb2JhbFRoaXM7XG5mdW5jdGlvbiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGJhc2U2NFN0cmluZykge1xuICBjb25zdCBiYXNlNjRVcmwgPSBiYXNlNjRTdHJpbmcucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gIGNvbnN0IGxhdGluMXN0cmluZyA9IGF0b2IoYmFzZTY0VXJsKTtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShsYXRpbjFzdHJpbmcsIChieXRlKSA9PiBieXRlLmNvZGVQb2ludEF0KDApKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoYXJyYXkpIHtcbiAgbGV0IGxhdGluMXN0cmluZyA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBsYXRpbjFzdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYXJyYXlbaV0pO1xuICB9XG4gIHJldHVybiBidG9hKGxhdGluMXN0cmluZyk7XG59XG5cbi8vIHNyYy93aXRob3V0LXRyYWlsaW5nLXNsYXNoLnRzXG5mdW5jdGlvbiB3aXRob3V0VHJhaWxpbmdTbGFzaCh1cmwpIHtcbiAgcmV0dXJuIHVybCA9PSBudWxsID8gdm9pZCAwIDogdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbn1cbmV4cG9ydCB7XG4gIGFzVmFsaWRhdG9yLFxuICBjb21iaW5lSGVhZGVycyxcbiAgY29udmVydEFzeW5jR2VuZXJhdG9yVG9SZWFkYWJsZVN0cmVhbSxcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCxcbiAgY3JlYXRlRXZlbnRTb3VyY2VSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUlkR2VuZXJhdG9yLFxuICBjcmVhdGVKc29uRXJyb3JSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUpzb25TdHJlYW1SZXNwb25zZUhhbmRsZXIsXG4gIGV4dHJhY3RSZXNwb25zZUhlYWRlcnMsXG4gIGdlbmVyYXRlSWQsXG4gIGdldEVycm9yTWVzc2FnZSxcbiAgaXNBYm9ydEVycm9yLFxuICBpc1BhcnNhYmxlSnNvbixcbiAgaXNQYXJzZWFibGVKc29uLFxuICBpc1ZhbGlkYXRvcixcbiAgbG9hZEFwaUtleSxcbiAgbG9hZE9wdGlvbmFsU2V0dGluZyxcbiAgbG9hZFNldHRpbmcsXG4gIHBhcnNlSlNPTixcbiAgcG9zdEpzb25Ub0FwaSxcbiAgcG9zdFRvQXBpLFxuICBzYWZlUGFyc2VKU09OLFxuICBzYWZlVmFsaWRhdGVUeXBlcyxcbiAgdmFsaWRhdGVUeXBlcyxcbiAgdmFsaWRhdG9yLFxuICB2YWxpZGF0b3JTeW1ib2wsXG4gIHdpdGhvdXRUcmFpbGluZ1NsYXNoLFxuICB6b2RWYWxpZGF0b3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/node_modules/@ai-sdk/provider-utils/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/node_modules/@ai-sdk/provider/dist/index.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/ai/node_modules/@ai-sdk/provider/dist/index.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* binding */ AISDKError),\n/* harmony export */   APICallError: () => (/* binding */ APICallError),\n/* harmony export */   EmptyResponseBodyError: () => (/* binding */ EmptyResponseBodyError),\n/* harmony export */   InvalidPromptError: () => (/* binding */ InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* binding */ InvalidResponseDataError),\n/* harmony export */   JSONParseError: () => (/* binding */ JSONParseError),\n/* harmony export */   LoadAPIKeyError: () => (/* binding */ LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* binding */ LoadSettingError),\n/* harmony export */   NoContentGeneratedError: () => (/* binding */ NoContentGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* binding */ TooManyEmbeddingValuesForCallError),\n/* harmony export */   TypeValidationError: () => (/* binding */ TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* binding */ UnsupportedFunctionalityError),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isJSONArray: () => (/* binding */ isJSONArray),\n/* harmony export */   isJSONObject: () => (/* binding */ isJSONObject),\n/* harmony export */   isJSONValue: () => (/* binding */ isJSONValue)\n/* harmony export */ });\n// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name13,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name13;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker14) {\n    const markerSymbol = Symbol.for(marker14);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n  /**\n   * Returns a JSON representation of the error.\n   * @returns {Object} An object containing the error's name, message, and cause.\n   *\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message\n    };\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\n\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isAPICallError(error) {\n    return error instanceof Error && error.name === name && typeof error.url === \"string\" && typeof error.requestBodyValues === \"object\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.responseHeaders == null || typeof error.responseHeaders === \"object\") && (error.responseBody == null || typeof error.responseBody === \"string\") && (error.cause == null || typeof error.cause === \"object\") && typeof error.isRetryable === \"boolean\" && (error.data == null || typeof error.data === \"object\");\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      url: this.url,\n      requestBodyValues: this.requestBodyValues,\n      statusCode: this.statusCode,\n      responseHeaders: this.responseHeaders,\n      responseBody: this.responseBody,\n      cause: this.cause,\n      isRetryable: this.isRetryable,\n      data: this.data\n    };\n  }\n};\n_a2 = symbol2;\n\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isEmptyResponseBodyError(error) {\n    return error instanceof Error && error.name === name2;\n  }\n};\n_a3 = symbol3;\n\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/errors/invalid-prompt-error.ts\nvar name3 = \"AI_InvalidPromptError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidPromptError = class extends AISDKError {\n  constructor({\n    prompt: prompt2,\n    message,\n    cause\n  }) {\n    super({ name: name3, message: `Invalid prompt: ${message}`, cause });\n    this[_a4] = true;\n    this.prompt = prompt2;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidPromptError(error) {\n    return error instanceof Error && error.name === name3 && prompt != null;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      prompt: this.prompt\n    };\n  }\n};\n_a4 = symbol4;\n\n// src/errors/invalid-response-data-error.ts\nvar name4 = \"AI_InvalidResponseDataError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidResponseDataError = class extends AISDKError {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name4, message });\n    this[_a5] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidResponseDataError(error) {\n    return error instanceof Error && error.name === name4 && error.data != null;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      data: this.data\n    };\n  }\n};\n_a5 = symbol5;\n\n// src/errors/json-parse-error.ts\nvar name5 = \"AI_JSONParseError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name5,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a6] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isJSONParseError(error) {\n    return error instanceof Error && error.name === name5 && \"text\" in error && typeof error.text === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n      valueText: this.text\n    };\n  }\n};\n_a6 = symbol6;\n\n// src/errors/load-api-key-error.ts\nvar name6 = \"AI_LoadAPIKeyError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar LoadAPIKeyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name6, message });\n    this[_a7] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadAPIKeyError(error) {\n    return error instanceof Error && error.name === name6;\n  }\n};\n_a7 = symbol7;\n\n// src/errors/load-setting-error.ts\nvar name7 = \"AI_LoadSettingError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadSettingError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadSettingError(error) {\n    return error instanceof Error && error.name === name7;\n  }\n};\n_a8 = symbol8;\n\n// src/errors/no-content-generated-error.ts\nvar name8 = \"AI_NoContentGeneratedError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoContentGeneratedError = class extends AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"No content generated.\"\n  } = {}) {\n    super({ name: name8, message });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker9);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isNoContentGeneratedError(error) {\n    return error instanceof Error && error.name === name8;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      cause: this.cause,\n      message: this.message,\n      stack: this.stack\n    };\n  }\n};\n_a9 = symbol9;\n\n// src/errors/no-such-model-error.ts\nvar name9 = \"AI_NoSuchModelError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoSuchModelError = class extends AISDKError {\n  constructor({\n    errorName = name9,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super({ name: errorName, message });\n    this[_a10] = true;\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker10);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchModelError(error) {\n    return error instanceof Error && error.name === name9 && typeof error.modelId === \"string\" && typeof error.modelType === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      modelId: this.modelId,\n      modelType: this.modelType\n    };\n  }\n};\n_a10 = symbol10;\n\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name10 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError {\n  constructor(options) {\n    super({\n      name: name10,\n      message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n    });\n    this[_a11] = true;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker11);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTooManyEmbeddingValuesForCallError(error) {\n    return error instanceof Error && error.name === name10 && \"provider\" in error && typeof error.provider === \"string\" && \"modelId\" in error && typeof error.modelId === \"string\" && \"maxEmbeddingsPerCall\" in error && typeof error.maxEmbeddingsPerCall === \"number\" && \"values\" in error && Array.isArray(error.values);\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      provider: this.provider,\n      modelId: this.modelId,\n      maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n      values: this.values\n    };\n  }\n};\n_a11 = symbol11;\n\n// src/errors/type-validation-error.ts\nvar name11 = \"AI_TypeValidationError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar _TypeValidationError = class _TypeValidationError extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name11,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a12] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker12);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTypeValidationError(error) {\n    return error instanceof Error && error.name === name11;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n      value: this.value\n    };\n  }\n};\n_a12 = symbol12;\nvar TypeValidationError = _TypeValidationError;\n\n// src/errors/unsupported-functionality-error.ts\nvar name12 = \"AI_UnsupportedFunctionalityError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n  constructor({ functionality }) {\n    super({\n      name: name12,\n      message: `'${functionality}' functionality not supported.`\n    });\n    this[_a13] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isUnsupportedFunctionalityError(error) {\n    return error instanceof Error && error.name === name12 && typeof error.functionality === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      functionality: this.functionality\n    };\n  }\n};\n_a13 = symbol13;\n\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n  if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n  if (typeof value === \"object\") {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n    );\n  }\n  return false;\n}\nfunction isJSONArray(value) {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n  return value != null && typeof value === \"object\" && Object.entries(value).every(\n    ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n  );\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXIvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDLElBQUk7QUFDdEQsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBLGlEQUFpRCxzQkFBc0I7QUFDdkUsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZ0hBQWdILGNBQWM7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW1CRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNzaXN0YW50LXVpLXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXIvZGlzdC9pbmRleC5tanM/YTY1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZXJyb3JzL2FpLXNkay1lcnJvci50c1xudmFyIG1hcmtlciA9IFwidmVyY2VsLmFpLmVycm9yXCI7XG52YXIgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xudmFyIF9hO1xudmFyIF9BSVNES0Vycm9yID0gY2xhc3MgX0FJU0RLRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIEFJIFNESyBFcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjcmVhdGluZyB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5tZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gW3BhcmFtcy5jYXVzZV0gLSBUaGUgdW5kZXJseWluZyBjYXVzZSBvZiB0aGUgZXJyb3IuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZTogbmFtZTEzLFxuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lMTM7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGVycm9yIGlzIGFuIEFJIFNESyBFcnJvci5cbiAgICogQHBhcmFtIHt1bmtub3dufSBlcnJvciAtIFRoZSBlcnJvciB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGVycm9yIGlzIGFuIEFJIFNESyBFcnJvciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gX0FJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG4gIHN0YXRpYyBoYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE0KSB7XG4gICAgY29uc3QgbWFya2VyU3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIxNCk7XG4gICAgcmV0dXJuIGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIG1hcmtlclN5bWJvbCBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3JbbWFya2VyU3ltYm9sXSA9PT0gXCJib29sZWFuXCIgJiYgZXJyb3JbbWFya2VyU3ltYm9sXSA9PT0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZXJyb3IncyBuYW1lLCBtZXNzYWdlLCBhbmQgY2F1c2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xuX2EgPSBzeW1ib2w7XG52YXIgQUlTREtFcnJvciA9IF9BSVNES0Vycm9yO1xuXG4vLyBzcmMvZXJyb3JzL2FwaS1jYWxsLWVycm9yLnRzXG52YXIgbmFtZSA9IFwiQUlfQVBJQ2FsbEVycm9yXCI7XG52YXIgbWFya2VyMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG52YXIgc3ltYm9sMiA9IFN5bWJvbC5mb3IobWFya2VyMik7XG52YXIgX2EyO1xudmFyIEFQSUNhbGxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIHVybCxcbiAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICBzdGF0dXNDb2RlLFxuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICByZXNwb25zZUJvZHksXG4gICAgY2F1c2UsXG4gICAgaXNSZXRyeWFibGUgPSBzdGF0dXNDb2RlICE9IG51bGwgJiYgKHN0YXR1c0NvZGUgPT09IDQwOCB8fCAvLyByZXF1ZXN0IHRpbWVvdXRcbiAgICBzdGF0dXNDb2RlID09PSA0MDkgfHwgLy8gY29uZmxpY3RcbiAgICBzdGF0dXNDb2RlID09PSA0MjkgfHwgLy8gdG9vIG1hbnkgcmVxdWVzdHNcbiAgICBzdGF0dXNDb2RlID49IDUwMCksXG4gICAgLy8gc2VydmVyIGVycm9yXG4gICAgZGF0YVxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMl0gPSB0cnVlO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMucmVxdWVzdEJvZHlWYWx1ZXMgPSByZXF1ZXN0Qm9keVZhbHVlcztcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzO1xuICAgIHRoaXMucmVzcG9uc2VCb2R5ID0gcmVzcG9uc2VCb2R5O1xuICAgIHRoaXMuaXNSZXRyeWFibGUgPSBpc1JldHJ5YWJsZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIyKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc0FQSUNhbGxFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUgJiYgdHlwZW9mIGVycm9yLnVybCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZXJyb3IucmVxdWVzdEJvZHlWYWx1ZXMgPT09IFwib2JqZWN0XCIgJiYgKGVycm9yLnN0YXR1c0NvZGUgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3Iuc3RhdHVzQ29kZSA9PT0gXCJudW1iZXJcIikgJiYgKGVycm9yLnJlc3BvbnNlSGVhZGVycyA9PSBudWxsIHx8IHR5cGVvZiBlcnJvci5yZXNwb25zZUhlYWRlcnMgPT09IFwib2JqZWN0XCIpICYmIChlcnJvci5yZXNwb25zZUJvZHkgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3IucmVzcG9uc2VCb2R5ID09PSBcInN0cmluZ1wiKSAmJiAoZXJyb3IuY2F1c2UgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3IuY2F1c2UgPT09IFwib2JqZWN0XCIpICYmIHR5cGVvZiBlcnJvci5pc1JldHJ5YWJsZSA9PT0gXCJib29sZWFuXCIgJiYgKGVycm9yLmRhdGEgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3IuZGF0YSA9PT0gXCJvYmplY3RcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHRoaXMucmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICBzdGF0dXNDb2RlOiB0aGlzLnN0YXR1c0NvZGUsXG4gICAgICByZXNwb25zZUhlYWRlcnM6IHRoaXMucmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5OiB0aGlzLnJlc3BvbnNlQm9keSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgaXNSZXRyeWFibGU6IHRoaXMuaXNSZXRyeWFibGUsXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG59O1xuX2EyID0gc3ltYm9sMjtcblxuLy8gc3JjL2Vycm9ycy9lbXB0eS1yZXNwb25zZS1ib2R5LWVycm9yLnRzXG52YXIgbmFtZTIgPSBcIkFJX0VtcHR5UmVzcG9uc2VCb2R5RXJyb3JcIjtcbnZhciBtYXJrZXIzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMyA9IFN5bWJvbC5mb3IobWFya2VyMyk7XG52YXIgX2EzO1xudmFyIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlID0gXCJFbXB0eSByZXNwb25zZSBib2R5XCIgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hM10gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIzKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNFbXB0eVJlc3BvbnNlQm9keUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTI7XG4gIH1cbn07XG5fYTMgPSBzeW1ib2wzO1xuXG4vLyBzcmMvZXJyb3JzL2dldC1lcnJvci1tZXNzYWdlLnRzXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgaWYgKGVycm9yID09IG51bGwpIHtcbiAgICByZXR1cm4gXCJ1bmtub3duIGVycm9yXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShlcnJvcik7XG59XG5cbi8vIHNyYy9lcnJvcnMvaW52YWxpZC1wcm9tcHQtZXJyb3IudHNcbnZhciBuYW1lMyA9IFwiQUlfSW52YWxpZFByb21wdEVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNDtcbnZhciBJbnZhbGlkUHJvbXB0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcHJvbXB0OiBwcm9tcHQyLFxuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTMsIG1lc3NhZ2U6IGBJbnZhbGlkIHByb21wdDogJHttZXNzYWdlfWAsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E0XSA9IHRydWU7XG4gICAgdGhpcy5wcm9tcHQgPSBwcm9tcHQyO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI0KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkUHJvbXB0RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMyAmJiBwcm9tcHQgIT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgcHJvbXB0OiB0aGlzLnByb21wdFxuICAgIH07XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtcmVzcG9uc2UtZGF0YS1lcnJvci50c1xudmFyIG5hbWU0ID0gXCJBSV9JbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3JcIjtcbnZhciBtYXJrZXI1ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU0fWA7XG52YXIgc3ltYm9sNSA9IFN5bWJvbC5mb3IobWFya2VyNSk7XG52YXIgX2E1O1xudmFyIEludmFsaWRSZXNwb25zZURhdGFFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCByZXNwb25zZSBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfS5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E1XSA9IHRydWU7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTQgJiYgZXJyb3IuZGF0YSAhPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG59O1xuX2E1ID0gc3ltYm9sNTtcblxuLy8gc3JjL2Vycm9ycy9qc29uLXBhcnNlLWVycm9yLnRzXG52YXIgbmFtZTUgPSBcIkFJX0pTT05QYXJzZUVycm9yXCI7XG52YXIgbWFya2VyNiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDYgPSBTeW1ib2wuZm9yKG1hcmtlcjYpO1xudmFyIF9hNjtcbnZhciBKU09OUGFyc2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgdGV4dCwgY2F1c2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWU1LFxuICAgICAgbWVzc2FnZTogYEpTT04gcGFyc2luZyBmYWlsZWQ6IFRleHQ6ICR7dGV4dH0uXG5FcnJvciBtZXNzYWdlOiAke2dldEVycm9yTWVzc2FnZShjYXVzZSl9YCxcbiAgICAgIGNhdXNlXG4gICAgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNKU09OUGFyc2VFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU1ICYmIFwidGV4dFwiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci50ZXh0ID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHZhbHVlVGV4dDogdGhpcy50ZXh0XG4gICAgfTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG5cbi8vIHNyYy9lcnJvcnMvbG9hZC1hcGkta2V5LWVycm9yLnRzXG52YXIgbmFtZTYgPSBcIkFJX0xvYWRBUElLZXlFcnJvclwiO1xudmFyIG1hcmtlcjcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTZ9YDtcbnZhciBzeW1ib2w3ID0gU3ltYm9sLmZvcihtYXJrZXI3KTtcbnZhciBfYTc7XG52YXIgTG9hZEFQSUtleUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hN10gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI3KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc0xvYWRBUElLZXlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU2O1xuICB9XG59O1xuX2E3ID0gc3ltYm9sNztcblxuLy8gc3JjL2Vycm9ycy9sb2FkLXNldHRpbmctZXJyb3IudHNcbnZhciBuYW1lNyA9IFwiQUlfTG9hZFNldHRpbmdFcnJvclwiO1xudmFyIG1hcmtlcjggPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTd9YDtcbnZhciBzeW1ib2w4ID0gU3ltYm9sLmZvcihtYXJrZXI4KTtcbnZhciBfYTg7XG52YXIgTG9hZFNldHRpbmdFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTcsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYThdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyOCk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNMb2FkU2V0dGluZ0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTc7XG4gIH1cbn07XG5fYTggPSBzeW1ib2w4O1xuXG4vLyBzcmMvZXJyb3JzL25vLWNvbnRlbnQtZ2VuZXJhdGVkLWVycm9yLnRzXG52YXIgbmFtZTggPSBcIkFJX05vQ29udGVudEdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyOSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOH1gO1xudmFyIHN5bWJvbDkgPSBTeW1ib2wuZm9yKG1hcmtlcjkpO1xudmFyIF9hOTtcbnZhciBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gY29udGVudCBnZW5lcmF0ZWQuXCJcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOV0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc05vQ29udGVudEdlbmVyYXRlZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTg7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrXG4gICAgfTtcbiAgfVxufTtcbl9hOSA9IHN5bWJvbDk7XG5cbi8vIHNyYy9lcnJvcnMvbm8tc3VjaC1tb2RlbC1lcnJvci50c1xudmFyIG5hbWU5ID0gXCJBSV9Ob1N1Y2hNb2RlbEVycm9yXCI7XG52YXIgbWFya2VyMTAgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTl9YDtcbnZhciBzeW1ib2wxMCA9IFN5bWJvbC5mb3IobWFya2VyMTApO1xudmFyIF9hMTA7XG52YXIgTm9TdWNoTW9kZWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlcnJvck5hbWUgPSBuYW1lOSxcbiAgICBtb2RlbElkLFxuICAgIG1vZGVsVHlwZSxcbiAgICBtZXNzYWdlID0gYE5vIHN1Y2ggJHttb2RlbFR5cGV9OiAke21vZGVsSWR9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBlcnJvck5hbWUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTEwXSA9IHRydWU7XG4gICAgdGhpcy5tb2RlbElkID0gbW9kZWxJZDtcbiAgICB0aGlzLm1vZGVsVHlwZSA9IG1vZGVsVHlwZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTApO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc05vU3VjaE1vZGVsRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lOSAmJiB0eXBlb2YgZXJyb3IubW9kZWxJZCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZXJyb3IubW9kZWxUeXBlID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWQsXG4gICAgICBtb2RlbFR5cGU6IHRoaXMubW9kZWxUeXBlXG4gICAgfTtcbiAgfVxufTtcbl9hMTAgPSBzeW1ib2wxMDtcblxuLy8gc3JjL2Vycm9ycy90b28tbWFueS1lbWJlZGRpbmctdmFsdWVzLWZvci1jYWxsLWVycm9yLnRzXG52YXIgbmFtZTEwID0gXCJBSV9Ub29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yXCI7XG52YXIgbWFya2VyMTEgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEwfWA7XG52YXIgc3ltYm9sMTEgPSBTeW1ib2wuZm9yKG1hcmtlcjExKTtcbnZhciBfYTExO1xudmFyIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTEwLFxuICAgICAgbWVzc2FnZTogYFRvbyBtYW55IHZhbHVlcyBmb3IgYSBzaW5nbGUgZW1iZWRkaW5nIGNhbGwuIFRoZSAke29wdGlvbnMucHJvdmlkZXJ9IG1vZGVsIFwiJHtvcHRpb25zLm1vZGVsSWR9XCIgY2FuIG9ubHkgZW1iZWQgdXAgdG8gJHtvcHRpb25zLm1heEVtYmVkZGluZ3NQZXJDYWxsfSB2YWx1ZXMgcGVyIGNhbGwsIGJ1dCAke29wdGlvbnMudmFsdWVzLmxlbmd0aH0gdmFsdWVzIHdlcmUgcHJvdmlkZWQuYFxuICAgIH0pO1xuICAgIHRoaXNbX2ExMV0gPSB0cnVlO1xuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRpb25zLnByb3ZpZGVyO1xuICAgIHRoaXMubW9kZWxJZCA9IG9wdGlvbnMubW9kZWxJZDtcbiAgICB0aGlzLm1heEVtYmVkZGluZ3NQZXJDYWxsID0gb3B0aW9ucy5tYXhFbWJlZGRpbmdzUGVyQ2FsbDtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUxMCAmJiBcInByb3ZpZGVyXCIgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLnByb3ZpZGVyID09PSBcInN0cmluZ1wiICYmIFwibW9kZWxJZFwiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5tb2RlbElkID09PSBcInN0cmluZ1wiICYmIFwibWF4RW1iZWRkaW5nc1BlckNhbGxcIiBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IubWF4RW1iZWRkaW5nc1BlckNhbGwgPT09IFwibnVtYmVyXCIgJiYgXCJ2YWx1ZXNcIiBpbiBlcnJvciAmJiBBcnJheS5pc0FycmF5KGVycm9yLnZhbHVlcyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkLFxuICAgICAgbWF4RW1iZWRkaW5nc1BlckNhbGw6IHRoaXMubWF4RW1iZWRkaW5nc1BlckNhbGwsXG4gICAgICB2YWx1ZXM6IHRoaXMudmFsdWVzXG4gICAgfTtcbiAgfVxufTtcbl9hMTEgPSBzeW1ib2wxMTtcblxuLy8gc3JjL2Vycm9ycy90eXBlLXZhbGlkYXRpb24tZXJyb3IudHNcbnZhciBuYW1lMTEgPSBcIkFJX1R5cGVWYWxpZGF0aW9uRXJyb3JcIjtcbnZhciBtYXJrZXIxMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTF9YDtcbnZhciBzeW1ib2wxMiA9IFN5bWJvbC5mb3IobWFya2VyMTIpO1xudmFyIF9hMTI7XG52YXIgX1R5cGVWYWxpZGF0aW9uRXJyb3IgPSBjbGFzcyBfVHlwZVZhbGlkYXRpb25FcnJvciBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IHZhbHVlLCBjYXVzZSB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTExLFxuICAgICAgbWVzc2FnZTogYFR5cGUgdmFsaWRhdGlvbiBmYWlsZWQ6IFZhbHVlOiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0uXG5FcnJvciBtZXNzYWdlOiAke2dldEVycm9yTWVzc2FnZShjYXVzZSl9YCxcbiAgICAgIGNhdXNlXG4gICAgfSk7XG4gICAgdGhpc1tfYTEyXSA9IHRydWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMik7XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBzIGFuIGVycm9yIGludG8gYSBUeXBlVmFsaWRhdGlvbkVycm9yLlxuICAgKiBJZiB0aGUgY2F1c2UgaXMgYWxyZWFkeSBhIFR5cGVWYWxpZGF0aW9uRXJyb3Igd2l0aCB0aGUgc2FtZSB2YWx1ZSwgaXQgcmV0dXJucyB0aGUgY2F1c2UuXG4gICAqIE90aGVyd2lzZSwgaXQgY3JlYXRlcyBhIG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHdyYXBwaW5nIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHt1bmtub3dufSBwYXJhbXMudmFsdWUgLSBUaGUgdmFsdWUgdGhhdCBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICogQHBhcmFtIHt1bmtub3dufSBwYXJhbXMuY2F1c2UgLSBUaGUgb3JpZ2luYWwgZXJyb3Igb3IgY2F1c2Ugb2YgdGhlIHZhbGlkYXRpb24gZmFpbHVyZS5cbiAgICogQHJldHVybnMge1R5cGVWYWxpZGF0aW9uRXJyb3J9IEEgVHlwZVZhbGlkYXRpb25FcnJvciBpbnN0YW5jZS5cbiAgICovXG4gIHN0YXRpYyB3cmFwKHtcbiAgICB2YWx1ZSxcbiAgICBjYXVzZVxuICB9KSB7XG4gICAgcmV0dXJuIF9UeXBlVmFsaWRhdGlvbkVycm9yLmlzSW5zdGFuY2UoY2F1c2UpICYmIGNhdXNlLnZhbHVlID09PSB2YWx1ZSA/IGNhdXNlIDogbmV3IF9UeXBlVmFsaWRhdGlvbkVycm9yKHsgdmFsdWUsIGNhdXNlIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc1R5cGVWYWxpZGF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMTE7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICB9O1xuICB9XG59O1xuX2ExMiA9IHN5bWJvbDEyO1xudmFyIFR5cGVWYWxpZGF0aW9uRXJyb3IgPSBfVHlwZVZhbGlkYXRpb25FcnJvcjtcblxuLy8gc3JjL2Vycm9ycy91bnN1cHBvcnRlZC1mdW5jdGlvbmFsaXR5LWVycm9yLnRzXG52YXIgbmFtZTEyID0gXCJBSV9VbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvclwiO1xudmFyIG1hcmtlcjEzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMn1gO1xudmFyIHN5bWJvbDEzID0gU3ltYm9sLmZvcihtYXJrZXIxMyk7XG52YXIgX2ExMztcbnZhciBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgZnVuY3Rpb25hbGl0eSB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTEyLFxuICAgICAgbWVzc2FnZTogYCcke2Z1bmN0aW9uYWxpdHl9JyBmdW5jdGlvbmFsaXR5IG5vdCBzdXBwb3J0ZWQuYFxuICAgIH0pO1xuICAgIHRoaXNbX2ExM10gPSB0cnVlO1xuICAgIHRoaXMuZnVuY3Rpb25hbGl0eSA9IGZ1bmN0aW9uYWxpdHk7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEzKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc1Vuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTEyICYmIHR5cGVvZiBlcnJvci5mdW5jdGlvbmFsaXR5ID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBmdW5jdGlvbmFsaXR5OiB0aGlzLmZ1bmN0aW9uYWxpdHlcbiAgICB9O1xuICB9XG59O1xuX2ExMyA9IHN5bWJvbDEzO1xuXG4vLyBzcmMvanNvbi12YWx1ZS9pcy1qc29uLnRzXG5mdW5jdGlvbiBpc0pTT05WYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGlzSlNPTlZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAgIChba2V5LCB2YWxdKSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGlzSlNPTlZhbHVlKHZhbClcbiAgICApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSlNPTkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShpc0pTT05WYWx1ZSk7XG59XG5mdW5jdGlvbiBpc0pTT05PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAoW2tleSwgdmFsXSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiBpc0pTT05WYWx1ZSh2YWwpXG4gICk7XG59XG5leHBvcnQge1xuICBBSVNES0Vycm9yLFxuICBBUElDYWxsRXJyb3IsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvcixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBKU09OUGFyc2VFcnJvcixcbiAgTG9hZEFQSUtleUVycm9yLFxuICBMb2FkU2V0dGluZ0Vycm9yLFxuICBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcixcbiAgTm9TdWNoTW9kZWxFcnJvcixcbiAgVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvcixcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IsXG4gIGdldEVycm9yTWVzc2FnZSxcbiAgaXNKU09OQXJyYXksXG4gIGlzSlNPTk9iamVjdCxcbiAgaXNKU09OVmFsdWVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/node_modules/@ai-sdk/provider/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/node_modules/nanoid/non-secure/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ai/node_modules/nanoid/non-secure/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),\n/* harmony export */   nanoid: () => (/* binding */ nanoid)\n/* harmony export */ });\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Fzc2lzdGFudC11aS1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL2FpL25vZGVfbW9kdWxlcy9uYW5vaWQvbm9uLXNlY3VyZS9pbmRleC5qcz9jZGYzIl0sInNvdXJjZXNDb250ZW50IjpbImxldCB1cmxBbHBoYWJldCA9XG4gICd1c2VhbmRvbS0yNlQxOTgzNDBQWDc1cHhKQUNLVkVSWU1JTkRCVVNIV09MRl9HUVpiZmdoamtscXZ3eXpyaWN0J1xubGV0IGN1c3RvbUFscGhhYmV0ID0gKGFscGhhYmV0LCBkZWZhdWx0U2l6ZSA9IDIxKSA9PiB7XG4gIHJldHVybiAoc2l6ZSA9IGRlZmF1bHRTaXplKSA9PiB7XG4gICAgbGV0IGlkID0gJydcbiAgICBsZXQgaSA9IHNpemVcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZCArPSBhbHBoYWJldFsoTWF0aC5yYW5kb20oKSAqIGFscGhhYmV0Lmxlbmd0aCkgfCAwXVxuICAgIH1cbiAgICByZXR1cm4gaWRcbiAgfVxufVxubGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gJydcbiAgbGV0IGkgPSBzaXplXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZCArPSB1cmxBbHBoYWJldFsoTWF0aC5yYW5kb20oKSAqIDY0KSB8IDBdXG4gIH1cbiAgcmV0dXJuIGlkXG59XG5leHBvcnQgeyBuYW5vaWQsIGN1c3RvbUFscGhhYmV0IH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\n");

/***/ })

};
;